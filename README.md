# Learning_ReactJs
>
> "This repository contains my learning journey with ReactJS, including various projects and exercises. ..."

<br>

### Table of Contents

### Level 0: Basics & Prerequisites

| Topic | Subtopic |
|-------|----------|
| Vanilla JavaScript & API Calls | |
| DOM Manipulation | select, modify, create, delete elements |
| Event Handling & Debugging | Chrome DevTools |
| Fetch API | GET, POST requests |
| JavaScript ES6 | let/const |
| JavaScript ES6 | functions |
| JavaScript ES6 | operators |
| JavaScript ES6 | destructuring |
| JavaScript ES6 | template literals |
| Functional Programming | map |
| Functional Programming | reduce |
| Functional Programming | filter |
| Understanding jQuery | |
| JavaScript Fundamentals | Code Execution & Global Context |
| JavaScript Fundamentals | Event Loop, Call Stack & Concurrency |
| JavaScript Fundamentals | Hoisting |
| JavaScript Fundamentals | var/let/const |
| JavaScript Fundamentals | Arrow Functions & 'this' |
| JavaScript Fundamentals | Closures & Lexical Scope |
| JavaScript Fundamentals | Classes, Objects, Getters/Setters |
| JavaScript Fundamentals | Public/Private/Protected |
| JavaScript Fundamentals | Working with Objects |
| JavaScript Fundamentals | Optional Chaining |
| JavaScript Fundamentals | Nullish Coalescing |
| JavaScript Fundamentals | Logical OR |
| JavaScript Fundamentals | Destructuring (Object & Array) |
| JavaScript Fundamentals | Shallow & Deep Copy |
| JavaScript Fundamentals | filter |
| JavaScript Fundamentals | map |
| JavaScript Fundamentals | reduce |
| JavaScript Fundamentals | join |
| JavaScript Fundamentals | split |
| JavaScript Fundamentals | find |
| JavaScript Fundamentals | findIndex |
| JavaScript Fundamentals | splice |
| JavaScript Fundamentals | slice |
| JavaScript Fundamentals | Apply |
| JavaScript Fundamentals | Bind |
| JavaScript Fundamentals | Call |
| JavaScript Fundamentals | Prototype & Inheritance |
| JavaScript Fundamentals | Boolean Values |
| JavaScript Fundamentals | Spread & Rest Operator |
| JavaScript Fundamentals | Ternary Operator & Short-Circuiting |
| JavaScript Fundamentals | Set & Map |
| JavaScript Fundamentals | Event Delegation & Bubbling |
| JavaScript Fundamentals | Promises |
| JavaScript Fundamentals | Async/Await |
| JavaScript Fundamentals | Memoization |
| JavaScript Fundamentals | Debouncing |
| JavaScript Fundamentals | Throttling |
| JavaScript Fundamentals | ES6 Modules |
| JavaScript Fundamentals | export default vs named exports |

<br>

<br>

### Level 1: React Fundamentals (Basics to Intermediate)

| Topic | Subtopic |
|-------|----------|
| Getting Started with React | [Introduction to React and Declarative UI](#introduction-to-react-and-declarative-ui) |
| Getting Started with React | [Virtual DOM and Reconciliation](#virtual-dom-and-reconciliation) |
| Getting Started with React | [Setting Up Development Environment](#setting-up-development-environment) |
| Getting Started with React | [Creating Your First React App](#creating-your-first-react-app) |
| Getting Started with React | [React Project Structure](#react-project-structure) |
| Getting Started with React | [NPM vs NPX vs NVM](#npm-vs-npx-vs-nvm) |
| Getting Started with React | [Caret and Tilde](#caret-and-tilde) |
| Getting Started with React | [Writing Code from Scratch](#writing-code-from-scratch) |
| Getting Started with React | [Creating and Publishing NPM Packages](#creating-and-publishing-npm-packages) |
| React Core Concepts | [JSX HTML like Syntax in JS](#jsx-html-like-syntax-in-js) |
| React Core Concepts | [Babel How JSX Works](#babel-how-jsx-works) |
| React Core Concepts | [Naming Conventions CamelCase PascalCase Kebab Case](#naming-conventions-camelcase-pascalcase-kebab-case) |
| React Core Concepts | [React Fragments](#react-fragments) |
| React Core Concepts | [JavaScript Expressions in JSX](#javascript-expressions-in-jsx) |
| React Core Concepts | [Dynamic Attributes in JSX](#dynamic-attributes-in-jsx) |
| React Core Concepts | [Handling Events in React](#handling-events-in-react) |
| React Core Concepts | [State in React](#state-in-react) |
| React Core Concepts | [Introduction to React Hooks](#introduction-to-react-hooks) |
| React Core Concepts | [useState for State Management](#usestate-for-state-management) |
| React Core Concepts | [Handling User Input in Forms](#handling-user-input-in-forms) |
| React Core Concepts | [Rendering Lists with map()](#rendering-lists-with-map) |
| React Core Concepts | [Mastering Props Passing Data](#mastering-props-passing-data) |
| React Core Concepts | [Web DevTools Deep Dive](#web-devtools-deep-dive) |
| Component Patterns & State | [Building Reusable Components](#building-reusable-components) |
| Component Patterns & State | [Rendering and Managing Task Cards](#rendering-and-managing-task-cards) |
| Component Patterns & State | [Delete Functionality for Tasks](#delete-functionality-for-tasks) |
| Component Patterns & State | [Persisting Tasks in Local Storage](#persisting-tasks-in-local-storage) |
| Component Patterns & State | [React Strict Mode](#react-strict-mode) |
| Component Patterns & State | [Tag Selection and Filtering UI](#tag-selection-and-filtering-ui) |
| Component Patterns & State | [Customizing Fonts and Styling Tailwind MaterialUI](#customizing-fonts-and-styling-tailwind-materialui) |
| React Routing | [Setting Up Routing](#setting-up-routing) |
| React Routing | [Not Found Page](#not-found-page) |
| React Routing | [SPA with React Router](#spa-with-react-router) |
| React Routing | [Route Parameters and Query Strings](#route-parameters-and-query-strings) |
| React Routing | [Nested Routing and Programmatic Navigation](#nested-routing-and-programmatic-navigation) |
| API Integration | [useEffect and Dependency Array](#useeffect-and-dependency-array) |
| API Integration | [Fetching Data fetch Axios](#fetching-data-fetch-axios) |
| API Integration | [Loaders and Error Handling](#loaders-and-error-handling) |
| API Integration | [Promises vs Async Await](#promises-vs-async-await) |
| API Integration | [POST PUT DELETE with Axios](#post-put-delete-with-axios) |

<br>

<br>

### Level 2: Intermediate to Advanced

| Topic | Subtopic |
|-------|----------|
| Advanced React Concepts | [React Design Patterns Container Presentational](#react-design-patterns-container-presentational) |
| Advanced React Concepts | [Higher Order Components HOC](#higher-order-components-hoc) |
| Advanced React Concepts | [Custom Hooks](#custom-hooks) |
| Advanced React Concepts | [Deep Dive into Hooks useEffect](#deep-dive-into-hooks-useeffect) |
| Advanced React Concepts | [useRef](#useref) |
| Advanced React Concepts | [useImperativeHandle](#useimperativehandle) |
| Advanced React Concepts | [useMemo](#usememo) |
| Advanced React Concepts | [useCallback](#usecallback) |
| Advanced React Concepts | [useContext](#usecontext) |
| Advanced React Concepts | [useReducer](#usereducer) |
| Advanced React Concepts | [React 19 Hooks useActionState](#react-19-hooks-useactionstate) |
| Advanced React Concepts | [useFormStatus](#useformstatus) |
| Advanced React Concepts | [useOptimistic](#useoptimistic) |
| Advanced React Concepts | [use API](#use-api) |
| Advanced React Concepts | [Passing Refs as Props](#passing-refs-as-props) |
| Advanced React Concepts | [React as a Wrapper](#react-as-a-wrapper) |
| Advanced React Concepts | [Reconciliation and How React Works Under the Hood](#reconciliation-and-how-react-works-under-the-hood) |
| Advanced React Concepts | [Prop Drilling](#prop-drilling) |
| Advanced React Concepts | [Context API](#context-api) |
| Advanced React Concepts | [Suspense API](#suspense-api) |
| Advanced React Concepts | [State Management Tools](#state-management-tools) |
| Advanced React Concepts | [Performance Optimization Minimize Renders](#performance-optimization-minimize-renders) |
| Advanced React Concepts | [React Hook Form](#react-hook-form) |
| Advanced React Concepts | [Formik](#formik) |
| Advanced React Concepts | [SWR](#swr) |
| Advanced React Concepts | [React Query](#react-query) |
| React Query | [State Management for API Data](#state-management-for-api-data) |
| React Query | [Data Fetching](#data-fetching) |
| React Query | [Caching](#caching) |
| React Query | [Synchronization](#synchronization) |
| React Query | [Project Based Learning with React Query](#project-based-learning-with-react-query) |
| Testing | [Introduction to Testing in React](#introduction-to-testing-in-react) |
| Testing | [Setting Up Jest and Component Testing](#setting-up-jest-and-component-testing) |
| Testing | [Mocking and Spying](#mocking-and-spying) |
| Testing | [Testing Async Code](#testing-async-code) |
| Testing | [Project Test Login Page and UI](#project-test-login-page-and-ui) |
| Best Practices & Tooling | [Webpack Mastery](#webpack-mastery) |
| Best Practices & Tooling | [Essential Git Commands](#essential-git-commands) |
| Best Practices & Tooling | [Docker Setup for React](#docker-setup-for-react) |
| Best Practices & Tooling | [CI CD with GitLab](#ci-cd-with-gitlab) |
| Best Practices & Tooling | [Tooling Bootstrapping](#tooling-bootstrapping) |
| Best Practices & Tooling | [Webpack](#webpack) |
| Best Practices & Tooling | [Vite](#vite) |
| Best Practices & Tooling | [Parcel](#parcel) |
| AI & Generative AI in Frontend | [What is AI and GenAI](#what-is-ai-and-genai) |
| AI & Generative AI in Frontend | [GenAI in Frontend](#genai-in-frontend) |
| AI & Generative AI in Frontend | [Text to Image Generation App](#text-to-image-generation-app) |
| AI & Generative AI in Frontend | [AI-Powered Chatbot App](#ai-powered-chatbot-app) |
| AI & Generative AI in Frontend | [Leveraging AI as a Software Engineer](#leveraging-ai-as-a-software-engineer) |
| Machine Coding & System Design | [HTML & CSS Mastery](#html-and-css-mastery) |
| Machine Coding & System Design | [Output-Based Interview Questions](#output-based-interview-questions) |
| Machine Coding & System Design | [LeetCode-Inspired Coding Challenges](#leetcode-inspired-coding-challenges) |
| Machine Coding & System Design | [Hands On Interview Prep JS and React](#hands-on-interview-prep-js-and-react) |
| Machine Coding & System Design | [System Design Interviews](#system-design-interviews) |
| Why NextJS is the Future of React | [Modern React Ecosystem](#modern-react-ecosystem) |
| Why NextJS is the Future of React | [NextJS vs ReactJS](#nextjs-vs-reactjs) |
| Why NextJS is the Future of React | [NextJS vs NestJS](#nextjs-vs-nestjs) |

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Introduction to React and Declarative UI

Imagine you're building with LEGO blocks. Instead of telling each block exactly where to go step by step, you just describe what the final castle should look like, and the blocks magically arrange themselves!

**Key Points:**

- React is a JavaScript library for building user interfaces
- Declarative means you describe WHAT you want, not HOW to do it
- Components are reusable pieces of UI (like LEGO blocks)
- React handles the DOM updates for you

**Real-life example:** Like ordering food at a restaurant - you tell the waiter "I want a burger with fries" (declarative) instead of going to the kitchen and cooking it yourself step by step (imperative).

<Details>
<Summary>Code example :</Summary>

```javascript
// Declarative approach with React
function Welcome() {
  return <h1>Hello, World!</h1>;
}

// vs Imperative approach (vanilla JS)
const element = document.createElement('h1');
element.textContent = 'Hello, World!';
document.body.appendChild(element);
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Virtual DOM and Reconciliation

Imagine you have a rough draft of your drawing before making the final version. React keeps a "rough draft" of your webpage in memory, compares it with the real webpage, and only changes the parts that are different!

**Key Points:**

- Virtual DOM is a JavaScript copy of the real DOM
- React compares old and new Virtual DOM (diffing)
- Only updates changed parts (reconciliation)
- Makes apps super fast

**Real-life example:** Like editing a document - instead of retyping the whole page, you only change the words that need fixing.

<Details>
<Summary>Code example :</Summary>

```javascript
// When state changes, React creates new Virtual DOM
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p> {/* Only this updates when count changes */}
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Setting Up Development Environment

Before you can build awesome LEGO creations, you need to set up your workspace with all the right tools and pieces organized!

**Key Points:**

- Install Node.js (JavaScript runtime)
- Install a code editor (VS Code recommended)
- Install browser extensions for React
- Set up terminal/command prompt

**Real-life example:** Like setting up your art desk with paints, brushes, and paper before starting to draw.

<Details>
<Summary>Code example :</Summary>

```bash
# Check if Node.js is installed
node --version
npm --version

# Install VS Code extensions
# - ES7+ React/Redux/React-Native snippets
# - Bracket Pair Colorizer
# - Auto Rename Tag
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Creating Your First React App

It's like getting a pre-built LEGO starter kit that already has the basic structure, so you can start building your castle right away!

**Key Points:**

- Create React App is a tool that sets everything up
- Provides development server with hot reload
- Includes build tools and testing setup
- No configuration needed to start

**Real-life example:** Like buying a cake mix instead of gathering flour, eggs, and sugar separately - everything you need is already included!

<Details>
<Summary>example :</Summary>

```bash
# Create a new React app
npx create-react-app my-first-app

# Navigate to the project
cd my-first-app

# Start the development server
npm start
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Project Structure

Think of your React project like organizing your bedroom - everything has its special place so you can find it easily!

**Key Points:**

- `src/` folder contains your React code
- `public/` folder has static files
- `package.json` lists all dependencies
- `App.js` is your main component

**Real-life example:** Like organizing your school backpack - textbooks in one section, pens in another, lunch in a separate compartment.

<Details>
<Summary>example :</Summary>

```
my-react-app/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── App.js
│   ├── App.css
│   ├── index.js
│   └── components/
├── package.json
└── node_modules/
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### NPM vs NPX vs NVM

Think of these as different types of helpers in your toy store - NPM is the store manager, NPX is the temporary helper, and NVM helps you switch between different store layouts!

**Key Points:**

- NPM = Node Package Manager (installs and manages packages)
- NPX = Node Package Execute (runs packages without installing)
- NVM = Node Version Manager (switches between Node.js versions)

**Real-life example:** NPM is like buying toys to keep, NPX is like renting toys for a day, NVM is like having different toy boxes for different ages.

<Details>
<Summary>example :</Summary>

```bash
# NPM - Install and keep packages
npm install react

# NPX - Run packages temporarily
npx create-react-app my-app

# NVM - Switch Node versions
nvm use 18.0.0
nvm list
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Caret and Tilde

These are like rules for your toy collection - the caret (^) says "I'm okay with newer toys from the same brand" and tilde (~) says "I only want tiny improvements to my exact toy."

**Key Points:**

- Caret (^) allows minor and patch updates
- Tilde (~) allows only patch updates
- Helps control which package versions to use
- Prevents breaking changes

**Real-life example:** Like saying "I want LEGO version 2.x.x or newer" (^) vs "I only want LEGO 2.1.x fixes" (~).

<Details>
<Summary> example :</Summary>

```json
{
  "dependencies": {
    "react": "^18.2.0",    // Allows 18.2.0 to 18.9.9
    "lodash": "~4.17.20"   // Allows 4.17.20 to 4.17.99
  }
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Writing Code from Scratch

Instead of using pre-made LEGO sets, you're building everything from individual blocks - it's harder but you learn exactly how everything fits together!

**Key Points:**

- Understanding core concepts deeply
- No magic or hidden configurations
- Better debugging skills
- Full control over your code

**Real-life example:** Like learning to bake a cake from scratch instead of using a cake mix - you understand every ingredient.

<Details>
<Summary>Code example :</Summary>

```javascript
// Creating React without Create React App
import React from 'react';
import ReactDOM from 'react-dom/client';

function App() {
  return <h1>Built from scratch!</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Creating and Publishing NPM Packages

It's like creating your own toy and sharing it with kids all around the world so they can play with it too!

**Key Points:**

- Package.json defines your package
- NPM registry stores packages globally
- Semantic versioning (1.2.3 = major.minor.patch)
- Anyone can install and use your package

**Real-life example:** Like creating a cool LEGO instruction manual and sharing it so other kids can build the same awesome creation.

<Details>
<Summary> example :</Summary>

```bash
# Initialize new package
npm init

# Publish to NPM
npm publish

# Install someone else's package
npm install awesome-react-component
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### JSX HTML like Syntax in JS

JSX is like being able to draw pictures directly in your story book instead of having to describe them with just words!

**Key Points:**

- JSX looks like HTML but it's actually JavaScript
- Makes writing UI components easier
- Gets converted to regular JavaScript
- Can mix HTML-like syntax with JavaScript logic

**Real-life example:** Like writing a comic book where you can draw pictures right in the middle of your sentences.

<Details>
<Summary>Code example :</Summary>

```javascript
// JSX - looks like HTML
function Welcome() {
  const name = "Alice";
  return <h1>Hello, {name}!</h1>;
}

// What it becomes (regular JavaScript)
function Welcome() {
  const name = "Alice";
  return React.createElement('h1', null, 'Hello, ', name, '!');
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Babel How JSX Works

Babel is like a magical translator that turns your easy-to-read comic book language into the complicated language that computers understand!

**Key Points:**

- Babel transpiles JSX to regular JavaScript
- Browsers don't understand JSX natively
- Happens during build process
- Allows modern JavaScript features

**Real-life example:** Like having a friend translate your English homework into French for your French teacher.

<Details>
<Summary>Code example :</Summary>

```javascript
// Before Babel (JSX)
const element = <h1>Hello World</h1>;

// After Babel (JavaScript)
const element = React.createElement('h1', null, 'Hello World');
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Naming Conventions CamelCase PascalCase Kebab Case

Different types of naming are like different ways of writing your name - sometimes "johnSmith", sometimes "JohnSmith", sometimes "john-smith" - each has its special place!

**Key Points:**

- camelCase: variables and functions (firstName)
- PascalCase: components and classes (MyComponent)
- kebab-case: CSS classes and HTML attributes (my-class)
- SCREAMING_CASE: constants (API_KEY)

**Real-life example:** Like how you write your name differently on your backpack (John), your homework (john smith), and your locker (JOHN-SMITH).

<Details>
<Summary>Code example :</Summary>

```javascript
// PascalCase for components
function MyAwesomeComponent() {
  // camelCase for variables
  const userName = "Alice";
  const handleButtonClick = () => {};

  return (
    <div className="my-component">  {/* kebab-case for CSS */}
      <h1>{userName}</h1>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Fragments

Fragments are like invisible gift boxes - they help you group your toys together without adding an extra box that everyone can see!

**Key Points:**

- Groups elements without extra DOM nodes
- Avoids unnecessary wrapper divs
- Two syntaxes: <React.Fragment> or <>
- Keeps HTML structure clean

**Real-life example:** Like putting multiple cookies on a plate without wrapping them in a bag first.

<Details>
<Summary>Code example :</Summary>

```javascript
// Without Fragment (creates extra div)
function BadExample() {
  return (
    <div>  {/* Extra wrapper div */}
      <h1>Title</h1>
      <p>Description</p>
    </div>
  );
}

// With Fragment (no extra wrapper)
function GoodExample() {
  return (
    <>
      <h1>Title</h1>
      <p>Description</p>
    </>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### JavaScript Expressions in JSX

It's like being able to do math problems right in the middle of writing a sentence - you put curly braces {} around the math part!

**Key Points:**

- Use {} to embed JavaScript in JSX
- Can contain variables, functions, expressions
- Only expressions, not statements (no if/for)
- Automatically converts to strings for display

**Real-life example:** Like writing "I have {2 + 3} apples" and it shows "I have 5 apples".

<Details>
<Summary>Code example :</Summary>

```javascript
function MathExample() {
  const name = "Alice";
  const age = 10;

  return (
    <div>
      <h1>Hello {name}!</h1>
      <p>Next year you'll be {age + 1} years old</p>
      <p>Your name has {name.length} letters</p>
      <p>{age >= 13 ? "Teenager" : "Kid"}</p>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Dynamic Attributes in JSX

It's like having a magic sticker that changes color based on your mood - the sticker's color attribute changes depending on how you're feeling!

**Key Points:**

- Attributes can use JavaScript expressions
- Use {} for dynamic values
- className instead of class
- camelCase for attribute names

**Real-life example:** Like a name tag that automatically shows your current favorite color.

<Details>
<Summary>Code example :</Summary>

```javascript
function DynamicButton() {
  const isActive = true;
  const buttonText = "Click me!";
  const buttonColor = isActive ? "blue" : "gray";

  return (
    <button
      className={isActive ? "active-btn" : "inactive-btn"}
      style={{backgroundColor: buttonColor}}
      disabled={!isActive}
    >
      {buttonText}
    </button>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Handling Events in React

It's like teaching your toy robot to respond when you press its buttons - you tell it exactly what to do when someone clicks, types, or touches!

**Key Points:**

- Use camelCase event names (onClick, onChange)
- Pass function references, not calls
- SyntheticEvents work across all browsers
- Can prevent default behavior

**Real-life example:** Like programming a doorbell to play different songs when pressed.

<Details>
<Summary>Code example :</Summary>

```javascript
function InteractiveButton() {
  const handleClick = () => {
    alert("Button was clicked!");
  };

  const handleMouseOver = () => {
    console.log("Mouse is over the button!");
  };

  return (
    <button
      onClick={handleClick}
      onMouseOver={handleMouseOver}
    >
      Hover and Click me!
    </button>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### State in React

State is like your toy robot's memory - it remembers important things like whether it's on or off, what color it is, or how many steps it has taken!

**Key Points:**

- State stores data that can change over time
- When state changes, component re-renders
- Each component has its own state
- State updates are asynchronous

**Real-life example:** Like a digital pet that remembers how hungry it is, how happy it is, and its current level.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
      <button onClick={() => setCount(count - 1)}>
        Decrease
      </button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Introduction to React Hooks

Hooks are like special tools that let your toy components do amazing things - like remember stuff, talk to other toys, or react to changes around them!

**Key Points:**

- Hooks let functional components use features like state
- Start with "use" (useState, useEffect, etc.)
- Only call at the top level of components
- Can create custom hooks

**Real-life example:** Like giving your action figures special powers - one remembers things, another can detect when it's moved.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState, useEffect } from 'react';

function HookExample() {
  const [count, setCount] = useState(0);

  // useEffect hook - runs after render
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useState for State Management

useState is like having a special memory box for your toy - you can put something in it, check what's inside, and replace it with something new whenever you want!

**Key Points:**

- Returns current state value and setter function
- State updates trigger re-renders
- Can hold any type of data
- Previous state available in updater function

**Real-life example:** Like a scoreboard that shows your current score and has buttons to change it.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';

function StateExamples() {
  const [name, setName] = useState(""); // String state
  const [age, setAge] = useState(0);    // Number state
  const [isVisible, setIsVisible] = useState(true); // Boolean state

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />
      <button onClick={() => setAge(age + 1)}>
        Age: {age}
      </button>
      {isVisible && <p>Hello {name}!</p>}
      <button onClick={() => setIsVisible(!isVisible)}>
        Toggle Message
      </button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Handling User Input in Forms

It's like having a conversation with your computer - you type something, the computer listens and remembers what you said, then it can respond back to you!

**Key Points:**

- Controlled components: React controls input values
- Use onChange to track input changes
- value prop makes inputs controlled
- Form submission with onSubmit

**Real-life example:** Like filling out a worksheet where each answer you write gets saved immediately.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';

function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Hello ${formData.name}!`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Your name"
      />
      <input
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Your email"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Rendering Lists with map

It's like having a magic copying machine - you give it a list of your favorite toys, and it creates a display case showing each toy with its name and picture!

**Key Points:**

- Use .map() to transform arrays into JSX elements
- Each item needs a unique key prop
- Keys help React track changes efficiently
- Can filter arrays before mapping

**Real-life example:** Like creating name tags for everyone in your class from a list of students.

<Details>
<Summary>Code example :</Summary>

```javascript
function TodoList() {
  const todos = [
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Build an app", completed: false },
    { id: 3, text: "Have fun coding", completed: true }
  ];

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id} style={{
          textDecoration: todo.completed ? 'line-through' : 'none'
        }}>
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Mastering Props Passing Data

Props are like passing notes between toys - one toy can send information, pictures, or instructions to another toy so they can work together!

**Key Points:**

- Props pass data from parent to child components
- Props are read-only (immutable)
- Can pass any type of data (strings, numbers, functions, objects)
- Use destructuring for cleaner code

**Real-life example:** Like giving your friend the ingredients and recipe so they can help you bake cookies.

<Details>
<Summary>Code example :</Summary>

```javascript
// Parent component
function App() {
  const userData = {
    name: "Alice",
    age: 12,
    favoriteColor: "blue"
  };

  return (
    <div>
      <UserCard
        name={userData.name}
        age={userData.age}
        color={userData.favoriteColor}
        onButtonClick={() => alert("Hello!")}
      />
    </div>
  );
}

// Child component
function UserCard({ name, age, color, onButtonClick }) {
  return (
    <div style={{ borderColor: color }}>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <button onClick={onButtonClick}>
        Say Hello!
      </button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Web DevTools Deep Dive

DevTools are like having X-ray vision and a detective kit for your web app - you can see inside, find problems, and understand exactly what's happening!

**Key Points:**

- React Developer Tools extension shows component tree
- Console for debugging and testing
- Network tab shows data loading
- Elements tab for inspecting HTML/CSS

**Real-life example:** Like having a special magnifying glass that shows you how all the parts of your toy robot work inside.

<Details>
<Summary>Code example :</Summary>

```javascript
function DebuggingExample() {
  const [count, setCount] = useState(0);

  // Console logging for debugging
  console.log("Component rendered, count is:", count);

  const handleClick = () => {
    console.log("Button clicked!");
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Click me</button>
      {/* This will show in React DevTools */}
    </div>
  );
}

// Debugging tips:
// 1. Use console.log() to see values
// 2. Use React DevTools to inspect props/state
// 3. Use breakpoints in browser debugger
// 4. Check Network tab for API calls
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Building Reusable Components

It's like creating a magic template for making toys - once you design the perfect toy robot template, you can create hundreds of different robots just by changing their colors, sizes, or special features!

**Key Points:**

- Components should do one thing well (Single Responsibility Principle)
- Use props to make components flexible and customizable
- Keep components small and focused
- Think about what parts can be reused across your app

**Real-life example:** Like creating a cookie cutter - once you have the shape, you can make cookies with different flavors, colors, or decorations using the same basic template.

<Details>
<Summary>Code example :</Summary>

```javascript
// Reusable Button Component
function Button({
  text,
  color = "blue",
  size = "medium",
  onClick,
  disabled = false
}) {
  const sizeClasses = {
    small: "px-2 py-1 text-sm",
    medium: "px-4 py-2 text-base",
    large: "px-6 py-3 text-lg"
  };

  return (
    <button
      className={`${sizeClasses[size]} bg-${color}-500 text-white rounded hover:bg-${color}-600 disabled:opacity-50`}
      onClick={onClick}
      disabled={disabled}
    >
      {text}
    </button>
  );
}

// Reusable Card Component
function Card({ title, children, className = "" }) {
  return (
    <div className={`bg-white shadow-md rounded-lg p-4 ${className}`}>
      {title && <h3 className="text-lg font-bold mb-2">{title}</h3>}
      {children}
    </div>
  );
}

// Using the reusable components
function App() {
  return (
    <div>
      <Card title="My Profile">
        <p>Welcome to my profile!</p>
        <Button text="Edit Profile" color="green" onClick={() => alert("Edit!")} />
        <Button text="Delete" color="red" size="small" onClick={() => alert("Delete!")} />
      </Card>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Rendering and Managing Task Cards

It's like having a bulletin board where you can pin up different task cards, and each card shows the task details, status, and has buttons to interact with it!

**Key Points:**

- Each task is represented as a card component
- Cards display task information clearly
- Use state to manage list of tasks
- Map through tasks to render multiple cards

**Real-life example:** Like having a collection of Pokemon cards where each card shows different information (name, type, powers) and you can organize them in different ways.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';

// Task Card Component
function TaskCard({ task, onEdit, onDelete, onToggleComplete }) {
  return (
    <div className={`p-4 border rounded-lg shadow-sm ${task.completed ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200'}`}>
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <h3 className={`font-semibold ${task.completed ? 'line-through text-gray-500' : 'text-gray-800'}`}>
            {task.title}
          </h3>
          <p className="text-sm text-gray-600 mt-1">{task.description}</p>
          <div className="flex gap-2 mt-2">
            {task.tags.map(tag => (
              <span key={tag} className="px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded">
                {tag}
              </span>
            ))}
          </div>
          <p className="text-xs text-gray-400 mt-2">Due: {task.dueDate}</p>
        </div>

        <div className="flex gap-2 ml-4">
          <button
            onClick={() => onToggleComplete(task.id)}
            className={`px-3 py-1 rounded text-sm ${
              task.completed
                ? 'bg-yellow-500 text-white hover:bg-yellow-600'
                : 'bg-green-500 text-white hover:bg-green-600'
            }`}
          >
            {task.completed ? 'Undo' : 'Complete'}
          </button>
          <button
            onClick={() => onEdit(task.id)}
            className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
          >
            Edit
          </button>
          <button
            onClick={() => onDelete(task.id)}
            className="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600"
          >
            Delete
          </button>
        </div>
      </div>
    </div>
  );
}

// Main Task Manager Component
function TaskManager() {
  const [tasks, setTasks] = useState([
    {
      id: 1,
      title: "Learn React Components",
      description: "Understand how to build reusable components",
      tags: ["react", "learning"],
      dueDate: "2023-12-31",
      completed: false
    },
    {
      id: 2,
      title: "Build Todo App",
      description: "Create a complete todo application",
      tags: ["project", "javascript"],
      dueDate: "2023-11-15",
      completed: true
    }
  ]);

  const handleEdit = (taskId) => {
    console.log("Editing task:", taskId);
    // Add edit functionality here
  };

  const handleDelete = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId));
  };

  const handleToggleComplete = (taskId) => {
    setTasks(tasks.map(task =>
      task.id === taskId
        ? { ...task, completed: !task.completed }
        : task
    ));
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">My Tasks</h1>
      <div className="space-y-4">
        {tasks.map(task => (
          <TaskCard
            key={task.id}
            task={task}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleComplete={handleToggleComplete}
          />
        ))}
      </div>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Delete Functionality for Tasks

It's like having a magic eraser that can remove specific drawings from your sketchbook - you point at what you want to delete, confirm you really want it gone, and *poof* it disappears!

**Key Points:**

- Use filter() to remove items from arrays
- Always confirm before deleting (user experience)
- Update state immutably (don't modify original array)
- Consider undo functionality for better UX

**Real-life example:** Like removing a specific photo from your photo album - you find the photo, decide to remove it, and the album reorganizes itself automatically.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';

function TaskList() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn React", completed: false },
    { id: 2, title: "Build a project", completed: false },
    { id: 3, title: "Practice coding", completed: true }
  ]);

  const [showDeleteConfirm, setShowDeleteConfirm] = useState(null);

  // Simple delete function
  const deleteTask = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId));
  };

  // Delete with confirmation
  const deleteTaskWithConfirm = (taskId) => {
    if (window.confirm("Are you sure you want to delete this task?")) {
      deleteTask(taskId);
    }
  };

  // Delete with custom confirmation modal
  const showDeleteModal = (taskId) => {
    setShowDeleteConfirm(taskId);
  };

  const confirmDelete = () => {
    if (showDeleteConfirm) {
      deleteTask(showDeleteConfirm);
      setShowDeleteConfirm(null);
    }
  };

  const cancelDelete = () => {
    setShowDeleteConfirm(null);
  };

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-4">Task List</h2>

      {/* Task List */}
      <div className="space-y-2">
        {tasks.map(task => (
          <div key={task.id} className="flex items-center justify-between p-3 border rounded">
            <span className={task.completed ? 'line-through text-gray-500' : ''}>
              {task.title}
            </span>
            <div className="space-x-2">
              {/* Simple delete button */}
              <button
                onClick={() => deleteTaskWithConfirm(task.id)}
                className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600"
              >
                Quick Delete
              </button>

              {/* Delete with modal */}
              <button
                onClick={() => showDeleteModal(task.id)}
                className="px-3 py-1 bg-orange-500 text-white rounded hover:bg-orange-600"
              >
                Delete with Modal
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Custom Delete Confirmation Modal */}
      {showDeleteConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
          <div className="bg-white p-6 rounded-lg shadow-lg">
            <h3 className="text-lg font-semibold mb-4">Confirm Delete</h3>
            <p className="mb-4">Are you sure you want to delete this task? This action cannot be undone.</p>
            <div className="flex gap-3">
              <button
                onClick={confirmDelete}
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
              >
                Yes, Delete
              </button>
              <button
                onClick={cancelDelete}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Advanced: Delete with Undo functionality
function TaskListWithUndo() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn React", completed: false },
    { id: 2, title: "Build a project", completed: false }
  ]);
  const [deletedTask, setDeletedTask] = useState(null);
  const [showUndo, setShowUndo] = useState(false);

  const deleteTaskWithUndo = (taskId) => {
    const taskToDelete = tasks.find(task => task.id === taskId);
    const updatedTasks = tasks.filter(task => task.id !== taskId);

    setTasks(updatedTasks);
    setDeletedTask(taskToDelete);
    setShowUndo(true);

    // Auto-hide undo after 5 seconds
    setTimeout(() => {
      setShowUndo(false);
      setDeletedTask(null);
    }, 5000);
  };

  const undoDelete = () => {
    if (deletedTask) {
      setTasks([...tasks, deletedTask]);
      setDeletedTask(null);
      setShowUndo(false);
    }
  };

  return (
    <div className="p-6">
      {/* Undo notification */}
      {showUndo && (
        <div className="mb-4 p-3 bg-yellow-100 border-l-4 border-yellow-500 flex justify-between items-center">
          <span>Task "{deletedTask?.title}" was deleted</span>
          <button
            onClick={undoDelete}
            className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
          >
            Undo
          </button>
        </div>
      )}

      {/* Tasks */}
      <div className="space-y-2">
        {tasks.map(task => (
          <div key={task.id} className="flex items-center justify-between p-3 border rounded">
            <span>{task.title}</span>
            <button
              onClick={() => deleteTaskWithUndo(task.id)}
              className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600"
            >
              Delete
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Persisting Tasks in Local Storage

It's like having a magic notebook that automatically saves everything you write, so even if you close the notebook and come back later, all your notes are still there!

**Key Points:**

- localStorage saves data in the browser permanently
- Data persists even after closing the browser
- Always handle JSON parsing errors
- Sync state with localStorage on every change

**Real-life example:** Like having a diary that magically saves your entries and remembers them even if you put it away for months.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState, useEffect } from 'react';

function TaskAppWithStorage() {
  // Initialize state from localStorage or use default
  const [tasks, setTasks] = useState(() => {
    try {
      const savedTasks = localStorage.getItem('tasks');
      return savedTasks ? JSON.parse(savedTasks) : [];
    } catch (error) {
      console.error('Error loading tasks from localStorage:', error);
      return [];
    }
  });

  // Save to localStorage whenever tasks change
  useEffect(() => {
    try {
      localStorage.setItem('tasks', JSON.stringify(tasks));
    } catch (error) {
      console.error('Error saving tasks to localStorage:', error);
    }
  }, [tasks]);

  // Add new task
  const addTask = (taskText) => {
    const newTask = {
      id: Date.now(), // Simple ID generation
      text: taskText,
      completed: false,
      createdAt: new Date().toISOString()
    };
    setTasks([...tasks, newTask]);
  };

  // Toggle task completion
  const toggleTask = (taskId) => {
    setTasks(tasks.map(task =>
      task.id === taskId
        ? { ...task, completed: !task.completed }
        : task
    ));
  };

  // Delete task
  const deleteTask = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId));
  };

  // Clear all tasks
  const clearAllTasks = () => {
    if (window.confirm('Are you sure you want to clear all tasks?')) {
      setTasks([]);
      localStorage.removeItem('tasks'); // Optional: remove from storage completely
    }
  };

  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h1 className="text-2xl font-bold mb-4">My Persistent Tasks</h1>

      {/* Add Task Form */}
      <TaskForm onAddTask={addTask} />

      {/* Task Count */}
      <div className="mb-4 text-sm text-gray-600">
        Total: {tasks.length} tasks ({tasks.filter(t => !t.completed).length} pending)
      </div>

      {/* Task List */}
      <div className="space-y-2 mb-4">
        {tasks.length === 0 ? (
          <p className="text-gray-500 text-center py-4">No tasks yet. Add one above!</p>
        ) : (
          tasks.map(task => (
            <TaskItem
              key={task.id}
              task={task}
              onToggle={() => toggleTask(task.id)}
              onDelete={() => deleteTask(task.id)}
            />
          ))
        )}
      </div>

      {/* Clear All Button */}
      {tasks.length > 0 && (
        <button
          onClick={clearAllTasks}
          className="w-full px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
        >
          Clear All Tasks
        </button>
      )}
    </div>
  );
}

// Task Form Component
function TaskForm({ onAddTask }) {
  const [inputValue, setInputValue] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      onAddTask(inputValue.trim());
      setInputValue('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="mb-4">
      <div className="flex gap-2">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Add a new task..."
          className="flex-1 px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
        />
        <button
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
          disabled={!inputValue.trim()}
        >
          Add
        </button>
      </div>
    </form>
  );
}

// Task Item Component
function TaskItem({ task, onToggle, onDelete }) {
  return (
    <div className="flex items-center gap-3 p-3 border rounded-lg">
      <input
        type="checkbox"
        checked={task.completed}
        onChange={onToggle}
        className="w-4 h-4"
      />
      <span className={`flex-1 ${task.completed ? 'line-through text-gray-500' : ''}`}>
        {task.text}
      </span>
      <button
        onClick={onDelete}
        className="px-2 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600"
      >
        Delete
      </button>
    </div>
  );
}

// Advanced: Custom hook for localStorage
function useLocalStorage(key, initialValue) {
  // Initialize state with value from localStorage or initialValue
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Function to set value in both state and localStorage
  const setValue = (value) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}

// Using the custom hook
function TaskAppWithCustomHook() {
  const [tasks, setTasks] = useLocalStorage('myTasks', []);

  const addTask = (text) => {
    const newTask = {
      id: Date.now(),
      text,
      completed: false
    };
    setTasks([...tasks, newTask]);
  };

  return (
    <div>
      <h1>Tasks with Custom Hook</h1>
      {/* Rest of the component */}
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Strict Mode

Strict Mode is like having a super careful teacher who double-checks your work and points out potential problems before they become big issues!

**Key Points:**

- Helps catch bugs early in development
- Renders components twice to detect side effects
- Warns about unsafe lifecycle methods
- Only runs in development mode (not production)

**Real-life example:** Like having a spell-checker that not only finds typos but also suggests better ways to write your sentences.

<Details>
<Summary>Code example :</Summary>

```javascript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

// Enabling Strict Mode for your entire app
function App() {
  return (
    <StrictMode>
      <Header />
      <MainContent />
      <Footer />
    </StrictMode>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// Or enable it just for specific components
function MyApp() {
  return (
    <div>
      <Header />
      <StrictMode>
        <ExperimentalComponent /> {/* Only this component runs in strict mode */}
      </StrictMode>
      <Footer />
    </div>
  );
}

// Example: Component with side effects (Strict Mode will help catch this)
function ProblematicComponent() {
  const [count, setCount] = useState(0);

  // ❌ BAD: Side effect in render (Strict Mode will run this twice)
  console.log('Component rendering...'); // This will log twice in Strict Mode

  // ❌ BAD: Direct DOM manipulation in render
  // document.title = `Count: ${count}`; // Don't do this!

  // ✅ GOOD: Side effects in useEffect
  useEffect(() => {
    console.log('Effect running...'); // This is fine
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Example: What Strict Mode helps you catch
function ComponentWithProblems() {
  const [users, setUsers] = useState([]);

  // ❌ BAD: This will cause problems in Strict Mode
  const fetchUsers = () => {
    fetch('/api/users')
      .then(response => response.json())
      .then(data => {
        setUsers(data); // This might set state after component unmounts
      });
  };

  // ✅ GOOD: Proper cleanup
  useEffect(() => {
    let cancelled = false;

    fetch('/api/users')
      .then(response => response.json())
      .then(data => {
        if (!cancelled) { // Only set state if component is still mounted
          setUsers(data);
        }
      });

    return () => {
      cancelled = true; // Cleanup function
    };
  }, []);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Example: Creating React app with Strict Mode (index.js)
/*
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const root = createRoot(document.getElementById('root'));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
*/

// What Strict Mode does:
// 1. Renders components twice to catch side effects
// 2. Warns about deprecated APIs
// 3. Helps identify unsafe lifecycles
// 4. Warns about legacy string ref API usage
// 5. Detects unexpected side effects

// Common issues Strict Mode helps catch:
function ExampleIssues() {
  const [data, setData] = useState([]);

  // Issue 1: Impure render function
  const randomId = Math.random(); // ❌ This changes on every render

  // Issue 2: Missing cleanup in useEffect
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 1000);

    // ❌ Missing cleanup - memory leak!
    // return () => clearInterval(timer); // Should have this
  }, []);

  // Issue 3: Mutating props or state directly
  const handleAddItem = (newItem) => {
    data.push(newItem); // ❌ Mutating state directly
    setData(data); // Won't trigger re-render properly

    // ✅ Should be:
    // setData([...data, newItem]);
  };

  return <div>Component with issues</div>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Tag Selection and Filtering UI

It's like having a magical sorting hat for your tasks - you can pick different colored tags and only see the tasks that match those colors, making it super easy to find exactly what you're looking for!

**Key Points:**

- Tags help categorize and organize tasks
- Filtering allows users to focus on specific categories
- Use state to track selected tags and filter logic
- Visual feedback shows which tags are active

**Real-life example:** Like organizing your clothes by color or type - you can choose to see only "school clothes" or "play clothes" when you're getting dressed.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';

function TaskManagerWithTags() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn React Components", tags: ["react", "learning", "frontend"], completed: false },
    { id: 2, title: "Build API endpoint", tags: ["backend", "api", "work"], completed: false },
    { id: 3, title: "Design homepage", tags: ["design", "frontend", "work"], completed: true },
    { id: 4, title: "Study for exam", tags: ["learning", "personal"], completed: false },
    { id: 5, title: "Fix bug in login", tags: ["bug", "backend", "urgent"], completed: false }
  ]);

  const [selectedTags, setSelectedTags] = useState([]);
  const [filterMode, setFilterMode] = useState('all'); // 'all', 'any', 'none'

  // Get all unique tags from all tasks
  const allTags = [...new Set(tasks.flatMap(task => task.tags))];

  // Filter tasks based on selected tags
  const filteredTasks = tasks.filter(task => {
    if (selectedTags.length === 0) return true;

    switch (filterMode) {
      case 'all':
        return selectedTags.every(tag => task.tags.includes(tag));
      case 'any':
        return selectedTags.some(tag => task.tags.includes(tag));
      case 'none':
        return !selectedTags.some(tag => task.tags.includes(tag));
      default:
        return true;
    }
  });

  // Toggle tag selection
  const toggleTag = (tag) => {
    setSelectedTags(prev =>
      prev.includes(tag)
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
  };

  // Clear all selected tags
  const clearAllTags = () => {
    setSelectedTags([]);
  };

  // Predefined tag colors for better UI
  const tagColors = {
    react: "bg-blue-500",
    learning: "bg-green-500",
    frontend: "bg-purple-500",
    backend: "bg-orange-500",
    api: "bg-yellow-500",
    work: "bg-red-500",
    design: "bg-pink-500",
    personal: "bg-gray-500",
    bug: "bg-red-600",
    urgent: "bg-red-700"
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">Task Manager with Tags</h1>

      {/* Tag Filter Section */}
      <div className="bg-gray-50 p-4 rounded-lg mb-6">
        <h3 className="font-semibold mb-3">Filter by Tags:</h3>

        {/* Filter Mode Selection */}
        <div className="mb-3">
          <label className="text-sm font-medium text-gray-700 mr-3">Filter Mode:</label>
          <select
            value={filterMode}
            onChange={(e) => setFilterMode(e.target.value)}
            className="px-2 py-1 border rounded text-sm"
          >
            <option value="any">Any selected tag (OR)</option>
            <option value="all">All selected tags (AND)</option>
            <option value="none">None of selected tags (NOT)</option>
          </select>
        </div>

        {/* Tag Selection */}
        <div className="flex flex-wrap gap-2 mb-3">
          {allTags.map(tag => (
            <TagButton
              key={tag}
              tag={tag}
              isSelected={selectedTags.includes(tag)}
              onClick={() => toggleTag(tag)}
              color={tagColors[tag] || "bg-gray-400"}
            />
          ))}
        </div>

        {/* Clear and Info */}
        <div className="flex justify-between items-center text-sm text-gray-600">
          <span>
            {selectedTags.length > 0
              ? `Showing ${filteredTasks.length} of ${tasks.length} tasks`
              : `Showing all ${tasks.length} tasks`
            }
          </span>
          {selectedTags.length > 0 && (
            <button
              onClick={clearAllTags}
              className="text-blue-500 hover:text-blue-700"
            >
              Clear filters
            </button>
          )}
        </div>
      </div>

      {/* Selected Tags Display */}
      {selectedTags.length > 0 && (
        <div className="mb-4">
          <span className="text-sm font-medium text-gray-700 mr-2">Active filters:</span>
          {selectedTags.map(tag => (
            <span key={tag} className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 text-sm rounded mr-2 mb-1">
              {tag}
              <button
                onClick={() => toggleTag(tag)}
                className="text-blue-600 hover:text-blue-800"
              >
                ×
              </button>
            </span>
          ))}
        </div>
      )}

      {/* Task List */}
      <div className="space-y-3">
        {filteredTasks.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            {selectedTags.length > 0
              ? "No tasks match the selected filters"
              : "No tasks available"
            }
          </div>
        ) : (
          filteredTasks.map(task => (
            <TaskCard key={task.id} task={task} />
          ))
        )}
      </div>
    </div>
  );
}

// Tag Button Component
function TagButton({ tag, isSelected, onClick, color }) {
  return (
    <button
      onClick={onClick}
      className={`
        px-3 py-1 rounded-full text-sm font-medium transition-all
        ${isSelected
          ? `${color} text-white shadow-md transform scale-105`
          : 'bg-white text-gray-700 border hover:bg-gray-50'
        }
      `}
    >
      {tag}
      {isSelected && <span className="ml-1">✓</span>}
    </button>
  );
}

// Task Card Component
function TaskCard({ task }) {
  const tagColors = {
    react: "bg-blue-500",
    learning: "bg-green-500",
    frontend: "bg-purple-500",
    backend: "bg-orange-500",
    api: "bg-yellow-500",
    work: "bg-red-500",
    design: "bg-pink-500",
    personal: "bg-gray-500",
    bug: "bg-red-600",
    urgent: "bg-red-700"
  };

  return (
    <div className={`p-4 border rounded-lg ${task.completed ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200'}`}>
      <h4 className={`font-semibold ${task.completed ? 'line-through text-gray-500' : 'text-gray-800'}`}>
        {task.title}
      </h4>
      <div className="flex flex-wrap gap-1 mt-2">
        {task.tags.map(tag => (
          <span
            key={tag}
            className={`px-2 py-1 text-xs text-white rounded ${tagColors[tag] || 'bg-gray-400'}`}
          >
            {tag}
          </span>
        ))}
      </div>
    </div>
  );
}

// Advanced: Tag Input Component for adding new tags
function TagInput({ onAddTag, existingTags = [] }) {
  const [inputValue, setInputValue] = useState('');
  const [suggestions, setSuggestions] = useState([]);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setInputValue(value);

    // Show suggestions based on existing tags
    if (value.length > 0) {
      const filteredSuggestions = existingTags.filter(tag =>
        tag.toLowerCase().includes(value.toLowerCase()) && !value.split(',').includes(tag)
      );
      setSuggestions(filteredSuggestions);
    } else {
      setSuggestions([]);
    }
  };

  const handleAddTag = (tagToAdd = null) => {
    const tag = tagToAdd || inputValue.trim();
    if (tag && !existingTags.includes(tag)) {
      onAddTag(tag);
      setInputValue('');
      setSuggestions([]);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault();
      handleAddTag();
    }
  };

  return (
    <div className="relative">
      <input
        type="text"
        value={inputValue}
        onChange={handleInputChange}
        onKeyPress={handleKeyPress}
        placeholder="Add tags (press Enter or comma to add)"
        className="w-full px-3 py-2 border rounded focus:outline-none focus:border-blue-500"
      />

      {suggestions.length > 0 && (
        <div className="absolute z-10 w-full bg-white border border-gray-300 rounded-b shadow-lg max-h-40 overflow-y-auto">
          {suggestions.map(suggestion => (
            <button
              key={suggestion}
              onClick={() => handleAddTag(suggestion)}
              className="w-full text-left px-3 py-2 hover:bg-gray-100"
            >
              {suggestion}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Customizing Fonts and Styling Tailwind MaterialUI

It's like having a massive box of art supplies and design tools - you can make your web app look exactly how you want, whether you prefer the quick stickers approach (Tailwind) or the fancy art kit approach (Material-UI)!

**Key Points:**

- Tailwind: Utility-first CSS for rapid styling
- Material-UI: Pre-built components with Google's design system
- Both approaches have different philosophies and use cases
- Choose based on your project needs and team preferences

**Real-life example:** Tailwind is like having individual colored pencils for every tiny detail, while Material-UI is like having pre-made sticker sets that look professional right away.

<Details>
<Summary>Code example :</Summary>

```javascript
import { useState } from 'react';
// For Material-UI (install: npm install @mui/material @emotion/react @emotion/styled)
import {
  Button,
  Card,
  CardContent,
  Typography,
  TextField,
  Chip,
  Box,
  ThemeProvider,
  createTheme,
  CssBaseline
} from '@mui/material';

// TAILWIND CSS APPROACH
function TailwindTaskApp() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn Tailwind CSS", status: "pending", priority: "high" },
    { id: 2, title: "Build responsive design", status: "completed", priority: "medium" }
  ]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
      {/* Header with custom fonts */}
      <header className="text-center mb-8">
        <h1 className="text-4xl md:text-5xl font-bold text-gray-800 mb-2 font-serif">
          My Stylish Tasks
        </h1>
        <p className="text-lg text-gray-600 font-light">
          Built with Tailwind CSS magic ✨
        </p>
      </header>

      {/* Custom styled container */}
      <div className="max-w-4xl mx-auto">
        {/* Add task form with custom styling */}
        <div className="bg-white/70 backdrop-blur-sm rounded-2xl p-6 mb-6 shadow-xl border border-white/20">
          <form className="flex gap-4">
            <input
              type="text"
              placeholder="Add a new task..."
              className="
                flex-1 px-4 py-3 rounded-xl border-2 border-gray-200
                focus:border-blue-500 focus:ring-2 focus:ring-blue-200
                outline-none transition-all duration-300
                font-medium text-gray-700 placeholder-gray-400
              "
            />
            <button className="
              px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600
              text-white font-semibold rounded-xl
              hover:from-blue-600 hover:to-purple-700
              transform hover:scale-105 transition-all duration-300
              shadow-lg hover:shadow-xl
            ">
              Add Task
            </button>
          </form>
        </div>

        {/* Task grid with responsive design */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {tasks.map(task => (
            <TailwindTaskCard key={task.id} task={task} />
          ))}
        </div>

        {/* Custom statistics card */}
        <div className="mt-8 bg-white/60 backdrop-blur-sm rounded-2xl p-6 shadow-xl">
          <h3 className="text-2xl font-bold text-gray-800 mb-4">Statistics</h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <StatCard label="Total" value="12" color="blue" />
            <StatCard label="Completed" value="8" color="green" />
            <StatCard label="Pending" value="4" color="yellow" />
            <StatCard label="High Priority" value="2" color="red" />
          </div>
        </div>
      </div>
    </div>
  );
}

// Tailwind Task Card Component
function TailwindTaskCard({ task }) {
  const priorityColors = {
    high: "bg-red-100 text-red-800 border-red-200",
    medium: "bg-yellow-100 text-yellow-800 border-yellow-200",
    low: "bg-green-100 text-green-800 border-green-200"
  };

  return (
    <div className="
      group bg-white/80 backdrop-blur-sm rounded-xl p-5 shadow-lg
      hover:shadow-2xl hover:bg-white/90
      transform hover:-translate-y-2 transition-all duration-300
      border border-white/30
    ">
      <div className="flex justify-between items-start mb-3">
        <h4 className="font-bold text-gray-800 text-lg group-hover:text-blue-600 transition-colors">
          {task.title}
        </h4>
        <span className={`
          px-3 py-1 rounded-full text-xs font-medium border
          ${priorityColors[task.priority]}
        `}>
          {task.priority}
        </span>
      </div>

      <div className="flex justify-between items-center">
        <span className={`
          px-3 py-1 rounded-full text-sm font-medium
          ${task.status === 'completed'
            ? 'bg-green-100 text-green-800'
            : 'bg-blue-100 text-blue-800'
          }
        `}>
          {task.status}
        </span>

        <div className="flex gap-2">
          <button className="
            p-2 rounded-lg bg-blue-500 text-white
            hover:bg-blue-600 transform hover:scale-110
            transition-all duration-200
          ">
            ✏️
          </button>
          <button className="
            p-2 rounded-lg bg-red-500 text-white
            hover:bg-red-600 transform hover:scale-110
            transition-all duration-200
          ">
            🗑️
          </button>
        </div>
      </div>
    </div>
  );
}

// Stat Card Component
function StatCard({ label, value, color }) {
  const colorClasses = {
    blue: "bg-blue-500",
    green: "bg-green-500",
    yellow: "bg-yellow-500",
    red: "bg-red-500"
  };

  return (
    <div className="text-center p-4 bg-white/50 rounded-xl">
      <div className={`w-12 h-12 mx-auto mb-2 rounded-full ${colorClasses[color]} flex items-center justify-center`}>
        <span className="text-white font-bold text-lg">{value}</span>
      </div>
      <p className="text-gray-600 font-medium">{label}</p>
    </div>
  );
}

// MATERIAL-UI APPROACH
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 600,
    },
  },
});

function MaterialUITaskApp() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn Material-UI", status: "pending", priority: "high" },
    { id: 2, title: "Design with components", status: "completed", priority: "medium" }
  ]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ minHeight: '100vh', bgcolor: 'grey.50', p: 3 }}>
        {/* Header */}
        <Box textAlign="center" mb={4}>
          <Typography variant="h3" component="h1" gutterBottom fontWeight="bold">
            Material-UI Task Manager
          </Typography>
          <Typography variant="h6" color="text.secondary">
            Beautiful components out of the box
          </Typography>
        </Box>

        {/* Add task form */}
        <Box maxWidth="md" mx="auto" mb={4}>
          <Card elevation={3}>
            <CardContent>
              <Box display="flex" gap={2}>
                <TextField
                  fullWidth
                  placeholder="Add a new task..."
                  variant="outlined"
                  size="medium"
                />
                <Button
                  variant="contained"
                  color="primary"
                  size="large"
                  sx={{ minWidth: '120px' }}
                >
                  Add Task
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Box>

        {/* Task cards */}
        <Box maxWidth="lg" mx="auto">
          <Box display="grid" gridTemplateColumns="repeat(auto-fit, minmax(300px, 1fr))" gap={3}>
            {tasks.map(task => (
              <MaterialUITaskCard key={task.id} task={task} />
            ))}
          </Box>
        </Box>
      </Box>
    </ThemeProvider>
  );
}

// Material-UI Task Card Component
function MaterialUITaskCard({ task }) {
  const getPriorityColor = (priority) => {
    switch(priority) {
      case 'high': return 'error';
      case 'medium': return 'warning';
      case 'low': return 'success';
      default: return 'default';
    }
  };

  return (
    <Card
      elevation={2}
      sx={{
        transition: 'all 0.3s ease',
        '&:hover': {
          elevation: 8,
          transform: 'translateY(-4px)'
        }
      }}
    >
      <CardContent>
        <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={2}>
          <Typography variant="h6" component="h3" fontWeight="bold">
            {task.title}
          </Typography>
          <Chip
            label={task.priority}
            color={getPriorityColor(task.priority)}
            size="small"
            variant="outlined"
          />
        </Box>

        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Chip
            label={task.status}
            color={task.status === 'completed' ? 'success' : 'primary'}
            variant={task.status === 'completed' ? 'filled' : 'outlined'}
          />

          <Box>
            <Button size="small" color="primary">
              Edit
            </Button>
            <Button size="small" color="error">
              Delete
            </Button>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
}

// Custom CSS-in-JS approach (Styled Components alternative)
function CustomStyledApp() {
  const styles = {
    container: {
      fontFamily: "'Inter', -apple-system, BlinkMacSystemFont, sans-serif",
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      padding: '2rem'
    },
    header: {
      textAlign: 'center',
      color: 'white',
      marginBottom: '2rem'
    },
    title: {
      fontSize: 'clamp(2rem, 5vw, 3.5rem)',
      fontWeight: '700',
      margin: '0 0 0.5rem 0',
      textShadow: '2px 2px 4px rgba(0,0,0,0.3)'
    },
    card: {
      backgroundColor: 'rgba(255, 255, 255, 0.95)',
      borderRadius: '1rem',
      padding: '1.5rem',
      boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
      backdropFilter: 'blur(10px)',
      border: '1px solid rgba(255, 255, 255, 0.2)',
      transition: 'all 0.3s ease',
      cursor: 'pointer'
    },
    cardHover: {
      transform: 'translateY(-5px)',
      boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15)'
    }
  };

  return (
    <div style={styles.container}>
      <header style={styles.header}>
        <h1 style={styles.title}>Custom Styled Tasks</h1>
        <p>Hand-crafted with CSS-in-JS</p>
      </header>

      {/* Content goes here */}
    </div>
  );
}

// Font loading example (add to your HTML head or CSS)
/*
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');

// Or for Tailwind config:
module.exports = {
  theme: {
    fontFamily: {
      'sans': ['Inter', 'sans-serif'],
      'display': ['Poppins', 'sans-serif'],
      'body': ['Inter', 'sans-serif'],
    }
  }
}
*/
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Setting Up Routing (React Router)

Like creating a map for your house - each room has a specific address so visitors know where to go!

**Key Points:**

- Install `react-router-dom` package
- Wrap app with `<BrowserRouter>`
- Define routes with `<Routes>` and `<Route>`

<Details>
<Summary>Code example :</Summary>

```js
// 1. Install: npm install react-router-dom
// 2. Setup in App.js:
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Not Found Page (React Router)

Like having a "Room not found" sign when someone looks for a room that doesn't exist in your house!

**Key Points:**

- Use `path="*"` to catch all undefined routes
- Always put it as the last route
- Show helpful 404 message

<Details>
<Summary>Code example :</Summary>

```js
function NotFound() {
  return (
    <div>
      <h1>404 - Page Not Found</h1>
      <Link to="/">Go Home</Link>
    </div>
  );
}

// In your Routes:
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
  <Route path="*" element={<NotFound />} /> {/* Always last! */}
</Routes>
```

</Details>

<br>

<br>

<br>

**[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### SPA with React Router

Like a magic house where rooms change instantly without walking through doors - no page reloads!

**Key Points:**

- SPA = Single Page Application
- Use `<Link>` instead of `<a>` tags
- Navigation happens without page refresh

<Details>
<Summary>Code example :</Summary>

```js
import { Link } from 'react-router-dom';

function Navbar() {
  return (
    <nav>
      <Link to="/">Home</Link> {/* ✅ Good - no reload */}
      <Link to="/about">About</Link>
      <a href="/contact">Contact</a> {/* ❌ Bad - causes reload */}
    </nav>
  );
}

// Link with styling:
<Link to="/about" className="nav-link">About Us</Link>
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Route Parameters and Query Strings

Like having personalized room keys - each person gets their own room number and special preferences!

**Key Points:**

- `:param` creates dynamic routes
- `useParams()` gets URL parameters
- `useSearchParams()` gets query strings (?key=value)

<Details>
<Summary>Code example :</Summary>

```js
// Routes with parameters:
<Routes>
  <Route path="/user/:id" element={<UserProfile />} />
  <Route path="/product/:category/:id" element={<Product />} />
</Routes>

// In UserProfile component:
import { useParams, useSearchParams } from 'react-router-dom';

function UserProfile() {
  const { id } = useParams(); // Gets :id from URL
  const [searchParams] = useSearchParams(); // Gets ?name=john&age=25

  const userName = searchParams.get('name');

  return (
    <div>
      <h1>User ID: {id}</h1>
      <p>Name: {userName}</p>
    </div>
  );
}

// URL: /user/123?name=john&age=25
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Nested Routing and Programmatic Navigation

Like having rooms inside rooms, and a remote control to instantly teleport between any room!

**Key Points:**

- Nest routes for layouts and subpages
- Use `<Outlet />` to render child routes
- `useNavigate()` for navigation in code

<Details>
<Summary>Code example :</Summary>

```js
import { Outlet, useNavigate } from 'react-router-dom';

// Nested Routes Setup:
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
    <Route path="settings" element={<Settings />} />
  </Route>
</Routes>

// Dashboard Layout:
function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="profile">Profile</Link>
        <Link to="settings">Settings</Link>
      </nav>
      <Outlet /> {/* Child routes render here */}
    </div>
  );
}

// Programmatic Navigation:
function LoginForm() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // After login logic...
    navigate('/dashboard'); // Redirect to dashboard
    // navigate(-1); // Go back
    // navigate('/home', { replace: true }); // Replace current page
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useEffect and Dependency Array

Like setting up reminders for your robot to do chores whenever something changes!

**Key Points:**

- `useEffect()` runs code after render (side effects)
- Dependency array `[]` controls when effect runs
- Empty `[]` = run once when component loads
- `[count]` = run when `count` changes

**Real-life example:** Like telling your alarm clock "Ring when it's 7 AM" or "Ring whenever I change the time."

<Details>
<Summary>Code example :</Summary>

```js
import { useEffect, useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  // Run once when component loads
  useEffect(() => {
    console.log("Component loaded!");
  }, []); // Empty array = run once

  // Run every time count changes
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]); // Runs when count changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Add</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Fetching Data fetch Axios

Like sending your robot to the store to get new supplies - it goes, gets the data, and brings it back!

**Key Points:**

- Use `fetch()` (built-in) or `axios` (library)
- Always fetch data inside `useEffect()`
- Axios is easier and more popular
- Handle both success and error cases

**Real-life example:** Like ordering food online - you place the order, wait for delivery, and either get your food or an error message.

<Details>
<Summary>Code example :</Summary>

```js
import { useState, useEffect } from 'react';
import axios from 'axios'; // npm install axios

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // Method 1: Using fetch (built-in)
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response => response.json()) // Convert to JSON
      .then(data => setUsers(data))
      .catch(error => console.error('Error:', error));
  }, []);

  // Method 2: Using axios (easier)
  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/users')
      .then(response => setUsers(response.data)) // axios auto-converts to JSON
      .catch(error => console.error('Error:', error));
  }, []);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Loaders and Error Handling

Like showing a "Loading..." sign while your robot is busy, and an "Oops!" sign if something goes wrong!

**Key Points:**

- Use 3 states: `loading`, `error`, and `data`
- Show loading spinner while fetching
- Display error message if something fails
- Show data when everything works

**Real-life example:** Like waiting for a webpage to load - you see a spinning wheel, then either the page or an error message.

<Details>
<Summary>Code example :</Summary>

```js
import { useState, useEffect } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Start loading
    setLoading(true);
    setError(null);

    fetch('https://jsonplaceholder.typicode.com/users/1')
      .then(response => {
        if (!response.ok) {
          throw new Error('User not found');
        }
        return response.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false); // Stop loading
      })
      .catch(err => {
        setError(err.message);
        setLoading(false); // Stop loading
      });
  }, []);

  // Show loading state
  if (loading) {
    return <div>Loading user data... 🔄</div>;
  }

  // Show error state
  if (error) {
    return <div>Error: {error} ❌</div>;
  }

  // Show success state
  return (
    <div>
      <h1>{user.name} ✅</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Promises vs Async Await

Like asking your robot to promise to finish a task, or just telling it "wait until you're done, then continue!"

**Key Points:**

- **Promises**: Use `.then()` and `.catch()` (older way)
- **Async/await**: Looks like normal code (newer, cleaner way)
- Both handle asynchronous operations
- Async/await is easier to read and debug

**Real-life example:** Promises are like "I promise to call you back" vs Async/await is like "Wait, let me check and get back to you right now."

<Details>
<Summary>Code example :</Summary>

```js
// METHOD 1: Promises (older style)
function fetchUserWithPromises() {
  fetch('https://jsonplaceholder.typicode.com/users/1')
    .then(response => response.json())
    .then(user => {
      console.log('User:', user.name);
      return user;
    })
    .catch(error => {
      console.error('Error:', error);
    });
}

// METHOD 2: Async/Await (modern style - RECOMMENDED)
async function fetchUserWithAsync() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
    const user = await response.json();
    console.log('User:', user.name);
    return user;
  } catch (error) {
    console.error('Error:', error);
  }
}

// Using in React component
function UserComponent() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Option 1: Create async function inside useEffect
    const getUser = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Error:', error);
      }
    };

    getUser(); // Call the async function
  }, []);

  return user ? <h1>{user.name}</h1> : <p>Loading...</p>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### POST PUT DELETE with Axios

Like sending your robot to add, update, or remove items from your inventory!

**Key Points:**

- **POST** = Create new data (like adding a new user)
- **PUT** = Update existing data (like editing a user)
- **DELETE** = Remove data (like deleting a user)
- Use axios methods for each operation

**Real-life example:** POST is like adding a new contact to your phone, PUT is like updating their phone number, DELETE is like removing them completely.

<Details>
<Summary>Code example :</Summary>

```js
import axios from 'axios';

function UserManager() {
  const [users, setUsers] = useState([]);

  // CREATE - Add new user (POST)
  const addUser = async () => {
    try {
      const newUser = {
        name: 'John Doe',
        email: 'john@example.com'
      };

      const response = await axios.post('https://jsonplaceholder.typicode.com/users', newUser);
      console.log('User created:', response.data);

      // Add to local state
      setUsers([...users, response.data]);
    } catch (error) {
      console.error('Error creating user:', error);
    }
  };

  // UPDATE - Edit existing user (PUT)
  const updateUser = async (userId) => {
    try {
      const updatedUser = {
        name: 'John Smith', // Updated name
        email: 'johnsmith@example.com'
      };

      const response = await axios.put(`https://jsonplaceholder.typicode.com/users/${userId}`, updatedUser);
      console.log('User updated:', response.data);

      // Update local state
      setUsers(users.map(user =>
        user.id === userId ? response.data : user
      ));
    } catch (error) {
      console.error('Error updating user:', error);
    }
  };

  // DELETE - Remove user
  const deleteUser = async (userId) => {
    try {
      await axios.delete(`https://jsonplaceholder.typicode.com/users/${userId}`);
      console.log('User deleted');

      // Remove from local state
      setUsers(users.filter(user => user.id !== userId));
    } catch (error) {
      console.error('Error deleting user:', error);
    }
  };

  return (
    <div>
      <button onClick={addUser}>Add User</button>
      <button onClick={() => updateUser(1)}>Update User 1</button>
      <button onClick={() => deleteUser(1)}>Delete User 1</button>
    </div>
  );
}

// Quick Reference:
// axios.get(url)           - GET data
// axios.post(url, data)    - CREATE data
// axios.put(url, data)     - UPDATE data
// axios.delete(url)        - DELETE data
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Design Patterns Container Presentational

Like having a chef (Container) who handles all the cooking logic, and a waiter (Presentational) who just serves the food beautifully!

**Key Points:**

- **Container Components**: Handle logic, state, and data fetching
- **Presentational Components**: Just display UI based on props
- Separates business logic from visual presentation
- Makes components more reusable and testable

**Real-life example:** Like a restaurant where the chef handles cooking (logic) while the waiter handles serving (presentation).

<Details>
<Summary>Code example :</Summary>

```js
// PRESENTATIONAL COMPONENT (UI only)
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
      <button onClick={() => onDelete(user.id)}>Delete</button>
    </div>
  );
}

// CONTAINER COMPONENT (Logic & State)
function UserCardContainer({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch user data
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(userData => {
        setUser(userData);
        setLoading(false);
      });
  }, [userId]);

  const handleEdit = (id) => {
    // Edit logic
    console.log('Editing user:', id);
  };

  const handleDelete = (id) => {
    // Delete logic
    setUser(null);
    console.log('Deleted user:', id);
  };

  if (loading) return <div>Loading...</div>;

  return (
    <UserCard
      user={user}
      onEdit={handleEdit}
      onDelete={handleDelete}
    />
  );
}

// Usage
function App() {
  return (
    <div>
      <UserCardContainer userId={1} />
      <UserCardContainer userId={2} />
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Higher Order Components HOC

Like a gift wrapper that takes any gift (component) and wraps it with extra features like tracking, authentication, or styling!

**Key Points:**

- Function that takes a component and returns an enhanced component
- Used for code reuse and cross-cutting concerns
- Common uses: authentication, logging, data fetching
- Think of it as a "component decorator"

**Real-life example:** Like a security guard who checks everyone's ID before letting them into different rooms - same security logic for all rooms.

<Details>
<Summary>Code example :</Summary>

```js
// HOC for authentication
function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      // Check if user is authenticated
      const token = localStorage.getItem('token');
      if (token) {
        fetch('/api/me', {
          headers: { Authorization: `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(userData => {
          setUser(userData);
          setLoading(false);
        })
        .catch(() => {
          setLoading(false);
        });
      } else {
        setLoading(false);
      }
    }, []);

    if (loading) return <div>Checking authentication...</div>;

    if (!user) {
      return <div>Please login to access this page</div>;
    }

    // Pass all props + user to wrapped component
    return <WrappedComponent {...props} user={user} />;
  };
}

// HOC for loading states
function withLoading(WrappedComponent) {
  return function LoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading... 🔄</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// Regular components
function Dashboard({ user }) {
  return (
    <div>
      <h1>Welcome to Dashboard, {user.name}!</h1>
      <p>Your email: {user.email}</p>
    </div>
  );
}

function Profile({ user }) {
  return (
    <div>
      <h1>Profile Page</h1>
      <p>Name: {user.name}</p>
    </div>
  );
}

// Enhanced components using HOCs
const AuthenticatedDashboard = withAuth(Dashboard);
const AuthenticatedProfile = withAuth(Profile);
const LoadingProfile = withLoading(Profile);

// Usage
function App() {
  return (
    <div>
      <AuthenticatedDashboard />
      <AuthenticatedProfile />
      <LoadingProfile isLoading={false} user={{ name: 'John' }} />
    </div>
  );
}

// Advanced: Composing multiple HOCs
const EnhancedDashboard = withAuth(withLoading(Dashboard));
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Custom Hooks

Like creating your own magic spells that you can use in any component - once you create the spell, you can cast it anywhere!

**Key Points:**

- Functions that start with "use" and contain React hooks
- Extract reusable stateful logic between components
- Can use other hooks inside them
- Return anything you want (state, functions, objects)

**Real-life example:** Like creating a universal remote control that works for TV, AC, and stereo - one remote (custom hook) for multiple devices (components).

<Details>
<Summary>Code example :</Summary>

```js
// Custom Hook for API data fetching
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Failed to fetch data');
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  // Return everything the component might need
  return { data, loading, error };
}

// Custom Hook for localStorage
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setStoredValue = (newValue) => {
    try {
      setValue(newValue);
      window.localStorage.setItem(key, JSON.stringify(newValue));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  };

  return [value, setStoredValue];
}

// Custom Hook for form handling
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({
      ...prev,
      [name]: value
    }));

    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const validate = (validationRules) => {
    const newErrors = {};

    Object.keys(validationRules).forEach(field => {
      const rule = validationRules[field];
      const value = values[field];

      if (rule.required && !value) {
        newErrors[field] = `${field} is required`;
      } else if (rule.minLength && value.length < rule.minLength) {
        newErrors[field] = `${field} must be at least ${rule.minLength} characters`;
      }
    });

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
  };

  return {
    values,
    errors,
    handleChange,
    validate,
    reset
  };
}

// Using Custom Hooks in Components
function UserProfile() {
  // Using useApi custom hook
  const { data: user, loading, error } = useApi('/api/user/profile');

  // Using useLocalStorage custom hook
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  if (loading) return <div>Loading profile...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div className={`profile ${theme}`}>
      <h1>{user.name}</h1>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Switch to {theme === 'light' ? 'Dark' : 'Light'} Mode
      </button>
    </div>
  );
}

function ContactForm() {
  // Using useForm custom hook
  const {
    values,
    errors,
    handleChange,
    validate,
    reset
  } = useForm({
    name: '',
    email: '',
    message: ''
  });

  const handleSubmit = (e) => {
    e.preventDefault();

    const isValid = validate({
      name: { required: true, minLength: 2 },
      email: { required: true },
      message: { required: true, minLength: 10 }
    });

    if (isValid) {
      console.log('Form submitted:', values);
      reset();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={values.name}
        onChange={handleChange}
        placeholder="Your name"
      />
      {errors.name && <span className="error">{errors.name}</span>}

      <input
        name="email"
        value={values.email}
        onChange={handleChange}
        placeholder="Your email"
      />
      {errors.email && <span className="error">{errors.email}</span>}

      <textarea
        name="message"
        value={values.message}
        onChange={handleChange}
        placeholder="Your message"
      />
      {errors.message && <span className="error">{errors.message}</span>}

      <button type="submit">Send Message</button>
    </form>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Deep Dive into Hooks useEffect

Like a Swiss Army knife for handling side effects - it can do cleanup, timers, data fetching, subscriptions, and more!

**Key Points:**

- Replaces componentDidMount, componentDidUpdate, componentWillUnmount
- Runs after every render by default
- Dependency array controls when it runs
- Return cleanup function to prevent memory leaks

**Real-life example:** Like a smart home assistant that can turn lights on when you arrive, off when you leave, and handle multiple scheduled tasks.

<Details>
<Summary>Code example :</Summary>

```js
import { useState, useEffect } from 'react';

function UseEffectMasterClass() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState(null);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);

  // 1. BASIC useEffect - runs after every render
  useEffect(() => {
    console.log('Component rendered');
  });

  // 2. useEffect with EMPTY DEPENDENCY ARRAY - runs once on mount
  useEffect(() => {
    console.log('Component mounted - like componentDidMount');

    // Fetch initial data
    fetch('/api/user')
      .then(res => res.json())
      .then(setUser);
  }, []); // Empty array = run once

  // 3. useEffect with DEPENDENCIES - runs when dependencies change
  useEffect(() => {
    document.title = `Count: ${count}`;
    console.log('Count changed to:', count);
  }, [count]); // Runs when count changes

  // 4. useEffect with CLEANUP - prevents memory leaks
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 1000);

    // Cleanup function (like componentWillUnmount)
    return () => {
      clearInterval(timer);
      console.log('Timer cleaned up');
    };
  }, []);

  // 5. useEffect for EVENT LISTENERS
  useEffect(() => {
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // 6. useEffect with ASYNC operations
  useEffect(() => {
    let cancelled = false;

    const fetchData = async () => {
      try {
        const response = await fetch(`/api/user/${count}`);
        const userData = await response.json();

        // Only update if component is still mounted
        if (!cancelled) {
          setUser(userData);
        }
      } catch (error) {
        if (!cancelled) {
          console.error('Error fetching user:', error);
        }
      }
    };

    if (count > 0) {
      fetchData();
    }

    // Cleanup function
    return () => {
      cancelled = true;
    };
  }, [count]);

  // 7. CONDITIONAL useEffect
  useEffect(() => {
    if (user && user.preferences) {
      localStorage.setItem('userPrefs', JSON.stringify(user.preferences));
    }
  }, [user?.preferences]); // Only run when user.preferences changes

  return (
    <div>
      <h1>useEffect Deep Dive</h1>
      <p>Count: {count}</p>
      <p>Window Width: {windowWidth}px</p>
      <p>User: {user ? user.name : 'Loading...'}</p>

      <button onClick={() => setCount(count + 1)}>
        Increment Count
      </button>
    </div>
  );
}

// Advanced useEffect Patterns
function AdvancedEffects() {
  const [posts, setPosts] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);

  // 8. useEffect for INFINITE SCROLL
  useEffect(() => {
    const handleScroll = () => {
      if (
        window.innerHeight + document.documentElement.scrollTop
        >= document.documentElement.offsetHeight - 1000
      ) {
        setPage(prev => prev + 1);
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  // 9. useEffect for DEBOUNCED API CALLS
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    const debounceTimer = setTimeout(() => {
      if (searchTerm) {
        // API call after 500ms delay
        fetch(`/api/search?q=${searchTerm}`)
          .then(res => res.json())
          .then(results => console.log(results));
      }
    }, 500);

    return () => clearTimeout(debounceTimer);
  }, [searchTerm]);

  // 10. useEffect for WEBSOCKET connections
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8080');

    ws.onopen = () => console.log('WebSocket connected');
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      console.log('Received:', message);
    };
    ws.onerror = (error) => console.error('WebSocket error:', error);

    return () => {
      ws.close();
      console.log('WebSocket disconnected');
    };
  }, []);

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
    </div>
  );
}

// Common useEffect Mistakes and Solutions
function UseEffectMistakes() {
  const [count, setCount] = useState(0);

  // ❌ MISTAKE 1: Missing dependency
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + 1); // This will always use initial count value
    }, 1000);
    return () => clearInterval(timer);
  }, []); // Missing 'count' in dependency array

  // ✅ SOLUTION 1: Use functional update
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prev => prev + 1); // Uses latest count
    }, 1000);
    return () => clearInterval(timer);
  }, []); // Now we don't need count as dependency

  // ❌ MISTAKE 2: Infinite re-renders
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => setCount(data.count));
  }); // No dependency array = runs after every render

  // ✅ SOLUTION 2: Add dependency array
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => setCount(data.count));
  }, []); // Runs only once

  return <div>Count: {count}</div>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useRef

Like having a sticky note that you can attach to any element or value - it persists between renders but doesn't trigger re-renders when changed!

**Key Points:**

- Creates a mutable reference that persists across renders
- Doesn't trigger re-renders when `.current` changes
- Common uses: DOM manipulation, storing previous values, timers
- Like `createRef` but for functional components

**Real-life example:** Like having a bookmark in a book - you can move it around without changing the book's content, and it stays where you put it.

<Details>
<Summary>Code example :</Summary>

```js
import { useRef, useState, useEffect } from 'react';

function UseRefExamples() {
  // 1. BASIC useRef for DOM elements
  const inputRef = useRef(null);
  const divRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus(); // Direct DOM access
  };

  const scrollToDiv = () => {
    divRef.current.scrollIntoView({ behavior: 'smooth' });
  };

  // 2. useRef for STORING VALUES (doesn't trigger re-render)
  const countRef = useRef(0);
  const [renderCount, setRenderCount] = useState(0);

  const incrementRef = () => {
    countRef.current += 1;
    console.log('Ref count:', countRef.current); // Updates but no re-render
  };

  const incrementState = () => {
    setRenderCount(prev => prev + 1); // Triggers re-render
  };

  // 3. useRef for PREVIOUS VALUES
  const [name, setName] = useState('');
  const prevNameRef = useRef('');

  useEffect(() => {
    prevNameRef.current = name; // Store previous value after render
  });

  const prevName = prevNameRef.current;

  // 4. useRef for TIMERS
  const timerRef = useRef(null);
  const [seconds, setSeconds] = useState(0);

  const startTimer = () => {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        setSeconds(prev => prev + 1);
      }, 1000);
    }
  };

  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  };

  const resetTimer = () => {
    stopTimer();
    setSeconds(0);
  };

  // Cleanup timer on unmount
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  return (
    <div>
      <h1>useRef Examples</h1>

      {/* DOM Reference Examples */}
      <section>
        <h2>DOM References</h2>
        <input ref={inputRef} placeholder="I can be focused!" />
        <button onClick={focusInput}>Focus Input</button>

        <div
          ref={divRef}
          style={{
            height: '200px',
            backgroundColor: 'lightblue',
            marginTop: '100vh'
          }}
        >
          Scroll to me!
        </div>
        <button onClick={scrollToDiv}>Scroll to Blue Div</button>
      </section>

      {/* Value Storage Examples */}
      <section>
        <h2>Value Storage</h2>
        <p>Ref count (no re-render): {countRef.current}</p>
        <p>State count (triggers re-render): {renderCount}</p>
        <button onClick={incrementRef}>Increment Ref</button>
        <button onClick={incrementState}>Increment State</button>
      </section>

      {/* Previous Value Example */}
      <section>
        <h2>Previous Values</h2>
        <input
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Type your name"
        />
        <p>Current name: {name}</p>
        <p>Previous name: {prevName}</p>
      </section>

      {/* Timer Example */}
      <section>
        <h2>Timer Control</h2>
        <p>Timer: {seconds} seconds</p>
        <button onClick={startTimer}>Start</button>
        <button onClick={stopTimer}>Stop</button>
        <button onClick={resetTimer}>Reset</button>
      </section>
    </div>
  );
}

// Advanced useRef Patterns
function AdvancedUseRef() {
  // 5. useRef for CALLBACK REFS
  const [height, setHeight] = useState(0);

  const measuredRef = useRef(null);

  const callbackRef = useRef((node) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  });

  // 6. useRef for STORING FUNCTIONS
  const apiCallRef = useRef(null);

  useEffect(() => {
    // Store the latest API call function
    apiCallRef.current = async (id) => {
      const response = await fetch(`/api/items/${id}`);
      return response.json();
    };
  });

  const handleApiCall = async (id) => {
    if (apiCallRef.current) {
      const data = await apiCallRef.current(id);
      console.log('API data:', data);
    }
  };

  // 7. useRef for IMPERATIVE ACTIONS
  const customComponentRef = useRef(null);

  const triggerCustomAction = () => {
    if (customComponentRef.current) {
      customComponentRef.current.doSomething();
    }
  };

  return (
    <div>
      <div ref={callbackRef}>
        <p>This div's height is: {height}px</p>
      </div>

      <CustomComponent ref={customComponentRef} />
      <button onClick={triggerCustomAction}>
        Trigger Custom Action
      </button>
    </div>
  );
}

// Forward Ref Example
const CustomComponent = React.forwardRef((props, ref) => {
  const [value, setValue] = useState('');

  // Expose methods to parent component
  useImperativeHandle(ref, () => ({
    doSomething: () => {
      setValue('Action triggered!');
      console.log('Custom action executed');
    },
    reset: () => {
      setValue('');
    },
    getValue: () => value
  }));

  return (
    <div>
      <p>Custom Component Value: {value}</p>
    </div>
  );
});

// Custom Hook using useRef
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

// Usage of custom hook
function ComponentWithPrevious() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useImperativeHandle

Like giving your component a remote control that parents can use to trigger specific actions!

**Key Points:**

- Exposes custom functions to parent components
- Used with `forwardRef`
- Limits what parent can access

<Details>
<Summary>Code example :</Summary>

```js
const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    clear: () => inputRef.current.value = '',
    getValue: () => inputRef.current.value
  }));

  return <input ref={inputRef} {...props} />;
});

// Usage
function Parent() {
  const childRef = useRef();

  return (
    <div>
      <CustomInput ref={childRef} />
      <button onClick={() => childRef.current.focus()}>Focus</button>
      <button onClick={() => childRef.current.clear()}>Clear</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useMemo

Like having a smart calculator that remembers expensive calculations so it doesn't repeat them!

**Key Points:**

- Caches expensive calculations
- Only recalculates when dependencies change
- Helps performance optimization

<Details>
<Summary>Code example :</Summary>

```js
function ExpensiveComponent({ items, filter }) {
  // Without useMemo - calculates every render
  const expensiveValue = items.filter(item =>
    item.name.includes(filter)
  ).reduce((sum, item) => sum + item.price, 0);

  // With useMemo - only recalculates when items or filter change
  const memoizedValue = useMemo(() => {
    return items.filter(item =>
      item.name.includes(filter)
    ).reduce((sum, item) => sum + item.price, 0);
  }, [items, filter]);

  return <div>Total: ${memoizedValue}</div>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useCallback

Like saving a recipe card so you don't have to rewrite it every time you cook!

**Key Points:**

- Caches function definitions
- Prevents unnecessary child re-renders
- Use when passing functions to child components

<Details>
<Summary>Code example :</Summary>

```js
function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // Bad - new function every render
  const handleClick = () => setCount(count + 1);

  // Good - cached function
  const memoizedClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  return (
    <div>
      <Child onClick={memoizedClick} />
      <input value={name} onChange={(e) => setName(e.target.value)} />
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useContext

Like a family group chat where everyone can see the same messages without passing them person to person!

**Key Points:**

- Shares data across components without prop drilling
- Create context, provide value, consume in any child
- Great for themes, user auth, language settings

<Details>
<Summary>Code example :</Summary>

```js
// 1. Create Context
const ThemeContext = createContext();

// 2. Provider Component
function App() {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Header />
      <MainContent />
      <Footer />
    </ThemeContext.Provider>
  );
}

// 3. Consume Context
function Header() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <header className={theme}>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Switch to {theme === 'light' ? 'Dark' : 'Light'}
      </button>
    </header>
  );
}

function MainContent() {
  const { theme } = useContext(ThemeContext);
  return <main className={theme}>Content here</main>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useReducer

Like having a state manager that handles complex state changes with specific rules!

**Key Points:**

- Better than useState for complex state logic
- Predictable state updates through actions
- Similar to Redux pattern

<Details>
<Summary>Code example :</Summary>

```js
// 1. Define reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    case 'set':
      return { count: action.payload };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// 2. Use reducer in component
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'set', payload: 10 })}>Set to 10</button>
    </div>
  );
}

// Complex example - Todo app
function todoReducer(todos, action) {
  switch (action.type) {
    case 'add':
      return [...todos, { id: Date.now(), text: action.text, done: false }];
    case 'toggle':
      return todos.map(todo =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    case 'delete':
      return todos.filter(todo => todo.id !== action.id);
    default:
      return todos;
  }
}

function TodoApp() {
  const [todos, dispatch] = useReducer(todoReducer, []);

  return (
    <div>
      <button onClick={() => dispatch({ type: 'add', text: 'New todo' })}>
        Add Todo
      </button>
      {todos.map(todo => (
        <div key={todo.id}>
          <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>
            {todo.text}
          </span>
          <button onClick={() => dispatch({ type: 'toggle', id: todo.id })}>
            Toggle
          </button>
          <button onClick={() => dispatch({ type: 'delete', id: todo.id })}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React 19 Hooks useActionState

Like having a smart form that tracks its own submission state and handles errors automatically!

**Key Points:**

- Manages form submission state (pending, success, error)
- Works with Server Actions
- Handles optimistic updates

<Details>
<Summary>Code example :</Summary>

```js
import { useActionState } from 'react';

async function submitForm(prevState, formData) {
  try {
    await new Promise(resolve => setTimeout(resolve, 1000));
    const name = formData.get('name');
    return { success: true, message: `Hello ${name}!` };
  } catch (error) {
    return { success: false, error: 'Something went wrong' };
  }
}

function ContactForm() {
  const [state, formAction, isPending] = useActionState(submitForm, null);

  return (
    <form action={formAction}>
      <input name="name" placeholder="Your name" required />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Submitting...' : 'Submit'}
      </button>

      {state?.success && <p style={{color: 'green'}}>{state.message}</p>}
      {state?.error && <p style={{color: 'red'}}>{state.error}</p>}
    </form>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useFormStatus

Like a dashboard that shows you exactly what's happening with your form submission!

**Key Points:**

- Tracks form submission status
- Must be used inside a form component
- Shows pending state and form data

<Details>
<Summary>Code example :</Summary>

```js
import { useFormStatus } from 'react-dom';

function SubmitButton() {
  const { pending, data, method, action } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Saving...' : 'Save'}
    </button>
  );
}

function MyForm() {
  async function handleSubmit(formData) {
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log('Form submitted:', Object.fromEntries(formData));
  }

  return (
    <form action={handleSubmit}>
      <input name="title" placeholder="Post title" />
      <textarea name="content" placeholder="Post content" />
      <SubmitButton />
    </form>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useOptimistic

Like showing instant results while secretly waiting for the real confirmation in the background!

**Key Points:**

- Shows immediate UI updates before server confirmation
- Great for likes, comments, todos
- Automatically reverts on error

<Details>
<Summary>Code example :</Summary>

```js
import { useOptimistic, useState } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false }
  ]);

  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, newTodo]
  );

  async function addTodo(formData) {
    const text = formData.get('text');
    const newTodo = { id: Date.now(), text, completed: false };

    addOptimisticTodo(newTodo); // Show immediately

    try {
      await new Promise(resolve => setTimeout(resolve, 1000));
      setTodos(prev => [...prev, newTodo]); // Real update
    } catch (error) {
      console.error('Failed to add todo');
    }
  }

  return (
    <div>
      <form action={addTodo}>
        <input name="text" placeholder="New todo" required />
        <button type="submit">Add Todo</button>
      </form>

      <ul>
        {optimisticTodos.map(todo => (
          <li key={todo.id} style={{
            opacity: todos.includes(todo) ? 1 : 0.5
          }}>
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### use API

Like a magic key that can unlock promises and context values anywhere in your component!

**Key Points:**

- Can be used inside conditions and loops (unlike hooks)
- Works with Promises and Context
- Suspends component until promise resolves

<Details>
<Summary>Code example :</Summary>

```js
import { use, Suspense } from 'react';

function UserProfile({ userPromise }) {
  const user = use(userPromise); // Suspends until resolved

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

const ThemeContext = createContext();

function Button({ primary }) {
  // Can use inside conditions!
  if (primary) {
    const theme = use(ThemeContext);
    return <button className={theme}>Primary Button</button>;
  }

  return <button>Regular Button</button>;
}

function App() {
  const userPromise = fetch('/api/user').then(res => res.json());

  return (
    <ThemeContext.Provider value="dark">
      <Suspense fallback={<div>Loading user...</div>}>
        <UserProfile userPromise={userPromise} />
        <Button primary />
      </Suspense>
    </ThemeContext.Provider>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Passing Refs as Props

Like giving someone the remote control to your TV so they can change channels from their couch!

**Key Points:**

- Pass refs like normal props (no forwardRef needed)
- Multiple refs can point to same element
- Cleaner than forwardRef pattern

<Details>
<Summary>Code example :</Summary>

```js
// Old way with forwardRef
const OldButton = forwardRef((props, ref) => {
  return <button ref={ref} {...props} />;
});

// New way - direct ref prop
function NewButton({ ref, ...props }) {
  return <button ref={ref} {...props} />;
}

function App() {
  const buttonRef = useRef();

  const focusButton = () => {
    buttonRef.current?.focus();
  };

  return (
    <div>
      <NewButton ref={buttonRef}>Click me</NewButton>
      <button onClick={focusButton}>Focus the button</button>

      {/* Conditional refs */}
      <NewButton ref={Math.random() > 0.5 ? buttonRef : null}>
        Maybe focused
      </NewButton>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React as a Wrapper

Like a gift wrapper that takes your regular HTML and makes it interactive and dynamic!

**Key Points:**

- React wraps DOM elements with extra powers
- JSX gets converted to React.createElement calls
- React manages the actual DOM manipulation

<Details>
<Summary>Code example :</Summary>

```js
// What you write (JSX)
function App() {
  return <div className="app">Hello World</div>;
}

// What React actually does
function App() {
  return React.createElement('div', { className: 'app' }, 'Hello World');
}

// React wraps your components with extra functionality
function WrappedComponent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Reconciliation and How React Works Under the Hood

Like having a smart assistant who compares your old shopping list with your new one and only buys what changed!

**Key Points:**

- React compares Virtual DOM trees (diffing algorithm)
- Only updates parts of real DOM that actually changed
- Uses keys to efficiently track list items

<Details>
<Summary>Code example :</Summary>

```js
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}> {/* Key helps React track items */}
          {todo.text}
        </li>
      ))}
    </ul>
  );
}

// Example: Adding item to middle of list
// Old: [A, B, C]
// New: [A, X, B, C]
// With keys: React knows to insert X, keep A, B, C unchanged

function FiberExample() {
  const [items, setItems] = useState(['A', 'B', 'C']);

  const addItem = () => {
    setItems(prev => [...prev, `Item ${prev.length + 1}`]);
    // React schedules this update and can interrupt it for higher priority work
  };

  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>{item}</div>
      ))}
      <button onClick={addItem}>Add Item</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Prop Drilling

Like passing a message through a long chain of people - each person must pass it along even if they don't need it!

**Key Points:**

- Passing props through multiple component levels
- Intermediate components don't use the props
- Can make code messy and hard to maintain

<Details>
<Summary>Code example :</Summary>

```js
// Prop Drilling Problem
function App() {
  const user = { name: 'John', role: 'admin' };
  return <Layout user={user} />;
}

function Layout({ user }) {
  // Layout doesn't use user, just passes it down
  return (
    <div>
      <Header user={user} />
      <Main user={user} />
    </div>
  );
}

function Header({ user }) {
  // Header doesn't use user, just passes it down
  return (
    <header>
      <Navigation user={user} />
    </header>
  );
}

function Navigation({ user }) {
  // Finally! Someone who actually uses the user
  return (
    <nav>
      Welcome, {user.name}!
      {user.role === 'admin' && <AdminPanel />}
    </nav>
  );
}

// Solution: Component Composition
function BetterApp() {
  const user = { name: 'John', role: 'admin' };

  return (
    <Layout>
      <Header>
        <Navigation user={user} /> {/* Direct prop passing */}
      </Header>
      <Main user={user} />
    </Layout>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Context API

Like a family group chat where everyone can see the same messages without passing them person to person!

**Key Points:**

- Avoids prop drilling by sharing data globally
- Provider supplies values, consumers use them
- Perfect for themes, auth, language settings

<Details>
<Summary>Code example :</Summary>

```js
import { createContext, useContext, useState } from 'react';

// 1. Create Context
const UserContext = createContext();

// 2. Create Provider Component
function UserProvider({ children }) {
  const [user, setUser] = useState({ name: 'John', role: 'admin' });

  const login = (userData) => setUser(userData);
  const logout = () => setUser(null);

  return (
    <UserContext.Provider value={{ user, login, logout }}>
      {children}
    </UserContext.Provider>
  );
}

// 3. Custom hook for easy access
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

// 4. Use anywhere in the component tree
function App() {
  return (
    <UserProvider>
      <Layout />
    </UserProvider>
  );
}

function Header() {
  const { user, logout } = useUser(); // Direct access!

  return (
    <header>
      Welcome, {user?.name}!
      <button onClick={logout}>Logout</button>
    </header>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Suspense API

Like having a loading screen that automatically shows up while your content is getting ready behind the scenes!

**Key Points:**

- Shows fallback UI while components are loading
- Works with lazy loading and data fetching
- Can have multiple Suspense boundaries

<Details>
<Summary>Code example :</Summary>

```js
import { Suspense, lazy } from 'react';

// 1. Lazy Loading Components
const LazyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <div>
      <h1>My App</h1>

      <Suspense fallback={<div>Loading component...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

// 2. Data Fetching with Suspense
function UserProfile({ userId }) {
  const user = use(fetchUser(userId)); // Suspends until data loads

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

function ProfileApp() {
  return (
    <Suspense fallback={<div>Loading user...</div>}>
      <UserProfile userId={1} />
    </Suspense>
  );
}

// 3. Nested Suspense Boundaries
function NestedApp() {
  return (
    <Suspense fallback={<div>Loading app...</div>}>
      <Header />

      <Suspense fallback={<div>Loading posts...</div>}>
        <PostList />
      </Suspense>

      <Suspense fallback={<div>Loading sidebar...</div>}>
        <Sidebar />
      </Suspense>
    </Suspense>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### State Management Tools

Like having different sized storage boxes for your app's data - small box for simple stuff, big warehouse for complex apps!

**Key Points:**

- Context API: Built-in, good for simple global state
- Redux: Powerful, predictable state management with actions/reducers
- Zustand: Simple and lightweight alternative

<Details>
<Summary>Code example :</Summary>

```js
// 1. Context API (Built-in)
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  return (
    <AppContext.Provider value={{ user, setUser, theme, setTheme }}>
      {children}
    </AppContext.Provider>
  );
}

// 2. Redux (npm install @reduxjs/toolkit react-redux)
import { createSlice, configureStore } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; },
  }
});

// 3. Zustand (npm install zustand)
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Performance Optimization Minimize Renders

Like being a smart shopper who only buys what they actually need instead of buying everything in the store!

**Key Points:**

- Use React.memo to prevent unnecessary re-renders
- useMemo for expensive calculations
- useCallback for function references

<Details>
<Summary>Code example :</Summary>

```js
// 1. React.memo - prevents re-renders when props haven't changed
const ExpensiveChild = React.memo(({ name, count }) => {
  console.log('ExpensiveChild rendered');
  return <div>{name}: {count}</div>;
});

// 2. useMemo - cache expensive calculations
function ExpensiveList({ items, filter }) {
  const filteredItems = useMemo(() => {
    return items.filter(item => item.name.includes(filter));
  }, [items, filter]);

  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

// 3. useCallback - cache function references
function TodoApp() {
  const [todos, setTodos] = useState([]);

  const memoizedDelete = useCallback((id) => {
    setTodos(todos => todos.filter(todo => todo.id !== id));
  }, []); // Stable reference

  return (
    <div>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} onDelete={memoizedDelete} />
      ))}
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Hook Form

Like having a smart form assistant that handles all the paperwork while you focus on the important stuff!

**Key Points:**

- Minimal re-renders with uncontrolled components
- Built-in validation and error handling
- Easy integration with UI libraries

<Details>
<Summary>Code example :</Summary>

```js
// npm install react-hook-form
import { useForm } from 'react-hook-form';

function ContactForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset
  } = useForm();

  const onSubmit = async (data) => {
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('Form data:', data);
    reset();
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('name', {
          required: 'Name is required',
          minLength: { value: 2, message: 'Min 2 characters' }
        })}
        placeholder="Your name"
      />
      {errors.name && <span style={{color: 'red'}}>{errors.name.message}</span>}

      <input
        {...register('email', {
          required: 'Email is required',
          pattern: {
            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            message: 'Invalid email'
          }
        })}
        placeholder="Your email"
      />
      {errors.email && <span style={{color: 'red'}}>{errors.email.message}</span>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : 'Send'}
      </button>
    </form>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Formik

Like having a personal form trainer who guides you through every step of form creation and validation!

**Key Points:**

- More opinionated than React Hook Form
- Built-in field components and validation
- Great for complex forms with nested data

<Details>
<Summary>Code example :</Summary>

```js
// npm install formik yup
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * Yup from 'yup';

const validationSchema = Yup.object({
  name: Yup.string().min(2, 'Too Short!').required('Required'),
  email: Yup.string().email('Invalid email').required('Required'),
});

function FormikForm() {
  return (
    <Formik
      initialValues={{ name: '', email: '' }}
      validationSchema={validationSchema}
      onSubmit={async (values, { setSubmitting, resetForm }) => {
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('Form values:', values);
        resetForm();
        setSubmitting(false);
      }}
    >
      {({ isSubmitting }) => (
        <Form>
          <Field type="text" name="name" placeholder="Your name" />
          <ErrorMessage name="name" component="div" style={{color: 'red'}} />

          <Field type="email" name="email" placeholder="Your email" />
          <ErrorMessage name="email" component="div" style={{color: 'red'}} />

          <button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Submitting...' : 'Submit'}
          </button>
        </Form>
      )}
    </Formik>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### SWR

Like having a smart cache that automatically refreshes your data when you switch browser tabs or come back online!

**Key Points:**

- Stale-while-revalidate strategy
- Automatic caching, revalidation, and error handling
- Great for simple data fetching needs

<Details>
<Summary>Code example :</Summary>

```js
// npm install swr
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserProfile({ userId }) {
  const { data: user, error, isLoading, mutate } = useSWR(
    `/api/users/${userId}`,
    fetcher,
    {
      refreshInterval: 10000, // Refresh every 10 seconds
      revalidateOnFocus: true, // Refresh when window gets focus
    }
  );

  if (error) return <div>Failed to load user</div>;
  if (isLoading) return <div>Loading...</div>;

  const updateUser = async () => {
    // Optimistic update
    mutate({ ...user, name: 'Updated Name' }, false);

    try {
      await fetch(`/api/users/${userId}`, {
        method: 'PUT',
        body: JSON.stringify({ name: 'Updated Name' })
      });
      mutate(); // Revalidate
    } catch (error) {
      mutate(); // Revert on error
    }
  };

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={updateUser}>Update Name</button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Query

Like having a super-intelligent data manager that handles caching, syncing, updating, and error handling automatically!

**Key Points:**

- Most powerful data fetching library
- Advanced caching strategies and background updates
- Built-in optimistic updates and infinite queries

<Details>
<Summary>Code example :</Summary>

```js
// npm install @tanstack/react-query
import { QueryClient, QueryClientProvider, useQuery, useMutation } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <UserList />
    </QueryClientProvider>
  );
}

function UserList() {
  // Query for fetching data
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json()),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Mutation for creating users
  const createUserMutation = useMutation({
    mutationFn: (newUser) =>
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser)
      }).then(res => res.json()),
    onSuccess: () => {
      queryClient.invalidateQueries(['users']);
    }
  });

  if (isLoading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={() => createUserMutation.mutate({ name: 'New User' })}>
        Create User
      </button>

      <ul>
        {users?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### State Management for API Data

Like having a smart warehouse manager who knows exactly where all your data is stored and keeps it fresh!

**Key Points:**

- React Query handles server state separately from client state
- Automatically manages loading, error, and success states
- Keeps UI in sync with server data

<Details>
<Summary>Code example :</Summary>

```js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function UserDashboard() {
  const queryClient = useQueryClient();

  // Server state management
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });

  // Update server state
  const updateUserMutation = useMutation({
    mutationFn: (userData) =>
      fetch(`/api/users/${userData.id}`, {
        method: 'PUT',
        body: JSON.stringify(userData)
      }),
    onSuccess: (updatedUser) => {
      // Update cache immediately
      queryClient.setQueryData(['users'], (oldUsers) =>
        oldUsers.map(user =>
          user.id === updatedUser.id ? updatedUser : user
        )
      );
    }
  });

  const handleUpdateUser = (user) => {
    updateUserMutation.mutate({ ...user, name: 'Updated Name' });
  };

  if (isLoading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>Users ({users?.length})</h1>
      {users?.map(user => (
        <div key={user.id}>
          <span>{user.name}</span>
          <button onClick={() => handleUpdateUser(user)}>
            Update
          </button>
        </div>
      ))}
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Data Fetching

Like having a personal delivery service that brings you exactly what you need, when you need it!

**Key Points:**

- Declarative data fetching with useQuery
- Automatic retries and error handling
- Support for dependent queries and parallel fetching

<Details>
<Summary>Code example :</Summary>

```js
// Basic data fetching
function UserProfile({ userId }) {
  const { data: user, isLoading, error, refetch } = useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user');
      return response.json();
    },
    enabled: !!userId, // Only run if userId exists
    retry: 3, // Retry 3 times on failure
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  if (isLoading) return <div>Loading user...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  );
}

// Dependent queries
function UserPosts({ userId }) {
  // First, get user
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(res => res.json())
  });

  // Then get posts (depends on user)
  const { data: posts, isLoading } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => fetch(`/api/users/${user.id}/posts`).then(res => res.json()),
    enabled: !!user?.id // Only run when user is loaded
  });

  if (isLoading) return <div>Loading posts...</div>;

  return (
    <div>
      <h2>{user?.name}'s Posts</h2>
      {posts?.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}

// Parallel queries
function Dashboard() {
  const userQuery = useQuery({
    queryKey: ['user'],
    queryFn: () => fetch('/api/user').then(res => res.json())
  });

  const postsQuery = useQuery({
    queryKey: ['posts'],
    queryFn: () => fetch('/api/posts').then(res => res.json())
  });

  const notificationsQuery = useQuery({
    queryKey: ['notifications'],
    queryFn: () => fetch('/api/notifications').then(res => res.json())
  });

  if (userQuery.isLoading || postsQuery.isLoading || notificationsQuery.isLoading) {
    return <div>Loading dashboard...</div>;
  }

  return (
    <div>
      <h1>Welcome, {userQuery.data?.name}</h1>
      <p>Posts: {postsQuery.data?.length}</p>
      <p>Notifications: {notificationsQuery.data?.length}</p>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Caching

Like having a super-smart librarian who remembers exactly which books you've read and keeps your favorites within easy reach!

**Key Points:**

- Intelligent caching with automatic garbage collection
- Query invalidation and cache updates
- Background refetching keeps data fresh

<Details>
<Summary>Code example :</Summary>

```js
import { useQuery, useQueryClient } from '@tanstack/react-query';

function CachingExample() {
  const queryClient = useQueryClient();

  const { data: todos } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(res => res.json()),
    staleTime: 2 * 60 * 1000, // 2 minutes - data is fresh
    cacheTime: 10 * 60 * 1000, // 10 minutes - keep in cache
    refetchOnWindowFocus: true, // Refetch when window regains focus
    refetchOnReconnect: true, // Refetch when reconnected
    refetchInterval: 30000, // Refetch every 30 seconds
  });

  // Manual cache operations
  const prefetchTodos = () => {
    queryClient.prefetchQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/api/todos').then(res => res.json()),
      staleTime: 2 * 60 * 1000,
    });
  };

  const invalidateTodos = () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  };

  const updateTodoInCache = (todoId, updates) => {
    queryClient.setQueryData(['todos'], (oldTodos) =>
      oldTodos.map(todo =>
        todo.id === todoId ? { ...todo, ...updates } : todo
      )
    );
  };

  const removeTodoFromCache = (todoId) => {
    queryClient.setQueryData(['todos'], (oldTodos) =>
      oldTodos.filter(todo => todo.id !== todoId)
    );
  };

  return (
    <div>
      <h1>Todos ({todos?.length})</h1>

      <div>
        <button onClick={prefetchTodos}>Prefetch Todos</button>
        <button onClick={invalidateTodos}>Refresh Todos</button>
        <button onClick={() => updateTodoInCache(1, { completed: true })}>
          Mark Todo 1 Complete
        </button>
      </div>

      {todos?.map(todo => (
        <div key={todo.id}>
          <span style={{
            textDecoration: todo.completed ? 'line-through' : 'none'
          }}>
            {todo.title}
          </span>
          <button onClick={() => removeTodoFromCache(todo.id)}>
            Remove
          </button>
        </div>
      ))}
    </div>
  );
}

// Query with selective cache updates
function OptimizedTodoList() {
  const queryClient = useQueryClient();

  const addTodoMutation = useMutation({
    mutationFn: (newTodo) =>
      fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo)
      }).then(res => res.json()),
    onMutate: async (newTodo) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // Snapshot previous value
      const previousTodos = queryClient.getQueryData(['todos']);

      // Optimistically update cache
      queryClient.setQueryData(['todos'], (old) => [
        ...old,
        { id: Date.now(), ...newTodo, completed: false }
      ]);

      return { previousTodos };
    },
    onError: (err, newTodo, context) => {
      // Rollback on error
      queryClient.setQueryData(['todos'], context.previousTodos);
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });

  return (
    <div>
      <button onClick={() => addTodoMutation.mutate({ title: 'New Todo' })}>
        Add Todo
      </button>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Synchronization

Like having a perfect orchestra conductor who keeps all musicians playing in harmony, even when someone misses a beat!

**Key Points:**

- Real-time synchronization across components
- Optimistic updates with automatic rollback
- Window focus and network reconnection sync

<Details>
<Summary>Code example :</Summary>

```js
function SynchronizationExample() {
  const queryClient = useQueryClient();

  // Query that syncs across all components
  const { data: messages, isLoading } = useQuery({
    queryKey: ['messages'],
    queryFn: () => fetch('/api/messages').then(res => res.json()),
    refetchOnWindowFocus: true, // Sync when window regains focus
    refetchOnReconnect: true, // Sync when network reconnects
    refetchIntervalInBackground: true, // Keep syncing in background
    refetchInterval: 5000, // Sync every 5 seconds
  });

  // Mutation with optimistic updates
  const sendMessageMutation = useMutation({
    mutationFn: (message) =>
      fetch('/api/messages', {
        method: 'POST',
        body: JSON.stringify(message)
      }).then(res => res.json()),
    onMutate: async (newMessage) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['messages'] });

      // Snapshot the previous value
      const previousMessages = queryClient.getQueryData(['messages']);

      // Optimistically update to the new value
      queryClient.setQueryData(['messages'], (old) => [
        ...old,
        {
          id: `temp-${Date.now()}`,
          ...newMessage,
          timestamp: new Date().toISOString(),
          status: 'sending' // Optimistic status
        }
      ]);

      return { previousMessages };
    },
    onSuccess: (data, variables, context) => {
      // Replace optimistic update with real data
      queryClient.setQueryData(['messages'], (old) =>
        old.map(msg =>
          msg.id.toString().startsWith('temp-') && msg.text === variables.text
            ? { ...data, status: 'sent' }
            : msg
        )
      );
    },
    onError: (err, newMessage, context) => {
      // Rollback to previous state
      queryClient.setQueryData(['messages'], context.previousMessages);
      console.error('Failed to send message:', err);
    },
    onSettled: () => {
      // Always invalidate to ensure consistency
      queryClient.invalidateQueries({ queryKey: ['messages'] });
    },
  });

  const deleteMessageMutation = useMutation({
    mutationFn: (messageId) =>
      fetch(`/api/messages/${messageId}`, { method: 'DELETE' }),
    onMutate: async (messageId) => {
      await queryClient.cancelQueries({ queryKey: ['messages'] });

      const previousMessages = queryClient.getQueryData(['messages']);

      // Optimistically remove the message
      queryClient.setQueryData(['messages'], (old) =>
        old.filter(msg => msg.id !== messageId)
      );

      return { previousMessages };
    },
    onError: (err, messageId, context) => {
      queryClient.setQueryData(['messages'], context.previousMessages);
    },
  });

  if (isLoading) return <div>Loading messages...</div>;

  return (
    <div>
      <h1>Chat Messages</h1>

      <div>
        {messages?.map(message => (
          <div key={message.id} style={{
            opacity: message.status === 'sending' ? 0.5 : 1,
            border: message.status === 'sending' ? '1px dashed gray' : 'none'
          }}>
            <span>{message.text}</span>
            <small> - {message.timestamp}</small>
            {message.status === 'sending' && <span> (sending...)</span>}
            <button onClick={() => deleteMessageMutation.mutate(message.id)}>
              Delete
            </button>
          </div>
        ))}
      </div>

      <button onClick={() =>
        sendMessageMutation.mutate({
          text: `Hello at ${new Date().toLocaleTimeString()}`
        })
      }>
        Send Message
      </button>
    </div>
  );
}

// Multi-user synchronization
function MultiUserSync() {
  const { data: onlineUsers } = useQuery({
    queryKey: ['online-users'],
    queryFn: () => fetch('/api/users/online').then(res => res.json()),
    refetchInterval: 10000, // Check every 10 seconds
  });

  const { data: sharedDocument } = useQuery({
    queryKey: ['shared-doc'],
    queryFn: () => fetch('/api/document').then(res => res.json()),
    refetchOnWindowFocus: true, // Sync when switching back to tab
    refetchInterval: 2000, // Real-time sync every 2 seconds
  });

  return (
    <div>
      <div>Online Users: {onlineUsers?.length}</div>
      <div>Document: {sharedDocument?.content}</div>
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Project Based Learning with React Query

Like building a real house instead of just learning about bricks - you see how everything works together!

**Key Points:**

- Complete todo app with React Query
- Real-world patterns and best practices
- Error handling and loading states

<Details>
<Summary>Code example :</Summary>

```js
// Complete Todo App with React Query
import { QueryClient, QueryClientProvider, useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 10, // 10 minutes
      retry: 2,
      refetchOnWindowFocus: false,
    },
  },
});

function TodoApp() {
  return (
    <QueryClientProvider client={queryClient}>
      <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
        <h1>Todo App with React Query</h1>
        <AddTodoForm />
        <TodoList />
        <TodoStats />
      </div>
    </QueryClientProvider>
  );
}

function AddTodoForm() {
  const [text, setText] = useState('');
  const queryClient = useQueryClient();

  const addTodoMutation = useMutation({
    mutationFn: (newTodo) =>
      fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTodo),
      }).then(res => res.json()),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
      setText('');
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    }
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      addTodoMutation.mutate({
        text: text.trim(),
        completed: false,
        createdAt: new Date().toISOString(),
      });
    }
  };

  return (
    <form onSubmit={handleSubmit} style={{ marginBottom: '20px' }}>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add a new todo..."
        disabled={addTodoMutation.isLoading}
        style={{ padding: '8px', marginRight: '8px', width: '300px' }}
      />
      <button
        type="submit"
        disabled={addTodoMutation.isLoading || !text.trim()}
        style={{ padding: '8px 16px' }}
      >
        {addTodoMutation.isLoading ? 'Adding...' : 'Add Todo'}
      </button>
    </form>
  );
}

function TodoList() {
  const { data: todos, isLoading, error } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(res => res.json()),
  });

  if (isLoading) return <div>Loading todos...</div>;
  if (error) return <div>Error loading todos: {error.message}</div>;

  return (
    <div>
      {todos?.length === 0 ? (
        <p>No todos yet. Add one above!</p>
      ) : (
        <div>
          {todos?.map(todo => (
            <TodoItem key={todo.id} todo={todo} />
          ))}
        </div>
      )}
    </div>
  );
}

function TodoItem({ todo }) {
  const queryClient = useQueryClient();

  const updateTodoMutation = useMutation({
    mutationFn: (updatedTodo) =>
      fetch(`/api/todos/${todo.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedTodo),
      }).then(res => res.json()),
    onMutate: async (updatedTodo) => {
      await queryClient.cancelQueries({ queryKey: ['todos'] });
      const previousTodos = queryClient.getQueryData(['todos']);

      queryClient.setQueryData(['todos'], (old) =>
        old.map(t => t.id === todo.id ? { ...t, ...updatedTodo } : t)
      );

      return { previousTodos };
    },
    onError: (err, updatedTodo, context) => {
      queryClient.setQueryData(['todos'], context.previousTodos);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });

  const deleteTodoMutation = useMutation({
    mutationFn: () => fetch(`/api/todos/${todo.id}`, { method: 'DELETE' }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });

  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      padding: '8px',
      border: '1px solid #ddd',
      marginBottom: '4px',
      opacity: updateTodoMutation.isLoading ? 0.7 : 1
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={(e) =>
          updateTodoMutation.mutate({ completed: e.target.checked })
        }
        style={{ marginRight: '8px' }}
      />
      <span style={{
        flex: 1,
        textDecoration: todo.completed ? 'line-through' : 'none'
      }}>
        {todo.text}
      </span>
      <button
        onClick={() => deleteTodoMutation.mutate()}
        disabled={deleteTodoMutation.isLoading}
        style={{ marginLeft: '8px', padding: '4px 8px' }}
      >
        {deleteTodoMutation.isLoading ? 'Deleting...' : 'Delete'}
      </button>
    </div>
  );
}

function TodoStats() {
  const { data: todos } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(res => res.json()),
  });

  const total = todos?.length || 0;
  const completed = todos?.filter(todo => todo.completed).length || 0;
  const remaining = total - completed;

  return (
    <div style={{
      marginTop: '20px',
      padding: '16px',
      backgroundColor: '#f5f5f5',
      borderRadius: '4px'
    }}>
      <h3>Statistics</h3>
      <p>Total: {total}</p>
      <p>Completed: {completed}</p>
      <p>Remaining: {remaining}</p>
      <p>Progress: {total > 0 ? Math.round((completed / total) * 100) : 0}%</p>
    </div>
  );
}

export default TodoApp;
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Introduction to Testing in React

Like having a quality control inspector who checks every part of your car before it leaves the factory!

**Key Points:**

- Testing ensures your components work correctly and prevent bugs
- Different types: Unit tests, Integration tests, End-to-end tests
- React Testing Library focuses on testing user interactions

<Details>
<Summary>Code example :</Summary>

```js
// Simple component to test
function Welcome({ name, isLoggedIn }) {
  if (!isLoggedIn) {
    return <div>Please log in</div>;
  }

  return (
    <div>
      <h1>Welcome, {name}!</h1>
      <button onClick={() => alert('Logged out!')}>Logout</button>
    </div>
  );
}

// Basic test example
import { render, screen } from '@testing-library/react';
import Welcome from './Welcome';

test('shows login message when not logged in', () => {
  render(<Welcome name="John" isLoggedIn={false} />);

  expect(screen.getByText('Please log in')).toBeInTheDocument();
});

test('shows welcome message when logged in', () => {
  render(<Welcome name="John" isLoggedIn={true} />);

  expect(screen.getByText('Welcome, John!')).toBeInTheDocument();
  expect(screen.getByRole('button', { name: 'Logout' })).toBeInTheDocument();
});

// Testing user interactions
import { fireEvent } from '@testing-library/react';

test('shows alert when logout clicked', () => {
  // Mock window.alert
  window.alert = jest.fn();

  render(<Welcome name="John" isLoggedIn={true} />);

  const logoutButton = screen.getByRole('button', { name: 'Logout' });
  fireEvent.click(logoutButton);

  expect(window.alert).toHaveBeenCalledWith('Logged out!');
});

// Testing with different props
describe('Welcome component', () => {
  test('renders correctly with different names', () => {
    const names = ['Alice', 'Bob', 'Charlie'];

    names.forEach(name => {
      render(<Welcome name={name} isLoggedIn={true} />);
      expect(screen.getByText(`Welcome, ${name}!`)).toBeInTheDocument();
    });
  });
});
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Setting Up Jest and Component Testing

Like setting up a perfect workshop with all the right tools before you start building!

**Key Points:**

- Jest is the testing framework (comes with Create React App)
- React Testing Library provides utilities for testing React components
- Setup includes test files, matchers, and mock configurations

<Details>
<Summary>Code example :</Summary>

```js
// package.json - test dependencies
{
  "devDependencies": {
    "@testing-library/react": "^13.4.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/user-event": "^14.4.3",
    "jest": "^27.5.1"
  },
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}

// setupTests.js - global test setup
import '@testing-library/jest-dom';

// Optional: Custom matchers
expect.extend({
  toBeVisible(received) {
    const pass = received.style.display !== 'none';
    return {
      message: () => `expected element to ${pass ? 'not ' : ''}be visible`,
      pass,
    };
  }
});

// jest.config.js - Jest configuration
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapping: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/src/__mocks__/fileMock.js'
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/index.js',
    '!src/reportWebVitals.js'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};

// Component testing patterns
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p data-testid="count">Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

// Counter.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Counter from './Counter';

describe('Counter Component', () => {
  beforeEach(() => {
    render(<Counter />);
  });

  test('renders initial count', () => {
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');
  });

  test('increments count when increment button clicked', async () => {
    const user = userEvent.setup();
    const incrementButton = screen.getByRole('button', { name: 'Increment' });

    await user.click(incrementButton);

    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');
  });

  test('decrements count when decrement button clicked', async () => {
    const user = userEvent.setup();
    const decrementButton = screen.getByRole('button', { name: 'Decrement' });

    await user.click(decrementButton);

    expect(screen.getByTestId('count')).toHaveTextContent('Count: -1');
  });

  test('resets count when reset button clicked', async () => {
    const user = userEvent.setup();

    // First increment
    await user.click(screen.getByRole('button', { name: 'Increment' }));
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');

    // Then reset
    await user.click(screen.getByRole('button', { name: 'Reset' }));
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');
  });
});

// Testing with custom render function
function customRender(ui, options = {}) {
  const AllTheProviders = ({ children }) => {
    return (
      <ThemeProvider theme="light">
        <Router>
          {children}
        </Router>
      </ThemeProvider>
    );
  };

  return render(ui, { wrapper: AllTheProviders, ...options });
}

// Custom hook testing
import { renderHook, act } from '@testing-library/react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
}

test('useCounter hook works correctly', () => {
  const { result } = renderHook(() => useCounter(5));

  expect(result.current.count).toBe(5);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(6);

  act(() => {
    result.current.reset();
  });

  expect(result.current.count).toBe(5);
});
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Mocking and Spying

Like having a stunt double who can pretend to be anyone and tell you exactly what happened during the scene!

**Key Points:**

- Mocks replace real functions/modules with fake implementations
- Spies watch function calls and track what happened
- Essential for testing external dependencies and side effects

<Details>
<Summary>Code example :</Summary>

```js
// Basic mocking examples
describe('Mocking Functions', () => {
  test('mock a simple function', () => {
    const mockFn = jest.fn();
    mockFn('hello', 'world');

    expect(mockFn).toHaveBeenCalledWith('hello', 'world');
    expect(mockFn).toHaveBeenCalledTimes(1);
  });

  test('mock with return value', () => {
    const mockFn = jest.fn();
    mockFn.mockReturnValue(42);

    expect(mockFn()).toBe(42);
  });

  test('mock with different return values', () => {
    const mockFn = jest.fn();
    mockFn
      .mockReturnValueOnce('first')
      .mockReturnValueOnce('second')
      .mockReturnValue('default');

    expect(mockFn()).toBe('first');
    expect(mockFn()).toBe('second');
    expect(mockFn()).toBe('default');
  });
});

// Mocking modules
// __mocks__/axios.js
export default {
  get: jest.fn(() => Promise.resolve({ data: {} })),
  post: jest.fn(() => Promise.resolve({ data: {} })),
};

// Component that uses axios
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    axios.get(`/api/users/${userId}`)
      .then(response => {
        setUser(response.data);
        setLoading(false);
      })
      .catch(() => {
        setLoading(false);
      });
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

// Testing with mocked axios
import axios from 'axios';
import { render, screen, waitFor } from '@testing-library/react';
import UserProfile from './UserProfile';

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('UserProfile with mocked axios', () => {
  beforeEach(() => {
    mockedAxios.get.mockClear();
  });

  test('displays user data when API call succeeds', async () => {
    const userData = { id: 1, name: 'John Doe', email: 'john@example.com' };
    mockedAxios.get.mockResolvedValue({ data: userData });

    render(<UserProfile userId={1} />);

    expect(screen.getByText('Loading...')).toBeInTheDocument();

    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });

    expect(mockedAxios.get).toHaveBeenCalledWith('/api/users/1');
  });

  test('displays error message when API call fails', async () => {
    mockedAxios.get.mockRejectedValue(new Error('API Error'));

    render(<UserProfile userId={1} />);

    await waitFor(() => {
      expect(screen.getByText('User not found')).toBeInTheDocument();
    });
  });
});

// Spying on real functions
describe('Spying Examples', () => {
  test('spy on console.log', () => {
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

    function greet(name) {
      console.log(`Hello, ${name}!`);
      return `Greeting sent to ${name}`;
    }

    const result = greet('Alice');

    expect(consoleSpy).toHaveBeenCalledWith('Hello, Alice!');
    expect(result).toBe('Greeting sent to Alice');

    consoleSpy.mockRestore();
  });

  test('spy on object methods', () => {
    const user = {
      name: 'John',
      greet() {
        return `Hello, I'm ${this.name}`;
      }
    };

    const greetSpy = jest.spyOn(user, 'greet');

    const greeting = user.greet();

    expect(greetSpy).toHaveBeenCalled();
    expect(greeting).toBe("Hello, I'm John");

    greetSpy.mockRestore();
  });

  test('spy with custom implementation', () => {
    const mathUtils = {
      add: (a, b) => a + b,
      multiply: (a, b) => a * b
    };

    const addSpy = jest.spyOn(mathUtils, 'add')
      .mockImplementation((a, b) => {
        console.log(`Adding ${a} + ${b}`);
        return a + b;
      });

    const result = mathUtils.add(2, 3);

    expect(addSpy).toHaveBeenCalledWith(2, 3);
    expect(result).toBe(5);
  });
});

// Mocking React Router
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => jest.fn(),
  useParams: () => ({ id: '123' }),
  useLocation: () => ({ pathname: '/users/123' })
}));

// Mocking local storage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
});

test('component uses localStorage', () => {
  localStorageMock.getItem.mockReturnValue('saved-data');

  render(<MyComponent />);

  expect(localStorageMock.getItem).toHaveBeenCalledWith('user-preferences');
});
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Testing Async Code

Like being a patient detective who waits for all the clues to arrive before solving the case!

**Key Points:**

- Use waitFor for elements that appear after async operations
- Mock API calls and promises for predictable testing
- Handle loading states, success, and error scenarios

<Details>
<Summary>Code example :</Summary>

```js
// Component with async operations
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/users');
      if (!response.ok) throw new Error('Failed to fetch');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const deleteUser = async (userId) => {
    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      setUsers(users.filter(user => user.id !== userId));
    } catch (err) {
      setError('Failed to delete user');
    }
  };

  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h1>Users ({users.length})</h1>
      {users.map(user => (
        <div key={user.id}>
          <span>{user.name}</span>
          <button onClick={() => deleteUser(user.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}

// Testing async component
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// Mock fetch globally
global.fetch = jest.fn();

describe('UserList Async Tests', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  test('displays loading state initially', () => {
    fetch.mockResolvedValue({
      ok: true,
      json: async () => []
    });

    render(<UserList />);

    expect(screen.getByText('Loading users...')).toBeInTheDocument();
  });

  test('displays users after successful fetch', async () => {
    const mockUsers = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' }
    ];

    fetch.mockResolvedValue({
      ok: true,
      json: async () => mockUsers
    });

    render(<UserList />);

    // Wait for loading to finish
    await waitFor(() => {
      expect(screen.queryByText('Loading users...')).not.toBeInTheDocument();
    });

    // Check if users are displayed
    expect(screen.getByText('Users (2)')).toBeInTheDocument();
    expect(screen.getByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();
  });

  test('displays error message when fetch fails', async () => {
    fetch.mockRejectedValue(new Error('Network error'));

    render(<UserList />);

    await waitFor(() => {
      expect(screen.getByText('Error: Network error')).toBeInTheDocument();
    });
  });

  test('deletes user when delete button clicked', async () => {
    const mockUsers = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' }
    ];

    // Mock initial fetch
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockUsers
    });

    render(<UserList />);

    // Wait for initial load
    await waitFor(() => {
      expect(screen.getByText('Alice')).toBeInTheDocument();
    });

    // Mock delete request
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({})
    });

    // Click delete button for Alice
    const deleteButton = screen.getAllByText('Delete')[0];
    fireEvent.click(deleteButton);

    // Wait for Alice to be removed
    await waitFor(() => {
      expect(screen.queryByText('Alice')).not.toBeInTheDocument();
    });

    expect(screen.getByText('Bob')).toBeInTheDocument();
    expect(fetch).toHaveBeenCalledWith('/api/users/1', { method: 'DELETE' });
  });
});

// Testing with React Query
function UserListWithQuery() {
  const { data: users, isLoading, error, refetch } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      {users?.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}

// Testing React Query component
import { QueryClient, QueryClientProvider } from 'react-query';

test('React Query component loads data', async () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });

  fetch.mockResolvedValue({
    ok: true,
    json: async () => [{ id: 1, name: 'Alice' }]
  });

  render(
    <QueryClientProvider client={queryClient}>
      <UserListWithQuery />
    </QueryClientProvider>
  );

  expect(screen.getByText('Loading...')).toBeInTheDocument();

  await waitFor(() => {
    expect(screen.getByText('Alice')).toBeInTheDocument();
  });
});

// Testing custom async hooks
function useAsyncUser(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;

    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();

        if (!cancelled) {
          setUser(userData);
          setLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
          setLoading(false);
        }
      }
    };

    fetchUser();

    return () => {
      cancelled = true;
    };
  }, [userId]);

  return { user, loading, error };
}

// Testing the custom hook
import { renderHook, waitFor } from '@testing-library/react';

test('useAsyncUser hook fetches user data', async () => {
  const mockUser = { id: 1, name: 'Alice' };

  fetch.mockResolvedValue({
    ok: true,
    json: async () => mockUser
  });

  const { result } = renderHook(() => useAsyncUser(1));

  expect(result.current.loading).toBe(true);
  expect(result.current.user).toBe(null);

  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });

  expect(result.current.user).toEqual(mockUser);
  expect(result.current.error).toBe(null);
});

// Testing with timers
function DelayedMessage() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const timer = setTimeout(() => {
      setMessage('Hello after 2 seconds!');
    }, 2000);

    return () => clearTimeout(timer);
  }, []);

  return <div>{message || 'Waiting...'}</div>;
}

test('displays message after delay', async () => {
  jest.useFakeTimers();

  render(<DelayedMessage />);

  expect(screen.getByText('Waiting...')).toBeInTheDocument();

  // Fast-forward time
  jest.advanceTimersByTime(2000);

  await waitFor(() => {
    expect(screen.getByText('Hello after 2 seconds!')).toBeInTheDocument();
  });

  jest.useRealTimers();
});
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Project Test Login Page and UI

Like building a complete security system test for your house - checking every door, window, and alarm!

**Key Points:**

- Complete testing of login form validation
- Testing user interactions and form submission
- Integration testing with authentication flow

<Details>
<Summary>Code example :</Summary>

```js
// LoginPage.js - Component to test
function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});
  const [loading, setLoading] = useState(false);
  const [loginSuccess, setLoginSuccess] = useState(false);

  const validateForm = () => {
    const newErrors = {};

    if (!email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!password) {
      newErrors.password = 'Password is required';
    } else if (password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) return;

    setLoading(true);

    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      if (response.ok) {
        const data = await response.json();
        localStorage.setItem('token', data.token);
        setLoginSuccess(true);
      } else {
        const errorData = await response.json();
        setErrors({ submit: errorData.message || 'Login failed' });
      }
    } catch (error) {
      setErrors({ submit: 'Network error. Please try again.' });
    } finally {
      setLoading(false);
    }
  };

  if (loginSuccess) {
    return (
      <div className="success-message">
        <h2>Login Successful!</h2>
        <p>Welcome back!</p>
      </div>
    );
  }

  return (
    <div className="login-page">
      <form onSubmit={handleSubmit} className="login-form">
        <h1>Login</h1>

        <div className="form-group">
          <label htmlFor="email">Email:</label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className={errors.email ? 'error' : ''}
            aria-describedby={errors.email ? 'email-error' : undefined}
          />
          {errors.email && (
            <span id="email-error" className="error-message" role="alert">
              {errors.email}
            </span>
          )}
        </div>

        <div className="form-group">
          <label htmlFor="password">Password:</label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className={errors.password ? 'error' : ''}
            aria-describedby={errors.password ? 'password-error' : undefined}
          />
          {errors.password && (
            <span id="password-error" className="error-message" role="alert">
              {errors.password}
            </span>
          )}
        </div>

        {errors.submit && (
          <div className="error-message" role="alert">
            {errors.submit}
          </div>
        )}

        <button
          type="submit"
          disabled={loading}
          className="submit-button"
        >
          {loading ? 'Logging in...' : 'Login'}
        </button>
      </form>
    </div>
  );
}

// LoginPage.test.js - Comprehensive test suite
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginPage from './LoginPage';

// Mock fetch
global.fetch = jest.fn();

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
Object.defineProperty(window, 'localStorage', { value: localStorageMock });

describe('LoginPage Component', () => {
  beforeEach(() => {
    fetch.mockClear();
    localStorageMock.setItem.mockClear();
    localStorageMock.getItem.mockClear();
  });

  // Rendering Tests
  describe('Rendering', () => {
    test('renders login form with all elements', () => {
      render(<LoginPage />);

      expect(screen.getByRole('heading', { name: 'Login' })).toBeInTheDocument();
      expect(screen.getByLabelText('Email:')).toBeInTheDocument();
      expect(screen.getByLabelText('Password:')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument();
    });

    test('form elements have correct attributes', () => {
      render(<LoginPage />);

      const emailInput = screen.getByLabelText('Email:');
      const passwordInput = screen.getByLabelText('Password:');

      expect(emailInput).toHaveAttribute('type', 'email');
      expect(passwordInput).toHaveAttribute('type', 'password');
      expect(emailInput).toHaveAttribute('id', 'email');
      expect(passwordInput).toHaveAttribute('id', 'password');
    });
  });

  // Form Validation Tests
  describe('Form Validation', () => {
    test('shows error when email is empty', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      const submitButton = screen.getByRole('button', { name: 'Login' });
      await user.click(submitButton);

      expect(screen.getByText('Email is required')).toBeInTheDocument();
      expect(screen.getByRole('alert')).toBeInTheDocument();
    });

    test('shows error when email is invalid', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'invalid-email');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Email is invalid')).toBeInTheDocument();
    });

    test('shows error when password is empty', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Password is required')).toBeInTheDocument();
    });

    test('shows error when password is too short', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), '123');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Password must be at least 6 characters')).toBeInTheDocument();
    });

    test('clears errors when valid input is entered', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      // First, trigger error
      await user.click(screen.getByRole('button', { name: 'Login' }));
      expect(screen.getByText('Email is required')).toBeInTheDocument();

      // Then enter valid email
      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');

      // Errors should be cleared when form is resubmitted
      fetch.mockResolvedValue({
        ok: true,
        json: async () => ({ token: 'fake-token' })
      });

      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.queryByText('Email is required')).not.toBeInTheDocument();
    });
  });

  // User Interaction Tests
  describe('User Interactions', () => {
    test('updates input values when user types', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      const emailInput = screen.getByLabelText('Email:');
      const passwordInput = screen.getByLabelText('Password:');

      await user.type(emailInput, 'user@example.com');
      await user.type(passwordInput, 'mypassword');

      expect(emailInput).toHaveValue('user@example.com');
      expect(passwordInput).toHaveValue('mypassword');
    });

    test('form can be submitted by pressing Enter', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      fetch.mockResolvedValue({
        ok: true,
        json: async () => ({ token: 'fake-token' })
      });

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');
      await user.keyboard('{Enter}');

      await waitFor(() => {
        expect(fetch).toHaveBeenCalledWith('/api/login', expect.any(Object));
      });
    });
  });

  // API Integration Tests
  describe('API Integration', () => {
    test('successful login saves token and shows success message', async () => {
      const user = userEvent.setup();
      const mockToken = 'mock-jwt-token';

      fetch.mockResolvedValue({
        ok: true,
        json: async () => ({ token: mockToken })
      });

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Logging in...')).toBeInTheDocument();

      await waitFor(() => {
        expect(screen.getByText('Login Successful!')).toBeInTheDocument();
      });

      expect(localStorageMock.setItem).toHaveBeenCalledWith('token', mockToken);
      expect(fetch).toHaveBeenCalledWith('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'password123'
        })
      });
    });

    test('failed login shows error message', async () => {
      const user = userEvent.setup();

      fetch.mockResolvedValue({
        ok: false,
        json: async () => ({ message: 'Invalid credentials' })
      });

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'wrongpassword');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      await waitFor(() => {
        expect(screen.getByText('Invalid credentials')).toBeInTheDocument();
      });

      expect(localStorageMock.setItem).not.toHaveBeenCalled();
    });

    test('network error shows error message', async () => {
      const user = userEvent.setup();

      fetch.mockRejectedValue(new Error('Network error'));

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      await waitFor(() => {
        expect(screen.getByText('Network error. Please try again.')).toBeInTheDocument();
      });
    });

    test('button is disabled during loading', async () => {
      const user = userEvent.setup();

      // Mock a slow response
      fetch.mockImplementation(() =>
        new Promise(resolve =>
          setTimeout(() => resolve({
            ok: true,
            json: async () => ({ token: 'token' })
          }), 100)
        )
      );

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');

      const submitButton = screen.getByRole('button', { name: 'Login' });
      await user.click(submitButton);

      expect(screen.getByRole('button', { name: 'Logging in...' })).toBeDisabled();

      await waitFor(() => {
        expect(screen.getByText('Login Successful!')).toBeInTheDocument();
      });
    });
  });

  // Accessibility Tests
  describe('Accessibility', () => {
    test('error messages have proper ARIA attributes', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.click(screen.getByRole('button', { name: 'Login' }));

      const emailError = screen.getByText('Email is required');
      const passwordError = screen.getByText('Password is required');

      expect(emailError).toHaveAttribute('role', 'alert');
      expect(passwordError).toHaveAttribute('role', 'alert');
      expect(emailError).toHaveAttribute('id', 'email-error');
      expect(passwordError).toHaveAttribute('id', 'password-error');

      const emailInput = screen.getByLabelText('Email:');
      const passwordInput = screen.getByLabelText('Password:');

      expect(emailInput).toHaveAttribute('aria-describedby', 'email-error');
      expect(passwordInput).toHaveAttribute('aria-describedby', 'password-error');
    });

    test('form is keyboard navigable', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      // Tab through form elements
      await user.tab();
      expect(screen.getByLabelText('Email:')).toHaveFocus();

      await user.tab();
      expect(screen.getByLabelText('Password:')).toHaveFocus();

      await user.tab();
      expect(screen.getByRole('button', { name: 'Login' })).toHaveFocus();
    });
  });

  // Edge Cases
  describe('Edge Cases', () => {
    test('handles multiple rapid submissions', async () => {
      const user = userEvent.setup();

      fetch.mockImplementation(() =>
        new Promise(resolve =>
          setTimeout(() => resolve({
            ok: true,
            json: async () => ({ token: 'token' })
          }), 100)
        )
      );

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');

      const submitButton = screen.getByRole('button', { name: 'Login' });

      // Rapidly click multiple times
      await user.click(submitButton);
      await user.click(submitButton);
      await user.click(submitButton);

      // Should only make one API call
      await waitFor(() => {
        expect(screen.getByText('Login Successful!')).toBeInTheDocument();
      });

      expect(fetch).toHaveBeenCalledTimes(1);
    });
  });
});
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Webpack Mastery

Imagine you're a master chef who takes all your ingredients (JavaScript files, CSS, images) and combines them into one perfect dish that's ready to serve to your customers!

**Key Points:**

- Webpack bundles all your files into optimized packages
- Handles code splitting and lazy loading automatically
- Transforms modern code to work in older browsers
- Optimizes assets for production (minification, compression)

**Real-life example:** Like a magical kitchen that takes all your recipe ingredients scattered around and creates one perfectly cooked meal, ready to serve.

<Details>
<Summary>Code example :</Summary>

```javascript
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // Entry point - where webpack starts building
  entry: './src/index.js',

  // Output configuration
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js', // Cache busting with hash
    clean: true // Clean dist folder before each build
  },

  // Development server
  devServer: {
    contentBase: './dist',
    hot: true, // Hot module replacement
    port: 3000
  },

  // Loaders - how webpack processes different files
  module: {
    rules: [
      {
        test: /\.jsx?$/, // Process .js and .jsx files
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-react', '@babel/preset-env']
          }
        }
      },
      {
        test: /\.css$/, // Process CSS files
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|jpg|gif|svg)$/, // Process images
        type: 'asset/resource'
      }
    ]
  },

  // Plugins - extend webpack functionality
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      favicon: './public/favicon.ico'
    })
  ],

  // Code splitting configuration
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  },

  // Resolve configuration
  resolve: {
    extensions: ['.js', '.jsx'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
};

// package.json scripts
{
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "analyze": "webpack-bundle-analyzer dist/static/js/*.js"
  }
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Essential Git Commands

Git is like having a time machine for your code - you can save snapshots, go back in time, and work with friends without messing up each other's work!

**Key Points:**

- Git tracks every change you make to your code
- Branches let you work on features without breaking main code
- Push/pull keeps everyone's code synchronized
- Merge combines different people's work together

**Real-life example:** Like having multiple drafts of your school essay - you can try different versions, save the good ones, and combine the best parts from each draft.

<Details>
<Summary>Code example :</Summary>

```bash
# Initial setup (one time)
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"

# Starting a new project
git init                          # Initialize git in current folder
git clone <repository-url>        # Copy existing project from GitHub

# Daily workflow
git status                        # Check what files changed
git add .                         # Stage all changes
git add filename.js               # Stage specific file
git commit -m "Add login feature"  # Save changes with message

# Working with remote repository
git remote add origin <url>       # Connect to GitHub repository
git push origin main              # Upload your changes
git pull origin main              # Download latest changes

# Branching workflow
git branch                        # List all branches
git branch feature-login          # Create new branch
git checkout feature-login        # Switch to branch
git checkout -b feature-signup    # Create and switch in one command

# Merging branches
git checkout main                 # Switch to main branch
git merge feature-login           # Merge feature into main
git branch -d feature-login       # Delete merged branch

# Checking history
git log                           # View commit history
git log --oneline                 # Condensed history
git show <commit-id>              # View specific commit details

# Undoing changes
git checkout -- filename.js      # Discard changes in file
git reset HEAD filename.js       # Unstage file
git reset --hard HEAD~1          # Go back one commit (careful!)

# Collaborative workflow
git fetch                         # Check for remote changes
git pull                          # Fetch and merge remote changes
git push                          # Push your commits to remote

# Handling conflicts
# When merge conflicts occur:
# 1. Open conflicted files
# 2. Look for <<<<<<< ======= >>>>>>> markers
# 3. Choose which code to keep
# 4. Remove conflict markers
# 5. git add <resolved-files>
# 6. git commit

# Useful commands for React projects
git add package.json package-lock.json  # Always commit lock files
git checkout -- package-lock.json       # Reset lock file conflicts
echo "node_modules/" >> .gitignore       # Ignore node_modules
echo "build/" >> .gitignore              # Ignore build folder
echo ".env" >> .gitignore                # Ignore environment files

# Branch naming conventions
git checkout -b feature/user-authentication
git checkout -b bugfix/login-error
git checkout -b hotfix/critical-security-issue
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Docker Setup for React

Docker is like having a magic shipping container that carries your React app with everything it needs - no matter where you send it, it runs exactly the same way!

**Key Points:**

- Docker packages your app with all dependencies
- Ensures your app runs the same everywhere (dev, staging, production)
- Easy to deploy and scale your application
- Isolates your app from the host system

**Real-life example:** Like packing your entire bedroom (furniture, decorations, everything) into a magic box that you can recreate perfectly in any house.

<Details>
<Summary>Code example :</Summary>

```dockerfile
# Dockerfile for React app
# Multi-stage build for optimization

# Stage 1: Build the app
FROM node:18-alpine as build

# Set working directory
WORKDIR /app

# Copy package files first (for better caching)
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build the app
RUN npm run build

# Stage 2: Serve the app with nginx
FROM nginx:alpine

# Copy built app from previous stage
COPY --from=build /app/build /usr/share/nginx/html

# Copy custom nginx config (optional)
COPY nginx.conf /etc/nginx/nginx.conf

# Expose port 80
EXPOSE 80

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
```

```yaml
# docker-compose.yml for development
version: '3.8'

services:
  react-app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - CHOKIDAR_USEPOLLING=true
    stdin_open: true
    tty: true

  # Optional: Add a backend service
  api:
    image: node:18-alpine
    working_dir: /app
    volumes:
      - ./api:/app
    ports:
      - "5000:5000"
    command: npm start
```

```dockerfile
# Dockerfile.dev for development
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies)
RUN npm install

# Copy source code
COPY . .

# Expose development port
EXPOSE 3000

# Start development server
CMD ["npm", "start"]
```

```bash
# Docker commands for React development

# Build the Docker image
docker build -t my-react-app .

# Run the container
docker run -p 3000:3000 my-react-app

# Run in development mode with live reload
docker run -p 3000:3000 -v $(pwd):/app -v /app/node_modules my-react-app

# Using docker-compose (easier for development)
docker-compose up                    # Start all services
docker-compose up --build           # Rebuild and start
docker-compose down                  # Stop all services
docker-compose logs react-app       # View logs

# Production deployment
docker build -t my-react-app:prod .
docker run -d -p 80:80 my-react-app:prod

# Useful Docker commands
docker ps                           # List running containers
docker images                       # List all images
docker exec -it <container-id> sh   # Access container shell
docker logs <container-id>          # View container logs
docker system prune                 # Clean up unused resources
```

```nginx
# nginx.conf for production serving
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;

        # Handle React Router (SPA routing)
        location / {
            try_files $uri $uri/ /index.html;
        }

        # Cache static assets
        location /static/ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # Gzip compression
        gzip on;
        gzip_types text/css application/javascript application/json;
    }
}
```

```json
// .dockerignore
node_modules
npm-debug.log
build
.git
.gitignore
README.md
Dockerfile
.dockerignore
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### CI CD with GitLab

CI/CD is like having a super-efficient assembly line that automatically tests, builds, and delivers your React app every time you make changes - no manual work needed!

**Key Points:**

- CI (Continuous Integration) automatically tests your code
- CD (Continuous Deployment) automatically deploys working code
- Catches bugs before they reach users
- Saves time and reduces human errors

**Real-life example:** Like having a robot that automatically checks your homework, fixes any mistakes, and submits it to your teacher every time you finish writing.

<Details>
<Summary>Code example :</Summary>

```yaml
# .gitlab-ci.yml - GitLab CI/CD pipeline
image: node:18-alpine

# Define pipeline stages
stages:
  - install
  - test
  - build
  - deploy

# Cache node_modules for faster builds
cache:
  paths:
    - node_modules/

# Stage 1: Install dependencies
install_dependencies:
  stage: install
  script:
    - npm ci
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour

# Stage 2: Run tests
test_app:
  stage: test
  script:
    - npm run test -- --coverage --watchAll=false
    - npm run lint
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

# Stage 3: Build the app
build_app:
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - build/
    expire_in: 1 week
  only:
    - main
    - develop

# Stage 4: Deploy to staging
deploy_staging:
  stage: deploy
  environment:
    name: staging
    url: https://staging.myapp.com
  script:
    - echo "Deploying to staging server..."
    - scp -r build/* user@staging-server:/var/www/html/
    - ssh user@staging-server "sudo systemctl reload nginx"
  only:
    - develop

# Stage 5: Deploy to production
deploy_production:
  stage: deploy
  environment:
    name: production
    url: https://myapp.com
  script:
    - echo "Deploying to production server..."
    - docker build -t my-react-app:$CI_COMMIT_SHA .
    - docker push registry.gitlab.com/username/my-react-app:$CI_COMMIT_SHA
    - kubectl set image deployment/react-app react-app=registry.gitlab.com/username/my-react-app:$CI_COMMIT_SHA
  when: manual  # Require manual approval for production
  only:
    - main

# Docker build and push job
build_docker:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - main
```

```yaml
# Advanced GitLab CI with multiple environments
variables:
  NODE_VERSION: "18"
  DOCKER_DRIVER: overlay2

# Job templates for reuse
.node_template: &node_template
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --cache .npm --prefer-offline

.deploy_template: &deploy_template
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
    - apk add --no-cache openssh-client

# Security scanning
security_scan:
  stage: test
  <<: *node_template
  script:
    - npm audit --audit-level moderate
    - npm run security-check
  allow_failure: true

# Performance testing
lighthouse_test:
  stage: test
  image: circleci/node:18-browsers
  script:
    - npm run build
    - npm install -g lighthouse
    - lighthouse --chrome-flags="--headless --no-sandbox" --output json --output html http://localhost:3000
  artifacts:
    paths:
      - lighthouse-report.html
    expire_in: 1 week

# Deploy to different environments based on branch
deploy_review:
  <<: *deploy_template
  stage: deploy
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    url: https://$CI_COMMIT_REF_SLUG.review.myapp.com
    on_stop: stop_review
  script:
    - echo "Deploying review app for $CI_COMMIT_REF_SLUG"
    - curl -X POST "https://api.heroku.com/apps" \
      -H "Authorization: Bearer $HEROKU_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{"name":"myapp-'$CI_COMMIT_REF_SLUG'"}'
  only:
    - merge_requests

stop_review:
  <<: *deploy_template
  stage: deploy
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  script:
    - echo "Stopping review app for $CI_COMMIT_REF_SLUG"
    - curl -X DELETE "https://api.heroku.com/apps/myapp-$CI_COMMIT_REF_SLUG" \
      -H "Authorization: Bearer $HEROKU_API_KEY"
  when: manual
  only:
    - merge_requests
```

```bash
# GitLab CI/CD environment variables to set in GitLab UI:
# Settings > CI/CD > Variables

# Docker registry
CI_REGISTRY_USER=gitlab-ci-token
CI_REGISTRY_PASSWORD=$CI_JOB_TOKEN
CI_REGISTRY=registry.gitlab.com

# Deployment keys
SSH_PRIVATE_KEY=<your-ssh-private-key>
HEROKU_API_KEY=<your-heroku-api-key>
AWS_ACCESS_KEY_ID=<your-aws-key>
AWS_SECRET_ACCESS_KEY=<your-aws-secret>

# Application settings
REACT_APP_API_URL=https://api.myapp.com
REACT_APP_ENVIRONMENT=production
```

```dockerfile
# Dockerfile optimized for CI/CD
FROM node:18-alpine as build

WORKDIR /app

# Copy package files for better layer caching
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine

COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

# Health check for container orchestration
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Tooling Bootstrapping

Bootstrapping is like choosing between different construction starter kits - each gives you a different foundation and set of tools to build your React house!

**Key Points:**

- Create React App: Easy starter kit with everything included
- Vite: Super fast development with modern tooling
- Next.js: Full-stack framework with server-side features
- Custom setup: Complete control but more complexity

**Real-life example:** Like choosing between a pre-built house kit (CRA), a modern modular kit (Vite), a smart home system (Next.js), or building from individual materials (custom).

<Details>
<Summary>Code example :</Summary>

```bash
# 1. CREATE REACT APP (Traditional, stable)
npx create-react-app my-app
cd my-app
npm start

# Features: Hot reload, ESLint, testing, build optimization
# Pros: Stable, well-documented, everything included
# Cons: Slower, harder to customize, larger bundle

# Package.json scripts:
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"  // One-way operation!
  }
}
```

```bash
# 2. VITE (Modern, fast)
npm create vite@latest my-app -- --template react
cd my-app
npm install
npm run dev

# Features: Lightning fast HMR, modern ES modules, smaller bundle
# Pros: Super fast, modern, flexible, great dev experience
# Cons: Newer (less stable), smaller ecosystem

# vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: 'build',
    sourcemap: true
  }
})
```

```bash
# 3. NEXT.JS (Full-stack framework)
npx create-next-app@latest my-app
cd my-app
npm run dev

# Features: SSR, SSG, API routes, file-based routing, automatic optimization
# Pros: SEO-friendly, performance optimized, full-stack
# Cons: Learning curve, specific patterns, can be overkill

# next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  images: {
    domains: ['example.com']
  },
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'https://api.example.com/:path*'
      }
    ]
  }
}

module.exports = nextConfig
```

```bash
# 4. CUSTOM WEBPACK SETUP (Maximum control)
mkdir my-custom-app
cd my-custom-app
npm init -y

# Install dependencies
npm install react react-dom
npm install -D webpack webpack-cli webpack-dev-server
npm install -D babel-loader @babel/core @babel/preset-react @babel/preset-env
npm install -D html-webpack-plugin css-loader style-loader
```

```javascript
// webpack.config.js for custom setup
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.[contenthash].js',
    clean: true
  },
  devServer: {
    port: 3000,
    hot: true,
    historyApiFallback: true
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              '@babel/preset-env',
              ['@babel/preset-react', { runtime: 'automatic' }]
            ]
          }
        }
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html'
    })
  ],
  resolve: {
    extensions: ['.js', '.jsx']
  }
};
```

```json
// Package.json for custom setup
{
  "name": "my-custom-app",
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development --open"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.21.0",
    "@babel/preset-env": "^7.21.0",
    "@babel/preset-react": "^7.18.6",
    "babel-loader": "^9.1.2",
    "css-loader": "^6.7.3",
    "html-webpack-plugin": "^5.5.0",
    "style-loader": "^3.3.2",
    "webpack": "^5.76.0",
    "webpack-cli": "^5.0.1",
    "webpack-dev-server": "^4.11.1"
  }
}
```

```bash
# 5. OTHER MODERN ALTERNATIVES

# Parcel (Zero configuration)
npm install -g parcel-bundler
parcel index.html

# Snowpack (Modern, fast)
npx create-snowpack-app my-app --template @snowpack/app-template-react

# Remix (Full-stack, web standards focused)
npx create-remix@latest my-app

# Gatsby (Static site generator)
npx create-gatsby my-app

# Comparison table for choosing:
#
# | Tool | Speed | Setup | Flexibility | Learning Curve | Best For |
# |------|-------|-------|-------------|----------------|----------|
# | CRA | Slow | Easy | Low | Easy | Beginners, prototypes |
# | Vite | Fast | Easy | Medium | Easy | Modern SPAs |
# | Next.js | Medium | Easy | High | Medium | Full-stack, SEO |
# | Custom | Varies | Hard | Maximum | Hard | Special requirements |
```

```bash
# Development workflow comparison

# Create React App workflow:
npx create-react-app my-app
cd my-app
npm start                    # Start dev server
npm test                     # Run tests
npm run build               # Build for production
npm run eject               # Eject (irreversible!)

# Vite workflow:
npm create vite@latest my-app -- --template react
cd my-app
npm install
npm run dev                 # Start dev server (faster!)
npm run build              # Build for production
npm run preview            # Preview production build

# Next.js workflow:
npx create-next-app@latest my-app
cd my-app
npm run dev                # Start dev server with SSR
npm run build             # Build with optimizations
npm start                 # Start production server
npm run export            # Export static site

# Tips for choosing:
# - Learning React? Start with Create React App
# - Want speed and modern tools? Use Vite
# - Need SEO or server-side features? Use Next.js
# - Have specific requirements? Build custom setup
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Webpack

Webpack is like a smart factory manager that takes all your messy code ingredients and organizes them into perfectly packaged boxes ready for delivery!

**Key Points:**

- Module bundler that combines all your files into optimized bundles
- Transforms and processes different file types (JS, CSS, images)
- Code splitting for better performance and loading
- Hot Module Replacement for instant development feedback

**Real-life example:** Like having a factory that takes raw materials (your code files) and produces finished products (optimized bundles) ready to ship to customers.

<Details>
<Summary>Code example :</Summary>

```javascript
// Basic webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // Entry point - where to start bundling
  entry: './src/index.js',

  // Where to output the bundled files
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.[contenthash].js',
    clean: true
  },

  // Development server configuration
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 3000,
    hot: true, // Hot Module Replacement
    historyApiFallback: true // For React Router
  },

  // How to process different file types
  module: {
    rules: [
      // JavaScript/JSX files
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              '@babel/preset-env',
              '@babel/preset-react'
            ]
          }
        }
      },
      // CSS files
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader']
      },
      // SCSS files
      {
        test: /\.scss$/i,
        use: ['style-loader', 'css-loader', 'sass-loader']
      },
      // Images
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource'
      },
      // Fonts
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource'
      }
    ]
  },

  // Plugins extend webpack functionality
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      filename: 'index.html'
    })
  ],

  // Performance optimizations
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  },

  // File extensions to resolve
  resolve: {
    extensions: ['.js', '.jsx'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@components': path.resolve(__dirname, 'src/components')
    }
  }
};

// Production configuration
const prodConfig = {
  mode: 'production',
  optimization: {
    minimize: true,
    sideEffects: false,
    usedExports: true
  }
};

// Development configuration
const devConfig = {
  mode: 'development',
  devtool: 'eval-source-map'
};

// Package.json scripts
{
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "build:dev": "webpack --mode development",
    "analyze": "webpack-bundle-analyzer dist/static/js/*.js"
  }
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Vite

Vite is like a race car mechanic that makes your development super fast - it only fixes the parts that changed instead of rebuilding the entire car every time!

**Key Points:**

- Lightning-fast development server with instant Hot Module Replacement
- Uses native ES modules for faster builds
- Out-of-the-box support for TypeScript, JSX, CSS, and more
- Optimized production builds with Rollup

**Real-life example:** Like having a super-efficient editor that only updates the paragraph you're typing instead of reloading the entire document every time you make a change.

<Details>
<Summary>Code example :</Summary>

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [
    react({
      // Enable React Fast Refresh
      fastRefresh: true
    })
  ],

  // Development server settings
  server: {
    port: 3000,
    open: true, // Auto-open browser
    host: true, // Listen on all addresses
    hmr: {
      overlay: true // Show errors in overlay
    }
  },

  // Build settings
  build: {
    outDir: 'dist',
    sourcemap: true,
    // Asset optimization
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom']
        }
      }
    }
  },

  // Path aliases for cleaner imports
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@components': path.resolve(__dirname, 'src/components'),
      '@utils': path.resolve(__dirname, 'src/utils'),
      '@assets': path.resolve(__dirname, 'src/assets')
    }
  },

  // Environment variables
  define: {
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version)
  },

  // CSS configuration
  css: {
    modules: {
      localsConvention: 'camelCaseOnly'
    },
    preprocessorOptions: {
      scss: {
        additionalData: '@import "@/styles/variables.scss";'
      }
    }
  }
})

// Advanced configuration for different environments
import { defineConfig, loadEnv } from 'vite'

export default defineConfig(({ command, mode }) => {
  // Load environment variables
  const env = loadEnv(mode, process.cwd(), '')

  return {
    plugins: [react()],

    // Different configs for dev/build
    ...(command === 'serve'
      ? {
          // Development config
          server: {
            port: 3000,
            proxy: {
              '/api': {
                target: env.VITE_API_URL || 'http://localhost:5000',
                changeOrigin: true,
                rewrite: (path) => path.replace(/^\/api/, '')
              }
            }
          }
        }
      : {
          // Production build config
          build: {
            minify: 'terser',
            terserOptions: {
              compress: {
                drop_console: true,
                drop_debugger: true
              }
            }
          }
        }
    )
  }
})

// Package.json scripts for Vite
{
  "name": "my-vite-app",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "build:analyze": "vite build --mode analyze"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^4.3.0"
  }
}

// Using environment variables in Vite
// .env.development
VITE_API_URL=http://localhost:5000
VITE_APP_TITLE=My Dev App

// .env.production
VITE_API_URL=https://api.myapp.com
VITE_APP_TITLE=My Production App

// Access in React components
function App() {
  const apiUrl = import.meta.env.VITE_API_URL;
  const appTitle = import.meta.env.VITE_APP_TITLE;

  return <div>{appTitle}</div>;
}

// Vite plugins for enhanced development
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react(),
    // Auto-import React hooks
    {
      name: 'auto-import-react',
      transform(code, id) {
        if (id.endsWith('.jsx') || id.endsWith('.tsx')) {
          if (code.includes('useState') || code.includes('useEffect')) {
            return `import { useState, useEffect } from 'react';\n${code}`;
          }
        }
      }
    }
  ]
})
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Parcel

Parcel is like having a magic assistant that requires zero setup - just point it at your files and it figures out everything else automatically!

**Key Points:**

- Zero configuration bundler that works out of the box
- Automatic detection of dependencies and file types
- Built-in development server with hot reloading
- Supports all modern web technologies without setup

**Real-life example:** Like having a super-smart robot butler that automatically organizes your room perfectly without you having to give it any instructions.

<Details>
<Summary>Code example :</Summary>

```bash
# Installing Parcel (super simple!)
npm install -g parcel-bundler

# Or with npm (recommended for projects)
npm install --save-dev parcel-bundler

# Create your React app structure
mkdir my-parcel-app
cd my-parcel-app
npm init -y
```

```html
<!-- index.html - Entry point -->
<!DOCTYPE html>
<html>
<head>
  <title>My Parcel React App</title>
</head>
<body>
  <div id="root"></div>
  <!-- Parcel automatically processes this -->
  <script src="./src/index.js"></script>
</body>
</html>
```

```javascript
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './styles.css'; // Parcel handles CSS automatically

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

// src/App.js
import React, { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);

  return (
    <div className="app">
      <h1>Parcel React App</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

export default App;
```

```css
/* src/styles.css - Parcel processes automatically */
.app {
  text-align: center;
  padding: 2rem;
  font-family: Arial, sans-serif;
}

button {
  background: #007acc;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #005a9e;
}
```

```json
// package.json - Simple scripts
{
  "name": "my-parcel-app",
  "version": "1.0.0",
  "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html",
    "dev": "parcel index.html --open",
    "clean": "rm -rf dist .cache"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "parcel-bundler": "^1.12.5"
  }
}
```

```bash
# Running Parcel commands (super easy!)

# Start development server
npm start
# or
parcel index.html

# Build for production
npm run build
# or
parcel build index.html

# Development with auto-open browser
parcel index.html --open

# Specify custom port
parcel index.html --port 8080

# Enable HTTPS for development
parcel index.html --https

# No configuration needed! Parcel automatically:
# ✅ Transforms JSX to JavaScript
# ✅ Bundles CSS and imports
# ✅ Optimizes images
# ✅ Handles different file types
# ✅ Provides hot module replacement
# ✅ Code splitting
# ✅ Tree shaking in production
```

```javascript
// Advanced Parcel features (still zero config!)

// Automatic code splitting with dynamic imports
import React, { lazy, Suspense } from 'react';

// Parcel automatically creates separate bundles
const Dashboard = lazy(() => import('./Dashboard'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dashboard />
      <Profile />
    </Suspense>
  );
}

// Environment variables (create .env file)
// .env
REACT_APP_API_URL=http://localhost:5000
REACT_APP_VERSION=1.0.0

// Access in components
function App() {
  const apiUrl = process.env.REACT_APP_API_URL;
  return <div>API: {apiUrl}</div>;
}

// Different file types Parcel handles automatically:
import image from './hero.jpg';        // Images
import styles from './styles.module.css'; // CSS Modules
import data from './data.json';        // JSON files
import './global.scss';                // SASS/SCSS
import { Component } from './utils.ts'; // TypeScript

// Web Workers (Parcel handles automatically)
import Worker from 'worker-loader!./worker.js';

const worker = new Worker();
worker.postMessage('Hello from main thread!');
```

```javascript
// .parcelrc (optional configuration file)
{
  "extends": ["@parcel/config-default"],
  "transformers": {
    "*.{js,mjs,jsm,jsx,es6,cjs,ts,tsx}": [
      "@parcel/transformer-js",
      "@parcel/transformer-react-refresh-wrap"
    ]
  },
  "bundler": "@parcel/bundler-default",
  "runtimes": ["@parcel/runtime-js", "@parcel/runtime-browser-hmr"]
}

// Custom Parcel plugins (if needed)
// parcel-plugin-custom-dist-structure
{
  "scripts": {
    "build": "parcel build index.html --public-url ./ --dist-dir build"
  }
}

// Parcel vs other bundlers comparison:
//
// ✅ Parcel Pros:
// - Zero configuration
// - Fast out-of-the-box
// - Handles everything automatically
// - Great for prototyping
// - Built-in dev server
//
// ❌ Parcel Cons:
// - Less flexibility than Webpack
// - Smaller ecosystem
// - Limited custom configuration options
// - Can be slower for very large projects
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### What is AI and GenAI

AI and GenAI are like having super-smart digital assistants that can think, create, and help you build amazing things - it's like having a genius friend who never gets tired and can help you code, design, and solve problems!

**Key Points:**

- AI (Artificial Intelligence) makes computers think and learn like humans
- GenAI (Generative AI) creates new content: text, images, code, music
- Large Language Models (LLMs) like GPT, Claude understand and generate human-like text
- AI is revolutionizing how we build and interact with web applications

**Real-life example:** Like having a super-smart robot that can not only answer questions but also write stories, draw pictures, compose music, and even help you write code!

<Details>
<Summary>Code example :</Summary>

```javascript
// Understanding AI concepts in React development

// 1. TRADITIONAL PROGRAMMING vs AI-ASSISTED
// Traditional way - you write every line
function validateEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}

// AI-assisted way - you describe what you want
// Prompt: "Create a React hook for email validation with real-time feedback"
import { useState, useEffect } from 'react';

function useEmailValidation(email) {
  const [isValid, setIsValid] = useState(false);
  const [error, setError] = useState('');

  useEffect(() => {
    if (!email) {
      setError('');
      setIsValid(false);
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const valid = emailRegex.test(email);

    setIsValid(valid);
    setError(valid ? '' : 'Please enter a valid email address');
  }, [email]);

  return { isValid, error };
}

// 2. AI APIS you can integrate in React apps
// OpenAI GPT API
const generateText = async (prompt) => {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.REACT_APP_OPENAI_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 150
    })
  });

  const data = await response.json();
  return data.choices[0].message.content;
};

// 3. AI-POWERED REACT COMPONENT
function AITextGenerator() {
  const [prompt, setPrompt] = useState('');
  const [generatedText, setGeneratedText] = useState('');
  const [loading, setLoading] = useState(false);

  const handleGenerate = async () => {
    setLoading(true);
    try {
      const text = await generateText(prompt);
      setGeneratedText(text);
    } catch (error) {
      console.error('AI generation failed:', error);
    }
    setLoading(false);
  };

  return (
    <div className="ai-generator">
      <h2>AI Text Generator</h2>
      <textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="Enter your prompt here..."
        rows={4}
        cols={50}
      />
      <button onClick={handleGenerate} disabled={loading}>
        {loading ? 'Generating...' : 'Generate Text'}
      </button>
      {generatedText && (
        <div className="generated-content">
          <h3>Generated Text:</h3>
          <p>{generatedText}</p>
        </div>
      )}
    </div>
  );
}

// 4. TYPES OF AI you'll work with as a React developer
const AITypes = {
  // Natural Language Processing
  textGeneration: 'GPT-4, Claude, Gemini',
  textAnalysis: 'Sentiment analysis, keyword extraction',

  // Computer Vision
  imageGeneration: 'DALL-E, Midjourney, Stable Diffusion',
  imageAnalysis: 'Object detection, face recognition',

  // Speech
  speechToText: 'Whisper, Google Speech API',
  textToSpeech: 'ElevenLabs, Azure Speech',

  // Code Generation
  codeAssistants: 'GitHub Copilot, Tabnine, Codeium',
  codeReview: 'DeepCode, SonarQube AI'
};
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### GenAI in Frontend

GenAI in frontend is like having a creative partner that can instantly generate designs, write code, create content, and enhance user experiences - making your React apps smarter and more interactive!

**Key Points:**

- Integrates AI capabilities directly into your React applications
- Enhances user experience with intelligent features
- Automates content creation, code generation, and design
- Enables real-time AI interactions in web browsers

**Real-life example:** Like having a magic wand that can instantly create personalized content, generate beautiful designs, write helpful text, and make your website respond intelligently to each user!

<Details>
<Summary>Code example :</Summary>

```javascript
// Real GenAI implementations in React frontend

// 1. AI-POWERED CONTENT GENERATION
import { useState } from 'react';

function BlogPostGenerator() {
  const [topic, setTopic] = useState('');
  const [tone, setTone] = useState('professional');
  const [generatedPost, setGeneratedPost] = useState('');
  const [loading, setLoading] = useState(false);

  const generateBlogPost = async () => {
    setLoading(true);

    const prompt = `Write a ${tone} blog post about ${topic}. Make it engaging and informative.`;

    try {
      const response = await fetch('/api/generate-content', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt, maxTokens: 500 })
      });

      const data = await response.json();
      setGeneratedPost(data.content);
    } catch (error) {
      console.error('Generation failed:', error);
    }

    setLoading(false);
  };

  return (
    <div className="blog-generator">
      <h2>AI Blog Post Generator</h2>

      <div className="input-group">
        <input
          type="text"
          value={topic}
          onChange={(e) => setTopic(e.target.value)}
          placeholder="Enter blog topic..."
        />

        <select value={tone} onChange={(e) => setTone(e.target.value)}>
          <option value="professional">Professional</option>
          <option value="casual">Casual</option>
          <option value="humorous">Humorous</option>
          <option value="technical">Technical</option>
        </select>

        <button onClick={generateBlogPost} disabled={loading || !topic}>
          {loading ? 'Generating...' : 'Generate Post'}
        </button>
      </div>

      {generatedPost && (
        <div className="generated-content">
          <h3>Generated Blog Post:</h3>
          <div dangerouslySetInnerHTML={{ __html: generatedPost }} />
        </div>
      )}
    </div>
  );
}

// 2. INTELLIGENT SEARCH WITH AI
function SmartSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [suggestions, setSuggestions] = useState([]);

  const performSmartSearch = async (searchQuery) => {
    // AI-enhanced search that understands context and intent
    const response = await fetch('/api/smart-search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: searchQuery,
        includeSemanticSearch: true,
        generateSuggestions: true
      })
    });

    const data = await response.json();
    setResults(data.results);
    setSuggestions(data.suggestions);
  };

  return (
    <div className="smart-search">
      <input
        type="text"
        value={query}
        onChange={(e) => {
          setQuery(e.target.value);
          if (e.target.value.length > 2) {
            performSmartSearch(e.target.value);
          }
        }}
        placeholder="Ask me anything..."
      />

      {suggestions.length > 0 && (
        <div className="suggestions">
          <h4>Did you mean:</h4>
          {suggestions.map((suggestion, index) => (
            <button key={index} onClick={() => setQuery(suggestion)}>
              {suggestion}
            </button>
          ))}
        </div>
      )}

      <div className="results">
        {results.map((result, index) => (
          <div key={index} className="result-item">
            <h3>{result.title}</h3>
            <p>{result.summary}</p>
            <span className="confidence">Confidence: {result.confidence}%</span>
          </div>
        ))}
      </div>
    </div>
  );
}

// 3. AI-POWERED FORM ASSISTANT
function IntelligentForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  const [aiSuggestions, setAiSuggestions] = useState({});
  const [autoComplete, setAutoComplete] = useState(true);

  const getAISuggestions = async (field, value) => {
    if (!autoComplete || value.length < 3) return;

    const response = await fetch('/api/form-suggestions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ field, value, context: formData })
    });

    const suggestions = await response.json();
    setAiSuggestions(prev => ({ ...prev, [field]: suggestions }));
  };

  const improveText = async (field) => {
    const response = await fetch('/api/improve-text', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: formData[field],
        improvement: 'grammar_and_clarity'
      })
    });

    const improved = await response.json();
    setFormData(prev => ({ ...prev, [field]: improved.text }));
  };

  return (
    <form className="intelligent-form">
      <h2>AI-Assisted Contact Form</h2>

      <div className="field-group">
        <input
          type="text"
          value={formData.name}
          onChange={(e) => {
            setFormData(prev => ({ ...prev, name: e.target.value }));
            getAISuggestions('name', e.target.value);
          }}
          placeholder="Your name"
        />
        {aiSuggestions.name && (
          <div className="suggestions">
            {aiSuggestions.name.map((suggestion, index) => (
              <button key={index} type="button"
                onClick={() => setFormData(prev => ({ ...prev, name: suggestion }))}>
                {suggestion}
              </button>
            ))}
          </div>
        )}
      </div>

      <div className="field-group">
        <textarea
          value={formData.message}
          onChange={(e) => setFormData(prev => ({ ...prev, message: e.target.value }))}
          placeholder="Your message"
          rows={4}
        />
        <button type="button" onClick={() => improveText('message')}>
          ✨ Improve with AI
        </button>
      </div>

      <button type="submit">Send Message</button>
    </form>
  );
}

// 4. REAL-TIME AI FEATURES
function AIEnhancedTextEditor() {
  const [content, setContent] = useState('');
  const [aiFeatures, setAiFeatures] = useState({
    grammar: true,
    tone: true,
    suggestions: true
  });

  const analyzeContent = async (text) => {
    const response = await fetch('/api/analyze-text', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text, features: aiFeatures })
    });

    return await response.json();
  };

  return (
    <div className="ai-text-editor">
      <div className="toolbar">
        <button onClick={() => analyzeContent(content)}>
          🔍 AI Analysis
        </button>
        <button onClick={() => /* paraphrase */}>
          🔄 Paraphrase
        </button>
        <button onClick={() => /* translate */}>
          🌐 Translate
        </button>
      </div>

      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Start writing and let AI help you..."
        className="ai-enhanced-textarea"
      />
    </div>
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Text to Image Generation App

Building a text-to-image app is like creating a magic art studio where users can describe any picture in words and watch it come to life instantly!

**Key Points:**

- Integrates AI image generation APIs (DALL-E, Midjourney, Stable Diffusion)
- Handles user prompts and generates unique images
- Manages image loading states and error handling
- Provides image customization options (style, size, quality)

**Real-life example:** Like having a magical artist friend who can instantly paint any picture you describe - "Draw a sunset over mountains with purple clouds" and boom, there's your custom artwork!

<Details>
<Summary>Code example :</Summary>

```javascript
// Complete Text-to-Image React App

import React, { useState, useRef } from 'react';
import './ImageGenerator.css';

function TextToImageGenerator() {
  const [prompt, setPrompt] = useState('');
  const [generatedImages, setGeneratedImages] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [settings, setSettings] = useState({
    style: 'realistic',
    size: '512x512',
    quality: 'standard',
    count: 1
  });

  // Generate images using AI API
  const generateImages = async () => {
    if (!prompt.trim()) {
      setError('Please enter a description for your image');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/generate-image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.REACT_APP_OPENAI_KEY}`
        },
        body: JSON.stringify({
          prompt: `${prompt}, ${settings.style} style`,
          size: settings.size,
          quality: settings.quality,
          n: parseInt(settings.count)
        })
      });

      if (!response.ok) {
        throw new Error('Failed to generate image');
      }

      const data = await response.json();
      setGeneratedImages(data.images);

    } catch (err) {
      setError(err.message || 'Something went wrong');
    } finally {
      setLoading(false);
    }
  };

  // Download generated image
  const downloadImage = async (imageUrl, filename) => {
    try {
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);

      const link = document.createElement('a');
      link.href = url;
      link.download = filename || 'ai-generated-image.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Download failed:', err);
    }
  };

  // Save to favorites (localStorage)
  const saveToFavorites = (image) => {
    const favorites = JSON.parse(localStorage.getItem('ai-favorites') || '[]');
    const newFavorite = {
      id: Date.now(),
      url: image.url,
      prompt: prompt,
      timestamp: new Date().toISOString()
    };
    favorites.push(newFavorite);
    localStorage.setItem('ai-favorites', JSON.stringify(favorites));
    alert('Image saved to favorites!');
  };

  return (
    <div className="image-generator">
      <header className="generator-header">
        <h1>🎨 AI Image Generator</h1>
        <p>Describe any image and watch AI create it for you!</p>
      </header>

      {/* Input Section */}
      <div className="input-section">
        <div className="prompt-input">
          <textarea
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder="Describe your image... (e.g., 'A serene lake surrounded by mountains at sunset')"
            rows={3}
            maxLength={500}
          />
          <div className="char-count">{prompt.length}/500</div>
        </div>

        {/* Settings Panel */}
        <div className="settings-panel">
          <h3>Generation Settings</h3>

          <div className="setting-group">
            <label>Style:</label>
            <select
              value={settings.style}
              onChange={(e) => setSettings(prev => ({...prev, style: e.target.value}))}
            >
              <option value="realistic">Realistic</option>
              <option value="artistic">Artistic</option>
              <option value="cartoon">Cartoon</option>
              <option value="abstract">Abstract</option>
              <option value="vintage">Vintage</option>
            </select>
          </div>

          <div className="setting-group">
            <label>Size:</label>
            <select
              value={settings.size}
              onChange={(e) => setSettings(prev => ({...prev, size: e.target.value}))}
            >
              <option value="256x256">Small (256x256)</option>
              <option value="512x512">Medium (512x512)</option>
              <option value="1024x1024">Large (1024x1024)</option>
            </select>
          </div>

          <div className="setting-group">
            <label>Count:</label>
            <select
              value={settings.count}
              onChange={(e) => setSettings(prev => ({...prev, count: e.target.value}))}
            >
              <option value="1">1 image</option>
              <option value="2">2 images</option>
              <option value="4">4 images</option>
            </select>
          </div>
        </div>

        <button
          className="generate-btn"
          onClick={generateImages}
          disabled={loading || !prompt.trim()}
        >
          {loading ? (
            <>
              <span className="loading-spinner"></span>
              Generating...
            </>
          ) : (
            '✨ Generate Images'
          )}
        </button>
      </div>

      {/* Error Display */}
      {error && (
        <div className="error-message">
          <span className="error-icon">⚠️</span>
          {error}
        </div>
      )}

      {/* Results Section */}
      {generatedImages.length > 0 && (
        <div className="results-section">
          <h2>Generated Images</h2>
          <div className="image-grid">
            {generatedImages.map((image, index) => (
              <div key={index} className="image-card">
                <img
                  src={image.url}
                  alt={`Generated: ${prompt}`}
                  loading="lazy"
                />
                <div className="image-actions">
                  <button
                    onClick={() => downloadImage(image.url, `ai-image-${index + 1}.png`)}
                    className="action-btn download-btn"
                  >
                    📥 Download
                  </button>
                  <button
                    onClick={() => saveToFavorites(image)}
                    className="action-btn favorite-btn"
                  >
                    ❤️ Save
                  </button>
                  <button
                    onClick={() => navigator.share({
                      title: 'AI Generated Image',
                      text: prompt,
                      url: image.url
                    })}
                    className="action-btn share-btn"
                  >
                    🔗 Share
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Prompt Suggestions */}
      <div className="suggestions-section">
        <h3>Need inspiration? Try these prompts:</h3>
        <div className="prompt-suggestions">
          {[
            "A cozy coffee shop on a rainy day with warm lighting",
            "Futuristic city skyline with flying cars at night",
            "A magical forest with glowing mushrooms and fireflies",
            "Vintage bookstore with cats sleeping among old books",
            "Abstract geometric patterns in vibrant colors"
          ].map((suggestion, index) => (
            <button
              key={index}
              className="suggestion-chip"
              onClick={() => setPrompt(suggestion)}
            >
              {suggestion}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}

// API route handler (if using Next.js)
// pages/api/generate-image.js
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { prompt, size, quality, n } = req.body;

  try {
    const response = await fetch('https://api.openai.com/v1/images/generations', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        prompt,
        size,
        quality: quality || 'standard',
        n: n || 1
      })
    });

    if (!response.ok) {
      throw new Error('Failed to generate image');
    }

    const data = await response.json();
    res.status(200).json({ images: data.data });

  } catch (error) {
    console.error('Image generation error:', error);
    res.status(500).json({ error: 'Failed to generate image' });
  }
}

// Favorites Manager Component
function FavoritesManager() {
  const [favorites, setFavorites] = useState([]);

  useEffect(() => {
    const savedFavorites = JSON.parse(localStorage.getItem('ai-favorites') || '[]');
    setFavorites(savedFavorites);
  }, []);

  const removeFavorite = (id) => {
    const updated = favorites.filter(fav => fav.id !== id);
    setFavorites(updated);
    localStorage.setItem('ai-favorites', JSON.stringify(updated));
  };

  return (
    <div className="favorites-manager">
      <h2>Your Favorite AI Images</h2>
      <div className="favorites-grid">
        {favorites.map(favorite => (
          <div key={favorite.id} className="favorite-item">
            <img src={favorite.url} alt={favorite.prompt} />
            <p>{favorite.prompt}</p>
            <button onClick={() => removeFavorite(favorite.id)}>
              Remove
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}

export default TextToImageGenerator;
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### AI Powered Chatbot App

Building an AI chatbot is like creating a smart virtual friend that can have conversations, answer questions, and help users with anything they need - all through natural language!

**Key Points:**

- Integrates conversational AI APIs (GPT, Claude, Gemini)
- Maintains conversation context and memory
- Handles real-time messaging with proper UI/UX
- Supports different chat modes (assistant, creative, technical)

**Real-life example:** Like having a super-intelligent friend available 24/7 who remembers your conversations, understands context, and can help you with everything from homework to creative projects!

<Details>
<Summary>Code example :</Summary>

```javascript
// Complete AI Chatbot React App

import React, { useState, useRef, useEffect } from 'react';
import './Chatbot.css';

function AIChatbot() {
  const [messages, setMessages] = useState([
    {
      id: 1,
      type: 'ai',
      content: "Hi! I'm your AI assistant. How can I help you today?",
      timestamp: new Date()
    }
  ]);
  const [inputMessage, setInputMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [chatMode, setChatMode] = useState('assistant');
  const [conversationId, setConversationId] = useState(null);
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);

  // Scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, isTyping]);

  // Focus input on load
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  // Send message to AI
  const sendMessage = async () => {
    if (!inputMessage.trim()) return;

    const userMessage = {
      id: Date.now(),
      type: 'user',
      content: inputMessage.trim(),
      timestamp: new Date()
    };

    // Add user message to chat
    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setIsTyping(true);

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: userMessage.content,
          conversationId,
          mode: chatMode,
          context: messages.slice(-5) // Send last 5 messages for context
        })
      });

      if (!response.ok) {
        throw new Error('Failed to get AI response');
      }

      const data = await response.json();

      const aiMessage = {
        id: Date.now() + 1,
        type: 'ai',
        content: data.response,
        timestamp: new Date()
      };

      setMessages(prev => [...prev, aiMessage]);
      setConversationId(data.conversationId);

    } catch (error) {
      const errorMessage = {
        id: Date.now() + 1,
        type: 'error',
        content: 'Sorry, I encountered an error. Please try again.',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };

  // Handle Enter key press
  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  // Clear conversation
  const clearChat = () => {
    setMessages([
      {
        id: 1,
        type: 'ai',
        content: "Hi! I'm your AI assistant. How can I help you today?",
        timestamp: new Date()
      }
    ]);
    setConversationId(null);
  };

  // Quick action buttons
  const quickActions = [
    { text: "Explain a concept", prompt: "Can you explain" },
    { text: "Write code", prompt: "Help me write code for" },
    { text: "Creative writing", prompt: "Help me write a creative" },
    { text: "Solve problem", prompt: "Help me solve this problem:" }
  ];

  return (
    <div className="chatbot-container">
      {/* Header */}
      <div className="chat-header">
        <div className="header-left">
          <div className="ai-avatar">🤖</div>
          <div className="header-info">
            <h2>AI Assistant</h2>
            <div className="status-indicator">
              <span className="status-dot online"></span>
              Online
            </div>
          </div>
        </div>

        <div className="header-controls">
          {/* Chat Mode Selector */}
          <select
            value={chatMode}
            onChange={(e) => setChatMode(e.target.value)}
            className="mode-selector"
          >
            <option value="assistant">💼 Assistant</option>
            <option value="creative">🎨 Creative</option>
            <option value="technical">⚙️ Technical</option>
            <option value="casual">💬 Casual</option>
          </select>

          <button onClick={clearChat} className="clear-btn">
            🗑️ Clear
          </button>
        </div>
      </div>

      {/* Messages Container */}
      <div className="messages-container">
        {messages.map((message) => (
          <div key={message.id} className={`message ${message.type}`}>
            <div className="message-avatar">
              {message.type === 'user' ? '👤' : message.type === 'error' ? '⚠️' : '🤖'}
            </div>
            <div className="message-content">
              <div className="message-text">
                {message.content}
              </div>
              <div className="message-time">
                {message.timestamp.toLocaleTimeString([], {
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </div>
            </div>
          </div>
        ))}

        {/* Typing Indicator */}
        {isTyping && (
          <div className="message ai typing">
            <div className="message-avatar">🤖</div>
            <div className="message-content">
              <div className="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Quick Actions */}
      <div className="quick-actions">
        {quickActions.map((action, index) => (
          <button
            key={index}
            className="quick-action-btn"
            onClick={() => setInputMessage(action.prompt + " ")}
          >
            {action.text}
          </button>
        ))}
      </div>

      {/* Input Area */}
      <div className="input-container">
        <div className="input-wrapper">
          <textarea
            ref={inputRef}
            value={inputMessage}
            onChange={(e) => setInputMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Type your message... (Enter to send, Shift+Enter for new line)"
            rows={1}
            className="message-input"
            maxLength={2000}
          />
          <button
            onClick={sendMessage}
            disabled={!inputMessage.trim() || isTyping}
            className="send-button"
          >
            {isTyping ? '⏳' : '🚀'}
          </button>
        </div>
        <div className="input-footer">
          <span className="char-count">{inputMessage.length}/2000</span>
          <span className="powered-by">Powered by AI ✨</span>
        </div>
      </div>
    </div>
  );
}

// API route handler (Next.js example)
// pages/api/chat.js
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { message, conversationId, mode, context } = req.body;

  // Customize AI behavior based on mode
  const systemPrompts = {
    assistant: "You are a helpful AI assistant. Provide clear, concise, and accurate responses.",
    creative: "You are a creative AI that helps with writing, brainstorming, and artistic projects. Be imaginative and inspiring.",
    technical: "You are a technical AI expert. Provide detailed, accurate technical information with code examples when relevant.",
    casual: "You are a friendly AI companion. Be conversational, casual, and engaging while still being helpful."
  };

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompts[mode] },
          ...context.map(msg => ({
            role: msg.type === 'user' ? 'user' : 'assistant',
            content: msg.content
          })),
          { role: 'user', content: message }
        ],
        max_tokens: 500,
        temperature: mode === 'creative' ? 0.8 : 0.3
      })
    });

    if (!response.ok) {
      throw new Error('Failed to get AI response');
    }

    const data = await response.json();

    res.status(200).json({
      response: data.choices[0].message.content,
      conversationId: conversationId || Date.now().toString()
    });

  } catch (error) {
    console.error('Chat API error:', error);
    res.status(500).json({ error: 'Failed to process chat message' });
  }
}

// Advanced Features Components

// Chat History Sidebar
function ChatHistory({ onLoadChat }) {
  const [chatHistory, setChatHistory] = useState([]);

  useEffect(() => {
    const history = JSON.parse(localStorage.getItem('chat-history') || '[]');
    setChatHistory(history);
  }, []);

  return (
    <div className="chat-history">
      <h3>Recent Chats</h3>
      {chatHistory.map(chat => (
        <div key={chat.id} className="history-item" onClick={() => onLoadChat(chat)}>
          <div className="chat-preview">{chat.title}</div>
          <div className="chat-date">{chat.date}</div>
        </div>
      ))}
    </div>
  );
}

// Voice Input Component
function VoiceInput({ onTranscript }) {
  const [isListening, setIsListening] = useState(false);

  const startListening = () => {
    if ('webkitSpeechRecognition' in window) {
      const recognition = new window.webkitSpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => setIsListening(true);
      recognition.onend = () => setIsListening(false);

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        onTranscript(transcript);
      };

      recognition.start();
    }
  };

  return (
    <button
      onClick={startListening}
      className={`voice-btn ${isListening ? 'listening' : ''}`}
    >
      {isListening ? '🎤' : '🎙️'}
    </button>
  );
}

export default AIChatbot;
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Leveraging AI as a Software Engineer

Using AI as a software engineer is like having a super-powered coding buddy who can help you write better code faster, debug problems, learn new concepts, and boost your productivity to superhuman levels!

**Key Points:**

- AI coding assistants help write, debug, and optimize code
- Use AI for learning new technologies and concepts quickly
- Automate repetitive tasks and generate boilerplate code
- Enhance code reviews, documentation, and testing

**Real-life example:** Like having a genius mentor sitting next to you who can instantly help with any coding problem, explain complex concepts, write code snippets, and make you 10x more productive!

<Details>
<Summary>Code example :</Summary>

```javascript
// Ways to leverage AI in your React development workflow

// 1. AI-ASSISTED CODE GENERATION
// Instead of writing repetitive code, describe what you want:

// Prompt: "Create a React hook for managing form state with validation"
// AI generates:
import { useState, useCallback } from 'react';

function useFormValidation(initialState, validationRules) {
  const [values, setValues] = useState(initialState);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const validate = useCallback((fieldName, value) => {
    const rule = validationRules[fieldName];
    if (!rule) return '';

    if (rule.required && !value) {
      return rule.message || `${fieldName} is required`;
    }

    if (rule.pattern && !rule.pattern.test(value)) {
      return rule.message || `${fieldName} is invalid`;
    }

    if (rule.minLength && value.length < rule.minLength) {
      return `${fieldName} must be at least ${rule.minLength} characters`;
    }

    return '';
  }, [validationRules]);

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));

    const error = validate(name, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  }, [validate]);

  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
  }, []);

  const isValid = Object.values(errors).every(error => !error);

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    isValid
  };
}

// 2. AI-POWERED CODE REVIEW AND OPTIMIZATION
// Prompt: "Review and optimize this React component"

// Original code:
function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);

  return (
    <div>
      {users.map(user => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
}

// AI-optimized version:
import { useState, useEffect, useMemo } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;

    const fetchUsers = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/users');

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (!cancelled) {
          setUsers(data);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchUsers();

    return () => {
      cancelled = true;
    };
  }, []);

  const userElements = useMemo(() =>
    users.map(user => (
      <div key={user.id} className="user-card">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
    )), [users]
  );

  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;
  if (users.length === 0) return <div>No users found</div>;

  return <div className="user-list">{userElements}</div>;
}

// 3. AI-GENERATED DOCUMENTATION
// Prompt: "Generate comprehensive documentation for this React hook"

/**
 * Custom React hook for managing API requests with loading, error, and success states
 *
 * @param {string} url - The API endpoint URL to fetch data from
 * @param {Object} options - Configuration options for the request
 * @param {Object} options.method - HTTP method (GET, POST, PUT, DELETE)
 * @param {Object} options.headers - Additional headers to include
 * @param {Object} options.body - Request body for POST/PUT requests
 * @param {boolean} options.immediate - Whether to make the request immediately (default: true)
 *
 * @returns {Object} Object containing:
 *   - data: The fetched data (null if not loaded)
 *   - loading: Boolean indicating if request is in progress
 *   - error: Error object if request failed (null if no error)
 *   - refetch: Function to manually trigger the request again
 *
 * @example
 * ```javascript
 * function UserProfile({ userId }) {
 *   const { data: user, loading, error, refetch } = useApi(`/api/users/${userId}`);
 *
 *   if (loading) return <div>Loading...</div>;
 *   if (error) return <div>Error: {error.message}</div>;
 *
 *   return (
 *     <div>
 *       <h1>{user.name}</h1>
 *       <button onClick={refetch}>Refresh</button>
 *     </div>
 *   );
 * }
 * ```
 */
function useApi(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(url, {
        method: options.method || 'GET',
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...(options.body && { body: JSON.stringify(options.body) })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [url, options]);

  useEffect(() => {
    if (options.immediate !== false) {
      fetchData();
    }
  }, [fetchData, options.immediate]);

  return { data, loading, error, refetch: fetchData };
}

// 4. AI-POWERED DEBUGGING ASSISTANT
// When you encounter an error, ask AI to help debug:

// Error: "Cannot read property 'map' of undefined"
// AI Analysis and Solution:

function ProductList() {
  const [products, setProducts] = useState([]); // ✅ Initialize as empty array
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchProducts()
      .then(data => {
        // ✅ Add safety check for API response
        setProducts(Array.isArray(data) ? data : []);
      })
      .catch(error => {
        console.error('Failed to fetch products:', error);
        setProducts([]); // ✅ Set fallback empty array
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  // ✅ Add loading and safety checks
  if (loading) return <div>Loading products...</div>;

  return (
    <div>
      {products && products.length > 0 ? (
        products.map(product => (
          <div key={product.id}>{product.name}</div>
        ))
      ) : (
        <div>No products available</div>
      )}
    </div>
  );
}

// 5. AI-GENERATED TESTS
// Prompt: "Generate comprehensive tests for this React component"

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import UserProfile from './UserProfile';

// Mock the API
jest.mock('../api/users', () => ({
  fetchUser: jest.fn()
}));

describe('UserProfile Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('displays loading state initially', () => {
    render(<UserProfile userId="123" />);
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  test('displays user data when loaded successfully', async () => {
    const mockUser = {
      id: '123',
      name: 'John Doe',
      email: 'john@example.com'
    };

    require('../api/users').fetchUser.mockResolvedValue(mockUser);

    render(<UserProfile userId="123" />);

    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });
  });

  test('displays error message when fetch fails', async () => {
    require('../api/users').fetchUser.mockRejectedValue(
      new Error('Failed to fetch user')
    );

    render(<UserProfile userId="123" />);

    await waitFor(() => {
      expect(screen.getByText(/Error.*Failed to fetch user/)).toBeInTheDocument();
    });
  });

  test('refetches data when refresh button is clicked', async () => {
    const mockUser = { id: '123', name: 'John Doe', email: 'john@example.com' };
    const fetchUser = require('../api/users').fetchUser;
    fetchUser.mockResolvedValue(mockUser);

    render(<UserProfile userId="123" />);

    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('Refresh'));

    expect(fetchUser).toHaveBeenCalledTimes(2);
  });
});

// 6. AI PRODUCTIVITY TIPS FOR REACT DEVELOPERS

// Use AI for:
const aiProductivityTips = {
  codeGeneration: {
    // Generate boilerplate components
    prompt: "Create a React component for a user profile card with props",
    // Generate custom hooks
    prompt2: "Create a useLocalStorage hook with TypeScript",
    // Generate utility functions
    prompt3: "Create a function to format dates for display"
  },

  debugging: {
    // Paste error and ask for explanation
    prompt: "Explain this React error and how to fix it: [paste error]",
    // Get debugging strategies
    prompt2: "How do I debug React re-rendering issues?"
  },

  optimization: {
    // Code review requests
    prompt: "Review this React component for performance issues",
    // Optimization suggestions
    prompt2: "How can I optimize this React app for better performance?"
  },

  learning: {
    // Concept explanations
    prompt: "Explain React useEffect cleanup functions with examples",
    // Best practices
    prompt2: "What are the best practices for React state management?"
  },

  testing: {
    // Generate test cases
    prompt: "Generate unit tests for this React component",
    // Testing strategies
    prompt2: "How do I test React components that use hooks?"
  }
};

// AI Tools for React Developers:
const aiTools = {
  codingAssistants: [
    'GitHub Copilot - AI pair programmer',
    'Tabnine - Code completion',
    'Codeium - Free coding assistant',
    'Replit Ghostwriter - Browser-based coding help'
  ],

  chatbots: [
    'ChatGPT - General programming help',
    'Claude - Code analysis and generation',
    'Bard - Google\'s AI assistant',
    'Phind - Developer-focused search and chat'
  ],

  specialized: [
    'Figma AI - Design to code conversion',
    'v0.dev - AI React component generator',
    'CodeWhisperer - Amazon\'s AI coding assistant',
    'Cursor - AI-powered code editor'
  ]
};

export { useFormValidation, useApi, aiProductivityTips, aiTools };
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### HTML and CSS Mastery

Mastering HTML & CSS for React is like knowing how to build a strong foundation before constructing a beautiful house - you need solid structural skills before adding React magic!

**Key Points:**

- Semantic HTML improves accessibility and SEO
- CSS Grid and Flexbox for modern layouts
- CSS-in-JS concepts for React styling
- Responsive design principles and mobile-first approach

**Real-life example:** Like being a master carpenter who knows every tool and technique before becoming an architect - you need to understand the basics perfectly before building complex React applications.

<Details>
<Summary>Code example :</Summary>

```css
/* Modern CSS techniques for React developers */
.card {
  display: grid;
  grid-template-areas:
    "header header"
    "content sidebar"
    "footer footer";
  gap: 1rem;
}

/* CSS Variables for theming */
:root {
  --primary-color: #007acc;
  --text-color: #333;
}

/* Mobile-first responsive design */
@media (min-width: 768px) {
  .container { max-width: 1200px; }
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Output-Based Interview Questions

Output-based questions are like detective puzzles - you need to trace through the code step by step to predict what will happen, testing your deep understanding of JavaScript and React behavior!

**Key Points:**

- Focus on understanding execution context and scope
- Know how React lifecycle and re-rendering works
- Understand closures, hoisting, and async behavior
- Practice with tricky scenarios and edge cases

**Real-life example:** Like being a detective who can look at a crime scene and perfectly reconstruct what happened step by step - you analyze code and predict exact outcomes.

<Details>
<Summary>Code example :</Summary>

```javascript
// Common output-based question patterns:

// 1. React State Updates
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
    console.log(count); // What logs? Answer: 0 (stale closure)
  };
}

// 2. JavaScript Closures
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // What logs? Answer: 3, 3, 3
}

// 3. React useEffect Dependencies
const [count, setCount] = useState(0);
useEffect(() => {
  console.log('Effect runs');
}, [count + 1]); // How many times does effect run?
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### LeetCode-Inspired Coding Challenges

LeetCode-style problems for frontend are like mental gymnastics - they train your algorithmic thinking to solve complex UI problems efficiently and elegantly!

**Key Points:**

- Array manipulation for rendering lists efficiently
- Tree traversal for component hierarchy problems
- Dynamic programming for optimization challenges
- String processing for search and filter features

**Real-life example:** Like training for a marathon by doing specific exercises - these challenges build your problem-solving muscles for real-world coding scenarios.

<Details>
<Summary>Code example :</Summary>

```javascript
// Frontend-focused algorithm problems:

// 1. Flatten nested component structure
function flattenComponents(components) {
  const result = [];
  const flatten = (items) => {
    items.forEach(item => {
      result.push(item);
      if (item.children) flatten(item.children);
    });
  };
  flatten(components);
  return result;
}

// 2. Debounce search function
function debounce(func, delay) {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  };
}

// 3. Virtual scrolling calculation
function getVisibleItems(items, containerHeight, itemHeight, scrollTop) {
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(containerHeight / itemHeight),
    items.length
  );
  return items.slice(startIndex, endIndex);
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Hands On Interview Prep JS and React

Hands-on interview prep is like practicing for a live cooking show - you need to build real things under pressure while explaining your thought process clearly!

**Key Points:**

- Build components from scratch without looking up documentation
- Explain your decision-making process while coding
- Handle edge cases and error scenarios gracefully
- Optimize for performance and user experience

**Real-life example:** Like a chef who can cook a perfect meal while teaching others - you need to code smoothly while articulating your reasoning and best practices.

<Details>
<Summary>Code example :</Summary>

```javascript
// Common hands-on interview challenges:

// 1. Build a custom hook from scratch
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// 2. Implement infinite scroll
function useInfiniteScroll(fetchMore) {
  useEffect(() => {
    const handleScroll = () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
        fetchMore();
      }
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [fetchMore]);
}

// 3. Create reusable modal component
function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;

  return createPortal(
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>,
    document.body
  );
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### System Design Interviews

System design interviews are like being an architect who must plan an entire smart city - you need to think about scalability, user experience, data flow, and how millions of people will interact with your system!

**Key Points:**

- Design scalable frontend architectures for large applications
- Plan component hierarchies and state management strategies
- Consider performance, caching, and optimization techniques
- Think about real-world constraints like network latency and mobile devices

**Real-life example:** Like designing a massive shopping mall - you need to plan traffic flow, emergency exits, store layouts, and how thousands of people will navigate efficiently.

<Details>
<Summary>Code example :</Summary>

```javascript
// System design concepts for frontend:

// 1. Micro-frontend architecture
const MicroFrontendLoader = {
  loadModule: async (name) => {
    const module = await import(`/microfrontends/${name}/index.js`);
    return module.default;
  }
};

// 2. State management architecture
const AppStateStructure = {
  user: { profile, preferences, permissions },
  ui: { modals, notifications, loading },
  data: { cache, entities, pagination },
  router: { currentRoute, history, params }
};

// 3. Performance optimization strategy
const OptimizationTechniques = {
  codesplitting: () => lazy(() => import('./HeavyComponent')),
  memoization: useMemo(() => expensiveCalculation, [deps]),
  virtualization: 'React Window for large lists',
  caching: 'React Query for server state'
};
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Modern React Ecosystem

The modern React ecosystem is like a bustling digital city with specialized districts - each tool and library serves a specific purpose, and knowing how they work together makes you a master developer!

**Key Points:**

- React 18+ features: Concurrent rendering, Suspense, Server Components
- Modern state management: Zustand, Jotai, Valtio over Redux
- Build tools evolution: Vite, Turbopack, ESBuild for faster development
- Full-stack frameworks: Next.js, Remix, Gatsby for different use cases

**Real-life example:** Like knowing all the best neighborhoods in a city - understanding when to use the financial district (Next.js), the arts quarter (Gatsby), or the tech hub (Vite) for different projects.

<Details>
<Summary>Code example :</Summary>

```javascript
// Modern React patterns and tools:

// 1. React 18 Concurrent Features
function App() {
  return (
    <Suspense fallback={<Loading />}>
      <ErrorBoundary>
        <Routes>
          <Route path="/" element={<HomePage />} />
        </Routes>
      </ErrorBoundary>
    </Suspense>
  );
}

// 2. Modern state management with Zustand
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}));

// 3. Server Components (Next.js 13+)
async function ServerComponent() {
  const data = await fetch('https://api.example.com/data');
  return <div>{data.title}</div>;
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### NextJS vs ReactJS

Comparing Next.js vs React is like comparing a fully-equipped smart home vs building materials - React gives you the foundation, while Next.js provides the complete infrastructure with electricity, plumbing, and smart features built-in!

**Key Points:**

- React is a library for UI components, Next.js is a full-stack framework
- Next.js adds SSR/SSG, routing, API routes, and optimization out of the box
- React requires additional setup for production features
- Next.js is opinionated, React is more flexible but needs more configuration

**Real-life example:** React is like buying individual car parts to build a custom vehicle, while Next.js is like buying a Tesla with all premium features included and ready to drive.

<Details>
<Summary>Code example :</Summary>

```javascript
// Key differences in implementation:

// 1. Routing
// React (with React Router)
<BrowserRouter>
  <Routes>
    <Route path="/about" element={<About />} />
  </Routes>
</BrowserRouter>

// Next.js (file-based routing)
// Just create: pages/about.js or app/about/page.js

// 2. Data Fetching
// React (client-side only)
useEffect(() => {
  fetch('/api/data').then(res => res.json()).then(setData);
}, []);

// Next.js (server-side + client-side)
export async function getServerSideProps() {
  const data = await fetch('http://localhost:3000/api/data');
  return { props: { data: await data.json() } };
}

// 3. API Routes
// React (needs separate backend)
// External Express server required

// Next.js (built-in API routes)
// api/users.js
export default function handler(req, res) {
  res.json({ users: [] });
}
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### NextJS vs NestJS

Comparing Next.js vs Nest.js is like comparing a modern apartment building vs a corporate office complex - both are powerful but serve completely different purposes in the development world!

**Key Points:**

- Next.js is a frontend React framework, Nest.js is a backend Node.js framework
- Next.js focuses on UI, routing, and web performance
- Nest.js focuses on APIs, databases, and server architecture
- They can work together: Next.js frontend + Nest.js backend

**Real-life example:** Next.js is like the beautiful storefront customers see, while Nest.js is like the efficient warehouse and management system running behind the scenes.

<Details>
<Summary>Code example :</Summary>

```javascript
// Next.js (Frontend Framework)
// pages/products/[id].js
export default function ProductPage({ product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}

export async function getServerSideProps({ params }) {
  const product = await fetch(`/api/products/${params.id}`);
  return { props: { product } };
}

// Nest.js (Backend Framework)
// products.controller.ts
@Controller('products')
export class ProductsController {
  constructor(private productsService: ProductsService) {}

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.productsService.findOne(+id);
  }

  @Post()
  async create(@Body() createProductDto: CreateProductDto) {
    return this.productsService.create(createProductDto);
  }
}

// They work together:
// Next.js frontend calls Nest.js API endpoints
// Nest.js provides data, Next.js renders UI
```

</Details>

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>
