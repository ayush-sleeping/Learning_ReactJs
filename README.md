# Learning_ReactJs
>
> "This repository contains my learning journey with ReactJS, including various projects and exercises. ..."

<br>

### Table of Contents

### Level 0: Basics & Prerequisites

| Topic | Subtopic |
|-------|----------|
| Vanilla JavaScript & API Calls | |
| DOM Manipulation | select, modify, create, delete elements |
| Event Handling & Debugging | Chrome DevTools |
| Fetch API | GET, POST requests |
| JavaScript ES6 | let/const |
| JavaScript ES6 | functions |
| JavaScript ES6 | operators |
| JavaScript ES6 | destructuring |
| JavaScript ES6 | template literals |
| Functional Programming | map |
| Functional Programming | reduce |
| Functional Programming | filter |
| Understanding jQuery | |
| JavaScript Fundamentals | Code Execution & Global Context |
| JavaScript Fundamentals | Event Loop, Call Stack & Concurrency |
| JavaScript Fundamentals | Hoisting |
| JavaScript Fundamentals | var/let/const |
| JavaScript Fundamentals | Arrow Functions & 'this' |
| JavaScript Fundamentals | Closures & Lexical Scope |
| JavaScript Fundamentals | Classes, Objects, Getters/Setters |
| JavaScript Fundamentals | Public/Private/Protected |
| JavaScript Fundamentals | Working with Objects |
| JavaScript Fundamentals | Optional Chaining |
| JavaScript Fundamentals | Nullish Coalescing |
| JavaScript Fundamentals | Logical OR |
| JavaScript Fundamentals | Destructuring (Object & Array) |
| JavaScript Fundamentals | Shallow & Deep Copy |
| JavaScript Fundamentals | filter |
| JavaScript Fundamentals | map |
| JavaScript Fundamentals | reduce |
| JavaScript Fundamentals | join |
| JavaScript Fundamentals | split |
| JavaScript Fundamentals | find |
| JavaScript Fundamentals | findIndex |
| JavaScript Fundamentals | splice |
| JavaScript Fundamentals | slice |
| JavaScript Fundamentals | Apply |
| JavaScript Fundamentals | Bind |
| JavaScript Fundamentals | Call |
| JavaScript Fundamentals | Prototype & Inheritance |
| JavaScript Fundamentals | Boolean Values |
| JavaScript Fundamentals | Spread & Rest Operator |
| JavaScript Fundamentals | Ternary Operator & Short-Circuiting |
| JavaScript Fundamentals | Set & Map |
| JavaScript Fundamentals | Event Delegation & Bubbling |
| JavaScript Fundamentals | Promises |
| JavaScript Fundamentals | Async/Await |
| JavaScript Fundamentals | Memoization |
| JavaScript Fundamentals | Debouncing |
| JavaScript Fundamentals | Throttling |
| JavaScript Fundamentals | ES6 Modules |
| JavaScript Fundamentals | export default vs named exports |

<br>

<br>

### Level 1: React Fundamentals (Basics to Intermediate)

| Topic | Subtopic |
|-------|----------|
| Getting Started with React | [Introduction to React and Declarative UI](#introduction-to-react-and-declarative-ui) |
| Getting Started with React | [Virtual DOM and Reconciliation](#virtual-dom-and-reconciliation) |
| Getting Started with React | [Setting Up Development Environment](#setting-up-development-environment) |
| Getting Started with React | [Creating Your First React App](#creating-your-first-react-app) |
| Getting Started with React | [React Project Structure](#react-project-structure) |
| Getting Started with React | [NPM vs NPX vs NVM](#npm-vs-npx-vs-nvm) |
| Getting Started with React | [Caret (^) and Tilde (~)](#Caret-^-and-Tilde-~) |
| Getting Started with React | [Writing Code from Scratch](#writing-code-from-scratch) |
| Getting Started with React | [Creating & Publishing NPM Packages](#Creating-&-Publishing-NPM-Packages) |
| React Core Concepts | [JSX HTML like Syntax in JS](#jsx-html-like-syntax-in-js) |
| React Core Concepts | [Babel How JSX Works](#babel-how-jsx-works) |
| React Core Concepts | [Naming Conventions CamelCase, PascalCase, Kebab-Case](#naming-conventions-camelcase-pascalcase-kebab-case) |
| React Core Concepts | [React Fragments](#react-fragments) |
| React Core Concepts | [JavaScript Expressions in JSX](#javascript-expressions-in-jsx) |
| React Core Concepts | [Dynamic Attributes in JSX](#dynamic-attributes-in-jsx) |
| React Core Concepts | [Handling Events in React](#handling-events-in-react) |
| React Core Concepts | [State in React](#state-in-react) |
| React Core Concepts | [Introduction to React Hooks](#introduction-to-react-hooks) |
| React Core Concepts | [useState for State Management](#usestate-for-state-management) |
| React Core Concepts | [Handling User Input in Forms](#handling-user-input-in-forms) |
| React Core Concepts | [Rendering Lists with map()](#rendering-lists-with-map) |
| React Core Concepts | [Mastering Props Passing Data](#Mastering-Props-Passing-Data) |
| React Core Concepts | [Web DevTools Deep Dive](#web-devtools-deep-dive) |
| Component Patterns & State | Building Reusable Components|
| Component Patterns & State | Rendering & Managing Task Cards |
| Component Patterns & State | Delete Functionality for Tasks |
| Component Patterns & State | Persisting Tasks in Local Storage |
| Component Patterns & State | React Strict Mode |
| Component Patterns & State | Tag Selection & Filtering UI |
| Component Patterns & State | Customizing Fonts & Styling (Tailwind, MaterialUI) |
| React Routing | Setting Up Routing |
| React Routing | Not Found Page |
| React Routing | SPA with React Router |
| React Routing | Route Parameters & Query Strings |
| React Routing | Nested Routing & Programmatic Navigation |
| API Integration | useEffect & Dependency Array |
| API Integration | Fetching Data (fetch, Axios) |
| API Integration | Loaders & Error Handling |
| API Integration | Promises vs Async/Await |
| API Integration | POST, PUT, DELETE with Axios |

<br>

<br>

### Level 2: Intermediate to Advanced

| Topic | Subtopic |
|-------|----------|
| Advanced React Concepts | React Design Patterns Container Presentational |
| Advanced React Concepts | HOC |
| Advanced React Concepts | Custom Hooks |
| Advanced React Concepts | Deep Dive into Hooks: useEffect |
| Advanced React Concepts | useRef |
| Advanced React Concepts | useImperativeHandle |
| Advanced React Concepts | useMemo |
| Advanced React Concepts | useCallback |
| Advanced React Concepts | useContext |
| Advanced React Concepts | useReducer |
| Advanced React Concepts | React 19 Hooks: useActionState |
| Advanced React Concepts | useFormStatus |
| Advanced React Concepts | useOptimistic |
| Advanced React Concepts | use() API |
| Advanced React Concepts | Passing Refs as Props |
| Advanced React Concepts | React as a Wrapper |
| Advanced React Concepts | Reconciliation & How React Works Under the Hood |
| Advanced React Concepts | Prop Drilling |
| Advanced React Concepts | Context API |
| Advanced React Concepts | Suspense API |
| Advanced React Concepts | State Management Tools (Redux, Context, etc.) |
| Advanced React Concepts | Performance Optimization: Minimize Renders |
| Advanced React Concepts | React Hook Form |
| Advanced React Concepts | Formik |
| Advanced React Concepts | SWR |
| Advanced React Concepts | React Query |
| React Query | State Management for API Data |
| React Query | Data Fetching |
| React Query | Caching |
| React Query | Synchronization |
| React Query | Project-Based Learning with React Query |
| Testing | Introduction to Testing in React |
| Testing | Setting Up Jest & Component Testing |
| Testing | Mocking & Spying |
| Testing | Testing Async Code |
| Testing | Project: Test Login Page & UI |

| Best Practices & Tooling | Webpack Mastery |
| Best Practices & Tooling | Essential Git Commands |
| Best Practices & Tooling | Docker Setup for React |
| Best Practices & Tooling | CI/CD with GitLab |
| Best Practices & Tooling | Tooling: Bootstrapping |

| Best Practices & Tooling | Webpack |
| Best Practices & Tooling | Vite |
| Best Practices & Tooling | Pebble |

| AI & Generative AI in Frontend | What is AI & GenAI? |
| AI & Generative AI in Frontend | GenAI in Frontend |
| AI & Generative AI in Frontend | Text-to-Image Generation App |
| AI & Generative AI in Frontend | AI-Powered Chatbot App |
| AI & Generative AI in Frontend | Leveraging AI as a Software Engineer |
| Machine Coding & System Design | HTML & CSS Mastery |
| Machine Coding & System Design | Output-Based Interview Questions |
| Machine Coding & System Design | LeetCode-Inspired Coding Challenges |
| Machine Coding & System Design | Hands-On Interview Prep (JS & React) |
| Machine Coding & System Design | System Design Interviews |
| Why NextJS is the Future of React | Modern React Ecosystem |
| Why NextJS is the Future of React | NextJS vs ReactJS |
| Why NextJS is the Future of React | NextJS vs NestJS |

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>



### Introduction to React and Declarative UI

Imagine you're building with LEGO blocks. Instead of telling each block exactly where to go step by step, you just describe what the final castle should look like, and the blocks magically arrange themselves!

**Key Points:**
- React is a JavaScript library for building user interfaces
- Declarative means you describe WHAT you want, not HOW to do it
- Components are reusable pieces of UI (like LEGO blocks)
- React handles the DOM updates for you

**Real-life example:** Like ordering food at a restaurant - you tell the waiter "I want a burger with fries" (declarative) instead of going to the kitchen and cooking it yourself step by step (imperative).

```javascript
// Declarative approach with React
function Welcome() {
  return <h1>Hello, World!</h1>;
}

// vs Imperative approach (vanilla JS)
const element = document.createElement('h1');
element.textContent = 'Hello, World!';
document.body.appendChild(element);
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Virtual DOM and Reconciliation

Imagine you have a rough draft of your drawing before making the final version. React keeps a "rough draft" of your webpage in memory, compares it with the real webpage, and only changes the parts that are different!

**Key Points:**
- Virtual DOM is a JavaScript copy of the real DOM
- React compares old and new Virtual DOM (diffing)
- Only updates changed parts (reconciliation)
- Makes apps super fast

**Real-life example:** Like editing a document - instead of retyping the whole page, you only change the words that need fixing.

```javascript
// When state changes, React creates new Virtual DOM
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p> {/* Only this updates when count changes */}
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Setting Up Development Environment

Before you can build awesome LEGO creations, you need to set up your workspace with all the right tools and pieces organized!

**Key Points:**
- Install Node.js (JavaScript runtime)
- Install a code editor (VS Code recommended)
- Install browser extensions for React
- Set up terminal/command prompt

**Real-life example:** Like setting up your art desk with paints, brushes, and paper before starting to draw.

```bash
# Check if Node.js is installed
node --version
npm --version

# Install VS Code extensions
# - ES7+ React/Redux/React-Native snippets
# - Bracket Pair Colorizer
# - Auto Rename Tag
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Creating Your First React App

It's like getting a pre-built LEGO starter kit that already has the basic structure, so you can start building your castle right away!

**Key Points:**
- Create React App is a tool that sets everything up
- Provides development server with hot reload
- Includes build tools and testing setup
- No configuration needed to start

**Real-life example:** Like buying a cake mix instead of gathering flour, eggs, and sugar separately - everything you need is already included!

```bash
# Create a new React app
npx create-react-app my-first-app

# Navigate to the project
cd my-first-app

# Start the development server
npm start
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Project Structure

Think of your React project like organizing your bedroom - everything has its special place so you can find it easily!

**Key Points:**
- `src/` folder contains your React code
- `public/` folder has static files
- `package.json` lists all dependencies
- `App.js` is your main component

**Real-life example:** Like organizing your school backpack - textbooks in one section, pens in another, lunch in a separate compartment.

```
my-react-app/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── App.js
│   ├── App.css
│   ├── index.js
│   └── components/
├── package.json
└── node_modules/
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### NPM vs NPX vs NVM

Think of these as different types of helpers in your toy store - NPM is the store manager, NPX is the temporary helper, and NVM helps you switch between different store layouts!

**Key Points:**
- NPM = Node Package Manager (installs and manages packages)
- NPX = Node Package Execute (runs packages without installing)
- NVM = Node Version Manager (switches between Node.js versions)

**Real-life example:** NPM is like buying toys to keep, NPX is like renting toys for a day, NVM is like having different toy boxes for different ages.

```bash
# NPM - Install and keep packages
npm install react

# NPX - Run packages temporarily
npx create-react-app my-app

# NVM - Switch Node versions
nvm use 18.0.0
nvm list
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Caret and Tilde

These are like rules for your toy collection - the caret (^) says "I'm okay with newer toys from the same brand" and tilde (~) says "I only want tiny improvements to my exact toy."

**Key Points:**
- Caret (^) allows minor and patch updates
- Tilde (~) allows only patch updates
- Helps control which package versions to use
- Prevents breaking changes

**Real-life example:** Like saying "I want LEGO version 2.x.x or newer" (^) vs "I only want LEGO 2.1.x fixes" (~).

```json
{
  "dependencies": {
    "react": "^18.2.0",    // Allows 18.2.0 to 18.9.9
    "lodash": "~4.17.20"   // Allows 4.17.20 to 4.17.99
  }
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Writing Code from Scratch

Instead of using pre-made LEGO sets, you're building everything from individual blocks - it's harder but you learn exactly how everything fits together!

**Key Points:**
- Understanding core concepts deeply
- No magic or hidden configurations
- Better debugging skills
- Full control over your code

**Real-life example:** Like learning to bake a cake from scratch instead of using a cake mix - you understand every ingredient.

```javascript
// Creating React without Create React App
import React from 'react';
import ReactDOM from 'react-dom/client';

function App() {
  return <h1>Built from scratch!</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Creating & Publishing NPM Packages

It's like creating your own toy and sharing it with kids all around the world so they can play with it too!

**Key Points:**
- Package.json defines your package
- NPM registry stores packages globally
- Semantic versioning (1.2.3 = major.minor.patch)
- Anyone can install and use your package

**Real-life example:** Like creating a cool LEGO instruction manual and sharing it so other kids can build the same awesome creation.

```bash
# Initialize new package
npm init

# Publish to NPM
npm publish

# Install someone else's package
npm install awesome-react-component
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### JSX HTML like Syntax in JS

JSX is like being able to draw pictures directly in your story book instead of having to describe them with just words!

**Key Points:**
- JSX looks like HTML but it's actually JavaScript
- Makes writing UI components easier
- Gets converted to regular JavaScript
- Can mix HTML-like syntax with JavaScript logic

**Real-life example:** Like writing a comic book where you can draw pictures right in the middle of your sentences.

```javascript
// JSX - looks like HTML
function Welcome() {
  const name = "Alice";
  return <h1>Hello, {name}!</h1>;
}

// What it becomes (regular JavaScript)
function Welcome() {
  const name = "Alice";
  return React.createElement('h1', null, 'Hello, ', name, '!');
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Babel How JSX Works

Babel is like a magical translator that turns your easy-to-read comic book language into the complicated language that computers understand!

**Key Points:**
- Babel transpiles JSX to regular JavaScript
- Browsers don't understand JSX natively
- Happens during build process
- Allows modern JavaScript features

**Real-life example:** Like having a friend translate your English homework into French for your French teacher.

```javascript
// Before Babel (JSX)
const element = <h1>Hello World</h1>;

// After Babel (JavaScript)
const element = React.createElement('h1', null, 'Hello World');
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Naming Conventions CamelCase PascalCase Kebab-Case

Different types of naming are like different ways of writing your name - sometimes "johnSmith", sometimes "JohnSmith", sometimes "john-smith" - each has its special place!

**Key Points:**
- camelCase: variables and functions (firstName)
- PascalCase: components and classes (MyComponent)
- kebab-case: CSS classes and HTML attributes (my-class)
- SCREAMING_CASE: constants (API_KEY)

**Real-life example:** Like how you write your name differently on your backpack (John), your homework (john smith), and your locker (JOHN-SMITH).

```javascript
// PascalCase for components
function MyAwesomeComponent() {
  // camelCase for variables
  const userName = "Alice";
  const handleButtonClick = () => {};

  return (
    <div className="my-component">  {/* kebab-case for CSS */}
      <h1>{userName}</h1>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Fragments

Fragments are like invisible gift boxes - they help you group your toys together without adding an extra box that everyone can see!

**Key Points:**
- Groups elements without extra DOM nodes
- Avoids unnecessary wrapper divs
- Two syntaxes: <React.Fragment> or <>
- Keeps HTML structure clean

**Real-life example:** Like putting multiple cookies on a plate without wrapping them in a bag first.

```javascript
// Without Fragment (creates extra div)
function BadExample() {
  return (
    <div>  {/* Extra wrapper div */}
      <h1>Title</h1>
      <p>Description</p>
    </div>
  );
}

// With Fragment (no extra wrapper)
function GoodExample() {
  return (
    <>
      <h1>Title</h1>
      <p>Description</p>
    </>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### JavaScript Expressions in JSX

It's like being able to do math problems right in the middle of writing a sentence - you put curly braces {} around the math part!

**Key Points:**
- Use {} to embed JavaScript in JSX
- Can contain variables, functions, expressions
- Only expressions, not statements (no if/for)
- Automatically converts to strings for display

**Real-life example:** Like writing "I have {2 + 3} apples" and it shows "I have 5 apples".

```javascript
function MathExample() {
  const name = "Alice";
  const age = 10;

  return (
    <div>
      <h1>Hello {name}!</h1>
      <p>Next year you'll be {age + 1} years old</p>
      <p>Your name has {name.length} letters</p>
      <p>{age >= 13 ? "Teenager" : "Kid"}</p>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Dynamic Attributes in JSX

It's like having a magic sticker that changes color based on your mood - the sticker's color attribute changes depending on how you're feeling!

**Key Points:**
- Attributes can use JavaScript expressions
- Use {} for dynamic values
- className instead of class
- camelCase for attribute names

**Real-life example:** Like a name tag that automatically shows your current favorite color.

```javascript
function DynamicButton() {
  const isActive = true;
  const buttonText = "Click me!";
  const buttonColor = isActive ? "blue" : "gray";

  return (
    <button
      className={isActive ? "active-btn" : "inactive-btn"}
      style={{backgroundColor: buttonColor}}
      disabled={!isActive}
    >
      {buttonText}
    </button>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Handling Events in React

It's like teaching your toy robot to respond when you press its buttons - you tell it exactly what to do when someone clicks, types, or touches!

**Key Points:**
- Use camelCase event names (onClick, onChange)
- Pass function references, not calls
- SyntheticEvents work across all browsers
- Can prevent default behavior

**Real-life example:** Like programming a doorbell to play different songs when pressed.

```javascript
function InteractiveButton() {
  const handleClick = () => {
    alert("Button was clicked!");
  };

  const handleMouseOver = () => {
    console.log("Mouse is over the button!");
  };

  return (
    <button
      onClick={handleClick}
      onMouseOver={handleMouseOver}
    >
      Hover and Click me!
    </button>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### State in React

State is like your toy robot's memory - it remembers important things like whether it's on or off, what color it is, or how many steps it has taken!

**Key Points:**
- State stores data that can change over time
- When state changes, component re-renders
- Each component has its own state
- State updates are asynchronous

**Real-life example:** Like a digital pet that remembers how hungry it is, how happy it is, and its current level.

```javascript
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
      <button onClick={() => setCount(count - 1)}>
        Decrease
      </button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Introduction to React Hooks

Hooks are like special tools that let your toy components do amazing things - like remember stuff, talk to other toys, or react to changes around them!

**Key Points:**
- Hooks let functional components use features like state
- Start with "use" (useState, useEffect, etc.)
- Only call at the top level of components
- Can create custom hooks

**Real-life example:** Like giving your action figures special powers - one remembers things, another can detect when it's moved.

```javascript
import { useState, useEffect } from 'react';

function HookExample() {
  const [count, setCount] = useState(0);

  // useEffect hook - runs after render
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useState for State Management

useState is like having a special memory box for your toy - you can put something in it, check what's inside, and replace it with something new whenever you want!

**Key Points:**
- Returns current state value and setter function
- State updates trigger re-renders
- Can hold any type of data
- Previous state available in updater function

**Real-life example:** Like a scoreboard that shows your current score and has buttons to change it.

```javascript
import { useState } from 'react';

function StateExamples() {
  const [name, setName] = useState(""); // String state
  const [age, setAge] = useState(0);    // Number state
  const [isVisible, setIsVisible] = useState(true); // Boolean state

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />
      <button onClick={() => setAge(age + 1)}>
        Age: {age}
      </button>
      {isVisible && <p>Hello {name}!</p>}
      <button onClick={() => setIsVisible(!isVisible)}>
        Toggle Message
      </button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Handling User Input in Forms

It's like having a conversation with your computer - you type something, the computer listens and remembers what you said, then it can respond back to you!

**Key Points:**
- Controlled components: React controls input values
- Use onChange to track input changes
- value prop makes inputs controlled
- Form submission with onSubmit

**Real-life example:** Like filling out a worksheet where each answer you write gets saved immediately.

```javascript
import { useState } from 'react';

function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Hello ${formData.name}!`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Your name"
      />
      <input
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Your email"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Rendering Lists with map

It's like having a magic copying machine - you give it a list of your favorite toys, and it creates a display case showing each toy with its name and picture!

**Key Points:**
- Use .map() to transform arrays into JSX elements
- Each item needs a unique key prop
- Keys help React track changes efficiently
- Can filter arrays before mapping

**Real-life example:** Like creating name tags for everyone in your class from a list of students.

```javascript
function TodoList() {
  const todos = [
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Build an app", completed: false },
    { id: 3, text: "Have fun coding", completed: true }
  ];

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id} style={{
          textDecoration: todo.completed ? 'line-through' : 'none'
        }}>
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Mastering Props Passing Data

Props are like passing notes between toys - one toy can send information, pictures, or instructions to another toy so they can work together!

**Key Points:**
- Props pass data from parent to child components
- Props are read-only (immutable)
- Can pass any type of data (strings, numbers, functions, objects)
- Use destructuring for cleaner code

**Real-life example:** Like giving your friend the ingredients and recipe so they can help you bake cookies.

```javascript
// Parent component
function App() {
  const userData = {
    name: "Alice",
    age: 12,
    favoriteColor: "blue"
  };

  return (
    <div>
      <UserCard
        name={userData.name}
        age={userData.age}
        color={userData.favoriteColor}
        onButtonClick={() => alert("Hello!")}
      />
    </div>
  );
}

// Child component
function UserCard({ name, age, color, onButtonClick }) {
  return (
    <div style={{ borderColor: color }}>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <button onClick={onButtonClick}>
        Say Hello!
      </button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Web DevTools Deep Dive

DevTools are like having X-ray vision and a detective kit for your web app - you can see inside, find problems, and understand exactly what's happening!

**Key Points:**
- React Developer Tools extension shows component tree
- Console for debugging and testing
- Network tab shows data loading
- Elements tab for inspecting HTML/CSS

**Real-life example:** Like having a special magnifying glass that shows you how all the parts of your toy robot work inside.

```javascript
function DebuggingExample() {
  const [count, setCount] = useState(0);

  // Console logging for debugging
  console.log("Component rendered, count is:", count);

  const handleClick = () => {
    console.log("Button clicked!");
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Click me</button>
      {/* This will show in React DevTools */}
    </div>
  );
}

// Debugging tips:
// 1. Use console.log() to see values
// 2. Use React DevTools to inspect props/state
// 3. Use breakpoints in browser debugger
// 4. Check Network tab for API calls
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Building Reusable Components

It's like creating a magic template for making toys - once you design the perfect toy robot template, you can create hundreds of different robots just by changing their colors, sizes, or special features!

**Key Points:**
- Components should do one thing well (Single Responsibility Principle)
- Use props to make components flexible and customizable
- Keep components small and focused
- Think about what parts can be reused across your app

**Real-life example:** Like creating a cookie cutter - once you have the shape, you can make cookies with different flavors, colors, or decorations using the same basic template.

```javascript
// Reusable Button Component
function Button({
  text,
  color = "blue",
  size = "medium",
  onClick,
  disabled = false
}) {
  const sizeClasses = {
    small: "px-2 py-1 text-sm",
    medium: "px-4 py-2 text-base",
    large: "px-6 py-3 text-lg"
  };

  return (
    <button
      className={`${sizeClasses[size]} bg-${color}-500 text-white rounded hover:bg-${color}-600 disabled:opacity-50`}
      onClick={onClick}
      disabled={disabled}
    >
      {text}
    </button>
  );
}

// Reusable Card Component
function Card({ title, children, className = "" }) {
  return (
    <div className={`bg-white shadow-md rounded-lg p-4 ${className}`}>
      {title && <h3 className="text-lg font-bold mb-2">{title}</h3>}
      {children}
    </div>
  );
}

// Using the reusable components
function App() {
  return (
    <div>
      <Card title="My Profile">
        <p>Welcome to my profile!</p>
        <Button text="Edit Profile" color="green" onClick={() => alert("Edit!")} />
        <Button text="Delete" color="red" size="small" onClick={() => alert("Delete!")} />
      </Card>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Rendering & Managing Task Cards

It's like having a bulletin board where you can pin up different task cards, and each card shows the task details, status, and has buttons to interact with it!

**Key Points:**
- Each task is represented as a card component
- Cards display task information clearly
- Use state to manage list of tasks
- Map through tasks to render multiple cards

**Real-life example:** Like having a collection of Pokemon cards where each card shows different information (name, type, powers) and you can organize them in different ways.

```javascript
import { useState } from 'react';

// Task Card Component
function TaskCard({ task, onEdit, onDelete, onToggleComplete }) {
  return (
    <div className={`p-4 border rounded-lg shadow-sm ${task.completed ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200'}`}>
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <h3 className={`font-semibold ${task.completed ? 'line-through text-gray-500' : 'text-gray-800'}`}>
            {task.title}
          </h3>
          <p className="text-sm text-gray-600 mt-1">{task.description}</p>
          <div className="flex gap-2 mt-2">
            {task.tags.map(tag => (
              <span key={tag} className="px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded">
                {tag}
              </span>
            ))}
          </div>
          <p className="text-xs text-gray-400 mt-2">Due: {task.dueDate}</p>
        </div>

        <div className="flex gap-2 ml-4">
          <button
            onClick={() => onToggleComplete(task.id)}
            className={`px-3 py-1 rounded text-sm ${
              task.completed
                ? 'bg-yellow-500 text-white hover:bg-yellow-600'
                : 'bg-green-500 text-white hover:bg-green-600'
            }`}
          >
            {task.completed ? 'Undo' : 'Complete'}
          </button>
          <button
            onClick={() => onEdit(task.id)}
            className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
          >
            Edit
          </button>
          <button
            onClick={() => onDelete(task.id)}
            className="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600"
          >
            Delete
          </button>
        </div>
      </div>
    </div>
  );
}

// Main Task Manager Component
function TaskManager() {
  const [tasks, setTasks] = useState([
    {
      id: 1,
      title: "Learn React Components",
      description: "Understand how to build reusable components",
      tags: ["react", "learning"],
      dueDate: "2023-12-31",
      completed: false
    },
    {
      id: 2,
      title: "Build Todo App",
      description: "Create a complete todo application",
      tags: ["project", "javascript"],
      dueDate: "2023-11-15",
      completed: true
    }
  ]);

  const handleEdit = (taskId) => {
    console.log("Editing task:", taskId);
    // Add edit functionality here
  };

  const handleDelete = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId));
  };

  const handleToggleComplete = (taskId) => {
    setTasks(tasks.map(task =>
      task.id === taskId
        ? { ...task, completed: !task.completed }
        : task
    ));
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">My Tasks</h1>
      <div className="space-y-4">
        {tasks.map(task => (
          <TaskCard
            key={task.id}
            task={task}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleComplete={handleToggleComplete}
          />
        ))}
      </div>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Delete Functionality for Tasks

It's like having a magic eraser that can remove specific drawings from your sketchbook - you point at what you want to delete, confirm you really want it gone, and *poof* it disappears!

**Key Points:**
- Use filter() to remove items from arrays
- Always confirm before deleting (user experience)
- Update state immutably (don't modify original array)
- Consider undo functionality for better UX

**Real-life example:** Like removing a specific photo from your photo album - you find the photo, decide to remove it, and the album reorganizes itself automatically.

```javascript
import { useState } from 'react';

function TaskList() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn React", completed: false },
    { id: 2, title: "Build a project", completed: false },
    { id: 3, title: "Practice coding", completed: true }
  ]);

  const [showDeleteConfirm, setShowDeleteConfirm] = useState(null);

  // Simple delete function
  const deleteTask = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId));
  };

  // Delete with confirmation
  const deleteTaskWithConfirm = (taskId) => {
    if (window.confirm("Are you sure you want to delete this task?")) {
      deleteTask(taskId);
    }
  };

  // Delete with custom confirmation modal
  const showDeleteModal = (taskId) => {
    setShowDeleteConfirm(taskId);
  };

  const confirmDelete = () => {
    if (showDeleteConfirm) {
      deleteTask(showDeleteConfirm);
      setShowDeleteConfirm(null);
    }
  };

  const cancelDelete = () => {
    setShowDeleteConfirm(null);
  };

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-4">Task List</h2>

      {/* Task List */}
      <div className="space-y-2">
        {tasks.map(task => (
          <div key={task.id} className="flex items-center justify-between p-3 border rounded">
            <span className={task.completed ? 'line-through text-gray-500' : ''}>
              {task.title}
            </span>
            <div className="space-x-2">
              {/* Simple delete button */}
              <button
                onClick={() => deleteTaskWithConfirm(task.id)}
                className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600"
              >
                Quick Delete
              </button>

              {/* Delete with modal */}
              <button
                onClick={() => showDeleteModal(task.id)}
                className="px-3 py-1 bg-orange-500 text-white rounded hover:bg-orange-600"
              >
                Delete with Modal
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Custom Delete Confirmation Modal */}
      {showDeleteConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
          <div className="bg-white p-6 rounded-lg shadow-lg">
            <h3 className="text-lg font-semibold mb-4">Confirm Delete</h3>
            <p className="mb-4">Are you sure you want to delete this task? This action cannot be undone.</p>
            <div className="flex gap-3">
              <button
                onClick={confirmDelete}
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
              >
                Yes, Delete
              </button>
              <button
                onClick={cancelDelete}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Advanced: Delete with Undo functionality
function TaskListWithUndo() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn React", completed: false },
    { id: 2, title: "Build a project", completed: false }
  ]);
  const [deletedTask, setDeletedTask] = useState(null);
  const [showUndo, setShowUndo] = useState(false);

  const deleteTaskWithUndo = (taskId) => {
    const taskToDelete = tasks.find(task => task.id === taskId);
    const updatedTasks = tasks.filter(task => task.id !== taskId);

    setTasks(updatedTasks);
    setDeletedTask(taskToDelete);
    setShowUndo(true);

    // Auto-hide undo after 5 seconds
    setTimeout(() => {
      setShowUndo(false);
      setDeletedTask(null);
    }, 5000);
  };

  const undoDelete = () => {
    if (deletedTask) {
      setTasks([...tasks, deletedTask]);
      setDeletedTask(null);
      setShowUndo(false);
    }
  };

  return (
    <div className="p-6">
      {/* Undo notification */}
      {showUndo && (
        <div className="mb-4 p-3 bg-yellow-100 border-l-4 border-yellow-500 flex justify-between items-center">
          <span>Task "{deletedTask?.title}" was deleted</span>
          <button
            onClick={undoDelete}
            className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
          >
            Undo
          </button>
        </div>
      )}

      {/* Tasks */}
      <div className="space-y-2">
        {tasks.map(task => (
          <div key={task.id} className="flex items-center justify-between p-3 border rounded">
            <span>{task.title}</span>
            <button
              onClick={() => deleteTaskWithUndo(task.id)}
              className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600"
            >
              Delete
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Persisting Tasks in Local Storage

It's like having a magic notebook that automatically saves everything you write, so even if you close the notebook and come back later, all your notes are still there!

**Key Points:**
- localStorage saves data in the browser permanently
- Data persists even after closing the browser
- Always handle JSON parsing errors
- Sync state with localStorage on every change

**Real-life example:** Like having a diary that magically saves your entries and remembers them even if you put it away for months.

```javascript
import { useState, useEffect } from 'react';

function TaskAppWithStorage() {
  // Initialize state from localStorage or use default
  const [tasks, setTasks] = useState(() => {
    try {
      const savedTasks = localStorage.getItem('tasks');
      return savedTasks ? JSON.parse(savedTasks) : [];
    } catch (error) {
      console.error('Error loading tasks from localStorage:', error);
      return [];
    }
  });

  // Save to localStorage whenever tasks change
  useEffect(() => {
    try {
      localStorage.setItem('tasks', JSON.stringify(tasks));
    } catch (error) {
      console.error('Error saving tasks to localStorage:', error);
    }
  }, [tasks]);

  // Add new task
  const addTask = (taskText) => {
    const newTask = {
      id: Date.now(), // Simple ID generation
      text: taskText,
      completed: false,
      createdAt: new Date().toISOString()
    };
    setTasks([...tasks, newTask]);
  };

  // Toggle task completion
  const toggleTask = (taskId) => {
    setTasks(tasks.map(task =>
      task.id === taskId
        ? { ...task, completed: !task.completed }
        : task
    ));
  };

  // Delete task
  const deleteTask = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId));
  };

  // Clear all tasks
  const clearAllTasks = () => {
    if (window.confirm('Are you sure you want to clear all tasks?')) {
      setTasks([]);
      localStorage.removeItem('tasks'); // Optional: remove from storage completely
    }
  };

  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h1 className="text-2xl font-bold mb-4">My Persistent Tasks</h1>

      {/* Add Task Form */}
      <TaskForm onAddTask={addTask} />

      {/* Task Count */}
      <div className="mb-4 text-sm text-gray-600">
        Total: {tasks.length} tasks ({tasks.filter(t => !t.completed).length} pending)
      </div>

      {/* Task List */}
      <div className="space-y-2 mb-4">
        {tasks.length === 0 ? (
          <p className="text-gray-500 text-center py-4">No tasks yet. Add one above!</p>
        ) : (
          tasks.map(task => (
            <TaskItem
              key={task.id}
              task={task}
              onToggle={() => toggleTask(task.id)}
              onDelete={() => deleteTask(task.id)}
            />
          ))
        )}
      </div>

      {/* Clear All Button */}
      {tasks.length > 0 && (
        <button
          onClick={clearAllTasks}
          className="w-full px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
        >
          Clear All Tasks
        </button>
      )}
    </div>
  );
}

// Task Form Component
function TaskForm({ onAddTask }) {
  const [inputValue, setInputValue] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      onAddTask(inputValue.trim());
      setInputValue('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="mb-4">
      <div className="flex gap-2">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Add a new task..."
          className="flex-1 px-3 py-2 border border-gray-300 rounded focus:outline-none focus:border-blue-500"
        />
        <button
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
          disabled={!inputValue.trim()}
        >
          Add
        </button>
      </div>
    </form>
  );
}

// Task Item Component
function TaskItem({ task, onToggle, onDelete }) {
  return (
    <div className="flex items-center gap-3 p-3 border rounded-lg">
      <input
        type="checkbox"
        checked={task.completed}
        onChange={onToggle}
        className="w-4 h-4"
      />
      <span className={`flex-1 ${task.completed ? 'line-through text-gray-500' : ''}`}>
        {task.text}
      </span>
      <button
        onClick={onDelete}
        className="px-2 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600"
      >
        Delete
      </button>
    </div>
  );
}

// Advanced: Custom hook for localStorage
function useLocalStorage(key, initialValue) {
  // Initialize state with value from localStorage or initialValue
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Function to set value in both state and localStorage
  const setValue = (value) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}

// Using the custom hook
function TaskAppWithCustomHook() {
  const [tasks, setTasks] = useLocalStorage('myTasks', []);

  const addTask = (text) => {
    const newTask = {
      id: Date.now(),
      text,
      completed: false
    };
    setTasks([...tasks, newTask]);
  };

  return (
    <div>
      <h1>Tasks with Custom Hook</h1>
      {/* Rest of the component */}
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Strict Mode

Strict Mode is like having a super careful teacher who double-checks your work and points out potential problems before they become big issues!

**Key Points:**
- Helps catch bugs early in development
- Renders components twice to detect side effects
- Warns about unsafe lifecycle methods
- Only runs in development mode (not production)

**Real-life example:** Like having a spell-checker that not only finds typos but also suggests better ways to write your sentences.

```javascript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

// Enabling Strict Mode for your entire app
function App() {
  return (
    <StrictMode>
      <Header />
      <MainContent />
      <Footer />
    </StrictMode>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// Or enable it just for specific components
function MyApp() {
  return (
    <div>
      <Header />
      <StrictMode>
        <ExperimentalComponent /> {/* Only this component runs in strict mode */}
      </StrictMode>
      <Footer />
    </div>
  );
}

// Example: Component with side effects (Strict Mode will help catch this)
function ProblematicComponent() {
  const [count, setCount] = useState(0);

  // ❌ BAD: Side effect in render (Strict Mode will run this twice)
  console.log('Component rendering...'); // This will log twice in Strict Mode

  // ❌ BAD: Direct DOM manipulation in render
  // document.title = `Count: ${count}`; // Don't do this!

  // ✅ GOOD: Side effects in useEffect
  useEffect(() => {
    console.log('Effect running...'); // This is fine
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Example: What Strict Mode helps you catch
function ComponentWithProblems() {
  const [users, setUsers] = useState([]);

  // ❌ BAD: This will cause problems in Strict Mode
  const fetchUsers = () => {
    fetch('/api/users')
      .then(response => response.json())
      .then(data => {
        setUsers(data); // This might set state after component unmounts
      });
  };

  // ✅ GOOD: Proper cleanup
  useEffect(() => {
    let cancelled = false;

    fetch('/api/users')
      .then(response => response.json())
      .then(data => {
        if (!cancelled) { // Only set state if component is still mounted
          setUsers(data);
        }
      });

    return () => {
      cancelled = true; // Cleanup function
    };
  }, []);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Example: Creating React app with Strict Mode (index.js)
/*
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const root = createRoot(document.getElementById('root'));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
*/

// What Strict Mode does:
// 1. Renders components twice to catch side effects
// 2. Warns about deprecated APIs
// 3. Helps identify unsafe lifecycles
// 4. Warns about legacy string ref API usage
// 5. Detects unexpected side effects

// Common issues Strict Mode helps catch:
function ExampleIssues() {
  const [data, setData] = useState([]);

  // Issue 1: Impure render function
  const randomId = Math.random(); // ❌ This changes on every render

  // Issue 2: Missing cleanup in useEffect
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 1000);

    // ❌ Missing cleanup - memory leak!
    // return () => clearInterval(timer); // Should have this
  }, []);

  // Issue 3: Mutating props or state directly
  const handleAddItem = (newItem) => {
    data.push(newItem); // ❌ Mutating state directly
    setData(data); // Won't trigger re-render properly

    // ✅ Should be:
    // setData([...data, newItem]);
  };

  return <div>Component with issues</div>;
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Tag Selection & Filtering UI

It's like having a magical sorting hat for your tasks - you can pick different colored tags and only see the tasks that match those colors, making it super easy to find exactly what you're looking for!

**Key Points:**
- Tags help categorize and organize tasks
- Filtering allows users to focus on specific categories
- Use state to track selected tags and filter logic
- Visual feedback shows which tags are active

**Real-life example:** Like organizing your clothes by color or type - you can choose to see only "school clothes" or "play clothes" when you're getting dressed.

```javascript
import { useState } from 'react';

function TaskManagerWithTags() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn React Components", tags: ["react", "learning", "frontend"], completed: false },
    { id: 2, title: "Build API endpoint", tags: ["backend", "api", "work"], completed: false },
    { id: 3, title: "Design homepage", tags: ["design", "frontend", "work"], completed: true },
    { id: 4, title: "Study for exam", tags: ["learning", "personal"], completed: false },
    { id: 5, title: "Fix bug in login", tags: ["bug", "backend", "urgent"], completed: false }
  ]);

  const [selectedTags, setSelectedTags] = useState([]);
  const [filterMode, setFilterMode] = useState('all'); // 'all', 'any', 'none'

  // Get all unique tags from all tasks
  const allTags = [...new Set(tasks.flatMap(task => task.tags))];

  // Filter tasks based on selected tags
  const filteredTasks = tasks.filter(task => {
    if (selectedTags.length === 0) return true;

    switch (filterMode) {
      case 'all':
        return selectedTags.every(tag => task.tags.includes(tag));
      case 'any':
        return selectedTags.some(tag => task.tags.includes(tag));
      case 'none':
        return !selectedTags.some(tag => task.tags.includes(tag));
      default:
        return true;
    }
  });

  // Toggle tag selection
  const toggleTag = (tag) => {
    setSelectedTags(prev =>
      prev.includes(tag)
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
  };

  // Clear all selected tags
  const clearAllTags = () => {
    setSelectedTags([]);
  };

  // Predefined tag colors for better UI
  const tagColors = {
    react: "bg-blue-500",
    learning: "bg-green-500",
    frontend: "bg-purple-500",
    backend: "bg-orange-500",
    api: "bg-yellow-500",
    work: "bg-red-500",
    design: "bg-pink-500",
    personal: "bg-gray-500",
    bug: "bg-red-600",
    urgent: "bg-red-700"
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">Task Manager with Tags</h1>

      {/* Tag Filter Section */}
      <div className="bg-gray-50 p-4 rounded-lg mb-6">
        <h3 className="font-semibold mb-3">Filter by Tags:</h3>

        {/* Filter Mode Selection */}
        <div className="mb-3">
          <label className="text-sm font-medium text-gray-700 mr-3">Filter Mode:</label>
          <select
            value={filterMode}
            onChange={(e) => setFilterMode(e.target.value)}
            className="px-2 py-1 border rounded text-sm"
          >
            <option value="any">Any selected tag (OR)</option>
            <option value="all">All selected tags (AND)</option>
            <option value="none">None of selected tags (NOT)</option>
          </select>
        </div>

        {/* Tag Selection */}
        <div className="flex flex-wrap gap-2 mb-3">
          {allTags.map(tag => (
            <TagButton
              key={tag}
              tag={tag}
              isSelected={selectedTags.includes(tag)}
              onClick={() => toggleTag(tag)}
              color={tagColors[tag] || "bg-gray-400"}
            />
          ))}
        </div>

        {/* Clear and Info */}
        <div className="flex justify-between items-center text-sm text-gray-600">
          <span>
            {selectedTags.length > 0
              ? `Showing ${filteredTasks.length} of ${tasks.length} tasks`
              : `Showing all ${tasks.length} tasks`
            }
          </span>
          {selectedTags.length > 0 && (
            <button
              onClick={clearAllTags}
              className="text-blue-500 hover:text-blue-700"
            >
              Clear filters
            </button>
          )}
        </div>
      </div>

      {/* Selected Tags Display */}
      {selectedTags.length > 0 && (
        <div className="mb-4">
          <span className="text-sm font-medium text-gray-700 mr-2">Active filters:</span>
          {selectedTags.map(tag => (
            <span key={tag} className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 text-sm rounded mr-2 mb-1">
              {tag}
              <button
                onClick={() => toggleTag(tag)}
                className="text-blue-600 hover:text-blue-800"
              >
                ×
              </button>
            </span>
          ))}
        </div>
      )}

      {/* Task List */}
      <div className="space-y-3">
        {filteredTasks.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            {selectedTags.length > 0
              ? "No tasks match the selected filters"
              : "No tasks available"
            }
          </div>
        ) : (
          filteredTasks.map(task => (
            <TaskCard key={task.id} task={task} />
          ))
        )}
      </div>
    </div>
  );
}

// Tag Button Component
function TagButton({ tag, isSelected, onClick, color }) {
  return (
    <button
      onClick={onClick}
      className={`
        px-3 py-1 rounded-full text-sm font-medium transition-all
        ${isSelected
          ? `${color} text-white shadow-md transform scale-105`
          : 'bg-white text-gray-700 border hover:bg-gray-50'
        }
      `}
    >
      {tag}
      {isSelected && <span className="ml-1">✓</span>}
    </button>
  );
}

// Task Card Component
function TaskCard({ task }) {
  const tagColors = {
    react: "bg-blue-500",
    learning: "bg-green-500",
    frontend: "bg-purple-500",
    backend: "bg-orange-500",
    api: "bg-yellow-500",
    work: "bg-red-500",
    design: "bg-pink-500",
    personal: "bg-gray-500",
    bug: "bg-red-600",
    urgent: "bg-red-700"
  };

  return (
    <div className={`p-4 border rounded-lg ${task.completed ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200'}`}>
      <h4 className={`font-semibold ${task.completed ? 'line-through text-gray-500' : 'text-gray-800'}`}>
        {task.title}
      </h4>
      <div className="flex flex-wrap gap-1 mt-2">
        {task.tags.map(tag => (
          <span
            key={tag}
            className={`px-2 py-1 text-xs text-white rounded ${tagColors[tag] || 'bg-gray-400'}`}
          >
            {tag}
          </span>
        ))}
      </div>
    </div>
  );
}

// Advanced: Tag Input Component for adding new tags
function TagInput({ onAddTag, existingTags = [] }) {
  const [inputValue, setInputValue] = useState('');
  const [suggestions, setSuggestions] = useState([]);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setInputValue(value);

    // Show suggestions based on existing tags
    if (value.length > 0) {
      const filteredSuggestions = existingTags.filter(tag =>
        tag.toLowerCase().includes(value.toLowerCase()) && !value.split(',').includes(tag)
      );
      setSuggestions(filteredSuggestions);
    } else {
      setSuggestions([]);
    }
  };

  const handleAddTag = (tagToAdd = null) => {
    const tag = tagToAdd || inputValue.trim();
    if (tag && !existingTags.includes(tag)) {
      onAddTag(tag);
      setInputValue('');
      setSuggestions([]);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault();
      handleAddTag();
    }
  };

  return (
    <div className="relative">
      <input
        type="text"
        value={inputValue}
        onChange={handleInputChange}
        onKeyPress={handleKeyPress}
        placeholder="Add tags (press Enter or comma to add)"
        className="w-full px-3 py-2 border rounded focus:outline-none focus:border-blue-500"
      />

      {suggestions.length > 0 && (
        <div className="absolute z-10 w-full bg-white border border-gray-300 rounded-b shadow-lg max-h-40 overflow-y-auto">
          {suggestions.map(suggestion => (
            <button
              key={suggestion}
              onClick={() => handleAddTag(suggestion)}
              className="w-full text-left px-3 py-2 hover:bg-gray-100"
            >
              {suggestion}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Customizing Fonts & Styling (Tailwind, MaterialUI)

It's like having a massive box of art supplies and design tools - you can make your web app look exactly how you want, whether you prefer the quick stickers approach (Tailwind) or the fancy art kit approach (Material-UI)!

**Key Points:**
- Tailwind: Utility-first CSS for rapid styling
- Material-UI: Pre-built components with Google's design system
- Both approaches have different philosophies and use cases
- Choose based on your project needs and team preferences

**Real-life example:** Tailwind is like having individual colored pencils for every tiny detail, while Material-UI is like having pre-made sticker sets that look professional right away.

```javascript
import { useState } from 'react';
// For Material-UI (install: npm install @mui/material @emotion/react @emotion/styled)
import {
  Button,
  Card,
  CardContent,
  Typography,
  TextField,
  Chip,
  Box,
  ThemeProvider,
  createTheme,
  CssBaseline
} from '@mui/material';

// TAILWIND CSS APPROACH
function TailwindTaskApp() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn Tailwind CSS", status: "pending", priority: "high" },
    { id: 2, title: "Build responsive design", status: "completed", priority: "medium" }
  ]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
      {/* Header with custom fonts */}
      <header className="text-center mb-8">
        <h1 className="text-4xl md:text-5xl font-bold text-gray-800 mb-2 font-serif">
          My Stylish Tasks
        </h1>
        <p className="text-lg text-gray-600 font-light">
          Built with Tailwind CSS magic ✨
        </p>
      </header>

      {/* Custom styled container */}
      <div className="max-w-4xl mx-auto">
        {/* Add task form with custom styling */}
        <div className="bg-white/70 backdrop-blur-sm rounded-2xl p-6 mb-6 shadow-xl border border-white/20">
          <form className="flex gap-4">
            <input
              type="text"
              placeholder="Add a new task..."
              className="
                flex-1 px-4 py-3 rounded-xl border-2 border-gray-200
                focus:border-blue-500 focus:ring-2 focus:ring-blue-200
                outline-none transition-all duration-300
                font-medium text-gray-700 placeholder-gray-400
              "
            />
            <button className="
              px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600
              text-white font-semibold rounded-xl
              hover:from-blue-600 hover:to-purple-700
              transform hover:scale-105 transition-all duration-300
              shadow-lg hover:shadow-xl
            ">
              Add Task
            </button>
          </form>
        </div>

        {/* Task grid with responsive design */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {tasks.map(task => (
            <TailwindTaskCard key={task.id} task={task} />
          ))}
        </div>

        {/* Custom statistics card */}
        <div className="mt-8 bg-white/60 backdrop-blur-sm rounded-2xl p-6 shadow-xl">
          <h3 className="text-2xl font-bold text-gray-800 mb-4">Statistics</h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <StatCard label="Total" value="12" color="blue" />
            <StatCard label="Completed" value="8" color="green" />
            <StatCard label="Pending" value="4" color="yellow" />
            <StatCard label="High Priority" value="2" color="red" />
          </div>
        </div>
      </div>
    </div>
  );
}

// Tailwind Task Card Component
function TailwindTaskCard({ task }) {
  const priorityColors = {
    high: "bg-red-100 text-red-800 border-red-200",
    medium: "bg-yellow-100 text-yellow-800 border-yellow-200",
    low: "bg-green-100 text-green-800 border-green-200"
  };

  return (
    <div className="
      group bg-white/80 backdrop-blur-sm rounded-xl p-5 shadow-lg
      hover:shadow-2xl hover:bg-white/90
      transform hover:-translate-y-2 transition-all duration-300
      border border-white/30
    ">
      <div className="flex justify-between items-start mb-3">
        <h4 className="font-bold text-gray-800 text-lg group-hover:text-blue-600 transition-colors">
          {task.title}
        </h4>
        <span className={`
          px-3 py-1 rounded-full text-xs font-medium border
          ${priorityColors[task.priority]}
        `}>
          {task.priority}
        </span>
      </div>

      <div className="flex justify-between items-center">
        <span className={`
          px-3 py-1 rounded-full text-sm font-medium
          ${task.status === 'completed'
            ? 'bg-green-100 text-green-800'
            : 'bg-blue-100 text-blue-800'
          }
        `}>
          {task.status}
        </span>

        <div className="flex gap-2">
          <button className="
            p-2 rounded-lg bg-blue-500 text-white
            hover:bg-blue-600 transform hover:scale-110
            transition-all duration-200
          ">
            ✏️
          </button>
          <button className="
            p-2 rounded-lg bg-red-500 text-white
            hover:bg-red-600 transform hover:scale-110
            transition-all duration-200
          ">
            🗑️
          </button>
        </div>
      </div>
    </div>
  );
}

// Stat Card Component
function StatCard({ label, value, color }) {
  const colorClasses = {
    blue: "bg-blue-500",
    green: "bg-green-500",
    yellow: "bg-yellow-500",
    red: "bg-red-500"
  };

  return (
    <div className="text-center p-4 bg-white/50 rounded-xl">
      <div className={`w-12 h-12 mx-auto mb-2 rounded-full ${colorClasses[color]} flex items-center justify-center`}>
        <span className="text-white font-bold text-lg">{value}</span>
      </div>
      <p className="text-gray-600 font-medium">{label}</p>
    </div>
  );
}

// MATERIAL-UI APPROACH
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 600,
    },
  },
});

function MaterialUITaskApp() {
  const [tasks, setTasks] = useState([
    { id: 1, title: "Learn Material-UI", status: "pending", priority: "high" },
    { id: 2, title: "Design with components", status: "completed", priority: "medium" }
  ]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ minHeight: '100vh', bgcolor: 'grey.50', p: 3 }}>
        {/* Header */}
        <Box textAlign="center" mb={4}>
          <Typography variant="h3" component="h1" gutterBottom fontWeight="bold">
            Material-UI Task Manager
          </Typography>
          <Typography variant="h6" color="text.secondary">
            Beautiful components out of the box
          </Typography>
        </Box>

        {/* Add task form */}
        <Box maxWidth="md" mx="auto" mb={4}>
          <Card elevation={3}>
            <CardContent>
              <Box display="flex" gap={2}>
                <TextField
                  fullWidth
                  placeholder="Add a new task..."
                  variant="outlined"
                  size="medium"
                />
                <Button
                  variant="contained"
                  color="primary"
                  size="large"
                  sx={{ minWidth: '120px' }}
                >
                  Add Task
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Box>

        {/* Task cards */}
        <Box maxWidth="lg" mx="auto">
          <Box display="grid" gridTemplateColumns="repeat(auto-fit, minmax(300px, 1fr))" gap={3}>
            {tasks.map(task => (
              <MaterialUITaskCard key={task.id} task={task} />
            ))}
          </Box>
        </Box>
      </Box>
    </ThemeProvider>
  );
}

// Material-UI Task Card Component
function MaterialUITaskCard({ task }) {
  const getPriorityColor = (priority) => {
    switch(priority) {
      case 'high': return 'error';
      case 'medium': return 'warning';
      case 'low': return 'success';
      default: return 'default';
    }
  };

  return (
    <Card
      elevation={2}
      sx={{
        transition: 'all 0.3s ease',
        '&:hover': {
          elevation: 8,
          transform: 'translateY(-4px)'
        }
      }}
    >
      <CardContent>
        <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={2}>
          <Typography variant="h6" component="h3" fontWeight="bold">
            {task.title}
          </Typography>
          <Chip
            label={task.priority}
            color={getPriorityColor(task.priority)}
            size="small"
            variant="outlined"
          />
        </Box>

        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Chip
            label={task.status}
            color={task.status === 'completed' ? 'success' : 'primary'}
            variant={task.status === 'completed' ? 'filled' : 'outlined'}
          />

          <Box>
            <Button size="small" color="primary">
              Edit
            </Button>
            <Button size="small" color="error">
              Delete
            </Button>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
}

// Custom CSS-in-JS approach (Styled Components alternative)
function CustomStyledApp() {
  const styles = {
    container: {
      fontFamily: "'Inter', -apple-system, BlinkMacSystemFont, sans-serif",
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      padding: '2rem'
    },
    header: {
      textAlign: 'center',
      color: 'white',
      marginBottom: '2rem'
    },
    title: {
      fontSize: 'clamp(2rem, 5vw, 3.5rem)',
      fontWeight: '700',
      margin: '0 0 0.5rem 0',
      textShadow: '2px 2px 4px rgba(0,0,0,0.3)'
    },
    card: {
      backgroundColor: 'rgba(255, 255, 255, 0.95)',
      borderRadius: '1rem',
      padding: '1.5rem',
      boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
      backdropFilter: 'blur(10px)',
      border: '1px solid rgba(255, 255, 255, 0.2)',
      transition: 'all 0.3s ease',
      cursor: 'pointer'
    },
    cardHover: {
      transform: 'translateY(-5px)',
      boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15)'
    }
  };

  return (
    <div style={styles.container}>
      <header style={styles.header}>
        <h1 style={styles.title}>Custom Styled Tasks</h1>
        <p>Hand-crafted with CSS-in-JS</p>
      </header>

      {/* Content goes here */}
    </div>
  );
}

// Font loading example (add to your HTML head or CSS)
/*
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');

// Or for Tailwind config:
module.exports = {
  theme: {
    fontFamily: {
      'sans': ['Inter', 'sans-serif'],
      'display': ['Poppins', 'sans-serif'],
      'body': ['Inter', 'sans-serif'],
    }
  }
}
*/
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### Setting Up Routing (React Router)

Like creating a map for your house - each room has a specific address so visitors know where to go!

**Key Points:**
- Install `react-router-dom` package
- Wrap app with `<BrowserRouter>`
- Define routes with `<Routes>` and `<Route>`

```js
// 1. Install: npm install react-router-dom
// 2. Setup in App.js:
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Not Found Page (React Router)

Like having a "Room not found" sign when someone looks for a room that doesn't exist in your house!

**Key Points:**
- Use `path="*"` to catch all undefined routes
- Always put it as the last route
- Show helpful 404 message

```js
function NotFound() {
  return (
    <div>
      <h1>404 - Page Not Found</h1>
      <Link to="/">Go Home</Link>
    </div>
  );
}

// In your Routes:
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
  <Route path="*" element={<NotFound />} /> {/* Always last! */}
</Routes>
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### SPA with React Router

Like a magic house where rooms change instantly without walking through doors - no page reloads!

**Key Points:**
- SPA = Single Page Application
- Use `<Link>` instead of `<a>` tags
- Navigation happens without page refresh

```js
import { Link } from 'react-router-dom';

function Navbar() {
  return (
    <nav>
      <Link to="/">Home</Link> {/* ✅ Good - no reload */}
      <Link to="/about">About</Link>
      <a href="/contact">Contact</a> {/* ❌ Bad - causes reload */}
    </nav>
  );
}

// Link with styling:
<Link to="/about" className="nav-link">About Us</Link>
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Route Parameters & Query Strings

Like having personalized room keys - each person gets their own room number and special preferences!

**Key Points:**
- `:param` creates dynamic routes
- `useParams()` gets URL parameters
- `useSearchParams()` gets query strings (?key=value)

```js
// Routes with parameters:
<Routes>
  <Route path="/user/:id" element={<UserProfile />} />
  <Route path="/product/:category/:id" element={<Product />} />
</Routes>

// In UserProfile component:
import { useParams, useSearchParams } from 'react-router-dom';

function UserProfile() {
  const { id } = useParams(); // Gets :id from URL
  const [searchParams] = useSearchParams(); // Gets ?name=john&age=25

  const userName = searchParams.get('name');

  return (
    <div>
      <h1>User ID: {id}</h1>
      <p>Name: {userName}</p>
    </div>
  );
}

// URL: /user/123?name=john&age=25
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Nested Routing & Programmatic Navigation

Like having rooms inside rooms, and a remote control to instantly teleport between any room!

**Key Points:**
- Nest routes for layouts and subpages
- Use `<Outlet />` to render child routes
- `useNavigate()` for navigation in code

```js
import { Outlet, useNavigate } from 'react-router-dom';

// Nested Routes Setup:
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
    <Route path="settings" element={<Settings />} />
  </Route>
</Routes>

// Dashboard Layout:
function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="profile">Profile</Link>
        <Link to="settings">Settings</Link>
      </nav>
      <Outlet /> {/* Child routes render here */}
    </div>
  );
}

// Programmatic Navigation:
function LoginForm() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // After login logic...
    navigate('/dashboard'); // Redirect to dashboard
    // navigate(-1); // Go back
    // navigate('/home', { replace: true }); // Replace current page
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useEffect & Dependency Array

Like setting up reminders for your robot to do chores whenever something changes!

**Key Points:**
- `useEffect()` runs code after render (side effects)
- Dependency array `[]` controls when effect runs
- Empty `[]` = run once when component loads
- `[count]` = run when `count` changes

**Real-life example:** Like telling your alarm clock "Ring when it's 7 AM" or "Ring whenever I change the time."

```js
import { useEffect, useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  // Run once when component loads
  useEffect(() => {
    console.log("Component loaded!");
  }, []); // Empty array = run once

  // Run every time count changes
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]); // Runs when count changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Add</button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Fetching Data (fetch, Axios)

Like sending your robot to the store to get new supplies - it goes, gets the data, and brings it back!

**Key Points:**
- Use `fetch()` (built-in) or `axios` (library)
- Always fetch data inside `useEffect()`
- Axios is easier and more popular
- Handle both success and error cases

**Real-life example:** Like ordering food online - you place the order, wait for delivery, and either get your food or an error message.

```js
import { useState, useEffect } from 'react';
import axios from 'axios'; // npm install axios

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // Method 1: Using fetch (built-in)
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response => response.json()) // Convert to JSON
      .then(data => setUsers(data))
      .catch(error => console.error('Error:', error));
  }, []);

  // Method 2: Using axios (easier)
  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/users')
      .then(response => setUsers(response.data)) // axios auto-converts to JSON
      .catch(error => console.error('Error:', error));
  }, []);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Loaders & Error Handling

Like showing a "Loading..." sign while your robot is busy, and an "Oops!" sign if something goes wrong!

**Key Points:**
- Use 3 states: `loading`, `error`, and `data`
- Show loading spinner while fetching
- Display error message if something fails
- Show data when everything works

**Real-life example:** Like waiting for a webpage to load - you see a spinning wheel, then either the page or an error message.

```js
import { useState, useEffect } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Start loading
    setLoading(true);
    setError(null);

    fetch('https://jsonplaceholder.typicode.com/users/1')
      .then(response => {
        if (!response.ok) {
          throw new Error('User not found');
        }
        return response.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false); // Stop loading
      })
      .catch(err => {
        setError(err.message);
        setLoading(false); // Stop loading
      });
  }, []);

  // Show loading state
  if (loading) {
    return <div>Loading user data... 🔄</div>;
  }

  // Show error state
  if (error) {
    return <div>Error: {error} ❌</div>;
  }

  // Show success state
  return (
    <div>
      <h1>{user.name} ✅</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Promises vs Async/Await

Like asking your robot to promise to finish a task, or just telling it "wait until you're done, then continue!"

**Key Points:**
- **Promises**: Use `.then()` and `.catch()` (older way)
- **Async/await**: Looks like normal code (newer, cleaner way)
- Both handle asynchronous operations
- Async/await is easier to read and debug

**Real-life example:** Promises are like "I promise to call you back" vs Async/await is like "Wait, let me check and get back to you right now."

```js
// METHOD 1: Promises (older style)
function fetchUserWithPromises() {
  fetch('https://jsonplaceholder.typicode.com/users/1')
    .then(response => response.json())
    .then(user => {
      console.log('User:', user.name);
      return user;
    })
    .catch(error => {
      console.error('Error:', error);
    });
}

// METHOD 2: Async/Await (modern style - RECOMMENDED)
async function fetchUserWithAsync() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
    const user = await response.json();
    console.log('User:', user.name);
    return user;
  } catch (error) {
    console.error('Error:', error);
  }
}

// Using in React component
function UserComponent() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Option 1: Create async function inside useEffect
    const getUser = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Error:', error);
      }
    };

    getUser(); // Call the async function
  }, []);

  return user ? <h1>{user.name}</h1> : <p>Loading...</p>;
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### POST, PUT, DELETE with Axios

Like sending your robot to add, update, or remove items from your inventory!

**Key Points:**
- **POST** = Create new data (like adding a new user)
- **PUT** = Update existing data (like editing a user)
- **DELETE** = Remove data (like deleting a user)
- Use axios methods for each operation

**Real-life example:** POST is like adding a new contact to your phone, PUT is like updating their phone number, DELETE is like removing them completely.

```js
import axios from 'axios';

function UserManager() {
  const [users, setUsers] = useState([]);

  // CREATE - Add new user (POST)
  const addUser = async () => {
    try {
      const newUser = {
        name: 'John Doe',
        email: 'john@example.com'
      };

      const response = await axios.post('https://jsonplaceholder.typicode.com/users', newUser);
      console.log('User created:', response.data);

      // Add to local state
      setUsers([...users, response.data]);
    } catch (error) {
      console.error('Error creating user:', error);
    }
  };

  // UPDATE - Edit existing user (PUT)
  const updateUser = async (userId) => {
    try {
      const updatedUser = {
        name: 'John Smith', // Updated name
        email: 'johnsmith@example.com'
      };

      const response = await axios.put(`https://jsonplaceholder.typicode.com/users/${userId}`, updatedUser);
      console.log('User updated:', response.data);

      // Update local state
      setUsers(users.map(user =>
        user.id === userId ? response.data : user
      ));
    } catch (error) {
      console.error('Error updating user:', error);
    }
  };

  // DELETE - Remove user
  const deleteUser = async (userId) => {
    try {
      await axios.delete(`https://jsonplaceholder.typicode.com/users/${userId}`);
      console.log('User deleted');

      // Remove from local state
      setUsers(users.filter(user => user.id !== userId));
    } catch (error) {
      console.error('Error deleting user:', error);
    }
  };

  return (
    <div>
      <button onClick={addUser}>Add User</button>
      <button onClick={() => updateUser(1)}>Update User 1</button>
      <button onClick={() => deleteUser(1)}>Delete User 1</button>
    </div>
  );
}

// Quick Reference:
// axios.get(url)           - GET data
// axios.post(url, data)    - CREATE data
// axios.put(url, data)     - UPDATE data
// axios.delete(url)        - DELETE data
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Design Patterns: Container-Presentational

Like having a chef (Container) who handles all the cooking logic, and a waiter (Presentational) who just serves the food beautifully!

**Key Points:**
- **Container Components**: Handle logic, state, and data fetching
- **Presentational Components**: Just display UI based on props
- Separates business logic from visual presentation
- Makes components more reusable and testable

**Real-life example:** Like a restaurant where the chef handles cooking (logic) while the waiter handles serving (presentation).

```js
// PRESENTATIONAL COMPONENT (UI only)
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
      <button onClick={() => onDelete(user.id)}>Delete</button>
    </div>
  );
}

// CONTAINER COMPONENT (Logic & State)
function UserCardContainer({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch user data
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(userData => {
        setUser(userData);
        setLoading(false);
      });
  }, [userId]);

  const handleEdit = (id) => {
    // Edit logic
    console.log('Editing user:', id);
  };

  const handleDelete = (id) => {
    // Delete logic
    setUser(null);
    console.log('Deleted user:', id);
  };

  if (loading) return <div>Loading...</div>;

  return (
    <UserCard
      user={user}
      onEdit={handleEdit}
      onDelete={handleDelete}
    />
  );
}

// Usage
function App() {
  return (
    <div>
      <UserCardContainer userId={1} />
      <UserCardContainer userId={2} />
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### HOC (Higher-Order Components)

Like a gift wrapper that takes any gift (component) and wraps it with extra features like tracking, authentication, or styling!

**Key Points:**
- Function that takes a component and returns an enhanced component
- Used for code reuse and cross-cutting concerns
- Common uses: authentication, logging, data fetching
- Think of it as a "component decorator"

**Real-life example:** Like a security guard who checks everyone's ID before letting them into different rooms - same security logic for all rooms.

```js
// HOC for authentication
function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      // Check if user is authenticated
      const token = localStorage.getItem('token');
      if (token) {
        fetch('/api/me', {
          headers: { Authorization: `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(userData => {
          setUser(userData);
          setLoading(false);
        })
        .catch(() => {
          setLoading(false);
        });
      } else {
        setLoading(false);
      }
    }, []);

    if (loading) return <div>Checking authentication...</div>;

    if (!user) {
      return <div>Please login to access this page</div>;
    }

    // Pass all props + user to wrapped component
    return <WrappedComponent {...props} user={user} />;
  };
}

// HOC for loading states
function withLoading(WrappedComponent) {
  return function LoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading... 🔄</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// Regular components
function Dashboard({ user }) {
  return (
    <div>
      <h1>Welcome to Dashboard, {user.name}!</h1>
      <p>Your email: {user.email}</p>
    </div>
  );
}

function Profile({ user }) {
  return (
    <div>
      <h1>Profile Page</h1>
      <p>Name: {user.name}</p>
    </div>
  );
}

// Enhanced components using HOCs
const AuthenticatedDashboard = withAuth(Dashboard);
const AuthenticatedProfile = withAuth(Profile);
const LoadingProfile = withLoading(Profile);

// Usage
function App() {
  return (
    <div>
      <AuthenticatedDashboard />
      <AuthenticatedProfile />
      <LoadingProfile isLoading={false} user={{ name: 'John' }} />
    </div>
  );
}

// Advanced: Composing multiple HOCs
const EnhancedDashboard = withAuth(withLoading(Dashboard));
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Custom Hooks

Like creating your own magic spells that you can use in any component - once you create the spell, you can cast it anywhere!

**Key Points:**
- Functions that start with "use" and contain React hooks
- Extract reusable stateful logic between components
- Can use other hooks inside them
- Return anything you want (state, functions, objects)

**Real-life example:** Like creating a universal remote control that works for TV, AC, and stereo - one remote (custom hook) for multiple devices (components).

```js
// Custom Hook for API data fetching
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Failed to fetch data');
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  // Return everything the component might need
  return { data, loading, error };
}

// Custom Hook for localStorage
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setStoredValue = (newValue) => {
    try {
      setValue(newValue);
      window.localStorage.setItem(key, JSON.stringify(newValue));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  };

  return [value, setStoredValue];
}

// Custom Hook for form handling
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({
      ...prev,
      [name]: value
    }));

    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const validate = (validationRules) => {
    const newErrors = {};

    Object.keys(validationRules).forEach(field => {
      const rule = validationRules[field];
      const value = values[field];

      if (rule.required && !value) {
        newErrors[field] = `${field} is required`;
      } else if (rule.minLength && value.length < rule.minLength) {
        newErrors[field] = `${field} must be at least ${rule.minLength} characters`;
      }
    });

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
  };

  return {
    values,
    errors,
    handleChange,
    validate,
    reset
  };
}

// Using Custom Hooks in Components
function UserProfile() {
  // Using useApi custom hook
  const { data: user, loading, error } = useApi('/api/user/profile');

  // Using useLocalStorage custom hook
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  if (loading) return <div>Loading profile...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div className={`profile ${theme}`}>
      <h1>{user.name}</h1>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Switch to {theme === 'light' ? 'Dark' : 'Light'} Mode
      </button>
    </div>
  );
}

function ContactForm() {
  // Using useForm custom hook
  const {
    values,
    errors,
    handleChange,
    validate,
    reset
  } = useForm({
    name: '',
    email: '',
    message: ''
  });

  const handleSubmit = (e) => {
    e.preventDefault();

    const isValid = validate({
      name: { required: true, minLength: 2 },
      email: { required: true },
      message: { required: true, minLength: 10 }
    });

    if (isValid) {
      console.log('Form submitted:', values);
      reset();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={values.name}
        onChange={handleChange}
        placeholder="Your name"
      />
      {errors.name && <span className="error">{errors.name}</span>}

      <input
        name="email"
        value={values.email}
        onChange={handleChange}
        placeholder="Your email"
      />
      {errors.email && <span className="error">{errors.email}</span>}

      <textarea
        name="message"
        value={values.message}
        onChange={handleChange}
        placeholder="Your message"
      />
      {errors.message && <span className="error">{errors.message}</span>}

      <button type="submit">Send Message</button>
    </form>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Deep Dive into Hooks: useEffect

Like a Swiss Army knife for handling side effects - it can do cleanup, timers, data fetching, subscriptions, and more!

**Key Points:**
- Replaces componentDidMount, componentDidUpdate, componentWillUnmount
- Runs after every render by default
- Dependency array controls when it runs
- Return cleanup function to prevent memory leaks

**Real-life example:** Like a smart home assistant that can turn lights on when you arrive, off when you leave, and handle multiple scheduled tasks.

```js
import { useState, useEffect } from 'react';

function UseEffectMasterClass() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState(null);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);

  // 1. BASIC useEffect - runs after every render
  useEffect(() => {
    console.log('Component rendered');
  });

  // 2. useEffect with EMPTY DEPENDENCY ARRAY - runs once on mount
  useEffect(() => {
    console.log('Component mounted - like componentDidMount');

    // Fetch initial data
    fetch('/api/user')
      .then(res => res.json())
      .then(setUser);
  }, []); // Empty array = run once

  // 3. useEffect with DEPENDENCIES - runs when dependencies change
  useEffect(() => {
    document.title = `Count: ${count}`;
    console.log('Count changed to:', count);
  }, [count]); // Runs when count changes

  // 4. useEffect with CLEANUP - prevents memory leaks
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 1000);

    // Cleanup function (like componentWillUnmount)
    return () => {
      clearInterval(timer);
      console.log('Timer cleaned up');
    };
  }, []);

  // 5. useEffect for EVENT LISTENERS
  useEffect(() => {
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // 6. useEffect with ASYNC operations
  useEffect(() => {
    let cancelled = false;

    const fetchData = async () => {
      try {
        const response = await fetch(`/api/user/${count}`);
        const userData = await response.json();

        // Only update if component is still mounted
        if (!cancelled) {
          setUser(userData);
        }
      } catch (error) {
        if (!cancelled) {
          console.error('Error fetching user:', error);
        }
      }
    };

    if (count > 0) {
      fetchData();
    }

    // Cleanup function
    return () => {
      cancelled = true;
    };
  }, [count]);

  // 7. CONDITIONAL useEffect
  useEffect(() => {
    if (user && user.preferences) {
      localStorage.setItem('userPrefs', JSON.stringify(user.preferences));
    }
  }, [user?.preferences]); // Only run when user.preferences changes

  return (
    <div>
      <h1>useEffect Deep Dive</h1>
      <p>Count: {count}</p>
      <p>Window Width: {windowWidth}px</p>
      <p>User: {user ? user.name : 'Loading...'}</p>

      <button onClick={() => setCount(count + 1)}>
        Increment Count
      </button>
    </div>
  );
}

// Advanced useEffect Patterns
function AdvancedEffects() {
  const [posts, setPosts] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);

  // 8. useEffect for INFINITE SCROLL
  useEffect(() => {
    const handleScroll = () => {
      if (
        window.innerHeight + document.documentElement.scrollTop
        >= document.documentElement.offsetHeight - 1000
      ) {
        setPage(prev => prev + 1);
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  // 9. useEffect for DEBOUNCED API CALLS
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    const debounceTimer = setTimeout(() => {
      if (searchTerm) {
        // API call after 500ms delay
        fetch(`/api/search?q=${searchTerm}`)
          .then(res => res.json())
          .then(results => console.log(results));
      }
    }, 500);

    return () => clearTimeout(debounceTimer);
  }, [searchTerm]);

  // 10. useEffect for WEBSOCKET connections
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8080');

    ws.onopen = () => console.log('WebSocket connected');
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      console.log('Received:', message);
    };
    ws.onerror = (error) => console.error('WebSocket error:', error);

    return () => {
      ws.close();
      console.log('WebSocket disconnected');
    };
  }, []);

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
    </div>
  );
}

// Common useEffect Mistakes and Solutions
function UseEffectMistakes() {
  const [count, setCount] = useState(0);

  // ❌ MISTAKE 1: Missing dependency
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + 1); // This will always use initial count value
    }, 1000);
    return () => clearInterval(timer);
  }, []); // Missing 'count' in dependency array

  // ✅ SOLUTION 1: Use functional update
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prev => prev + 1); // Uses latest count
    }, 1000);
    return () => clearInterval(timer);
  }, []); // Now we don't need count as dependency

  // ❌ MISTAKE 2: Infinite re-renders
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => setCount(data.count));
  }); // No dependency array = runs after every render

  // ✅ SOLUTION 2: Add dependency array
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => setCount(data.count));
  }, []); // Runs only once

  return <div>Count: {count}</div>;
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### useRef

Like having a sticky note that you can attach to any element or value - it persists between renders but doesn't trigger re-renders when changed!

**Key Points:**
- Creates a mutable reference that persists across renders
- Doesn't trigger re-renders when `.current` changes
- Common uses: DOM manipulation, storing previous values, timers
- Like `createRef` but for functional components

**Real-life example:** Like having a bookmark in a book - you can move it around without changing the book's content, and it stays where you put it.

```js
import { useRef, useState, useEffect } from 'react';

function UseRefExamples() {
  // 1. BASIC useRef for DOM elements
  const inputRef = useRef(null);
  const divRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus(); // Direct DOM access
  };

  const scrollToDiv = () => {
    divRef.current.scrollIntoView({ behavior: 'smooth' });
  };

  // 2. useRef for STORING VALUES (doesn't trigger re-render)
  const countRef = useRef(0);
  const [renderCount, setRenderCount] = useState(0);

  const incrementRef = () => {
    countRef.current += 1;
    console.log('Ref count:', countRef.current); // Updates but no re-render
  };

  const incrementState = () => {
    setRenderCount(prev => prev + 1); // Triggers re-render
  };

  // 3. useRef for PREVIOUS VALUES
  const [name, setName] = useState('');
  const prevNameRef = useRef('');

  useEffect(() => {
    prevNameRef.current = name; // Store previous value after render
  });

  const prevName = prevNameRef.current;

  // 4. useRef for TIMERS
  const timerRef = useRef(null);
  const [seconds, setSeconds] = useState(0);

  const startTimer = () => {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        setSeconds(prev => prev + 1);
      }, 1000);
    }
  };

  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  };

  const resetTimer = () => {
    stopTimer();
    setSeconds(0);
  };

  // Cleanup timer on unmount
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  return (
    <div>
      <h1>useRef Examples</h1>

      {/* DOM Reference Examples */}
      <section>
        <h2>DOM References</h2>
        <input ref={inputRef} placeholder="I can be focused!" />
        <button onClick={focusInput}>Focus Input</button>

        <div
          ref={divRef}
          style={{
            height: '200px',
            backgroundColor: 'lightblue',
            marginTop: '100vh'
          }}
        >
          Scroll to me!
        </div>
        <button onClick={scrollToDiv}>Scroll to Blue Div</button>
      </section>

      {/* Value Storage Examples */}
      <section>
        <h2>Value Storage</h2>
        <p>Ref count (no re-render): {countRef.current}</p>
        <p>State count (triggers re-render): {renderCount}</p>
        <button onClick={incrementRef}>Increment Ref</button>
        <button onClick={incrementState}>Increment State</button>
      </section>

      {/* Previous Value Example */}
      <section>
        <h2>Previous Values</h2>
        <input
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Type your name"
        />
        <p>Current name: {name}</p>
        <p>Previous name: {prevName}</p>
      </section>

      {/* Timer Example */}
      <section>
        <h2>Timer Control</h2>
        <p>Timer: {seconds} seconds</p>
        <button onClick={startTimer}>Start</button>
        <button onClick={stopTimer}>Stop</button>
        <button onClick={resetTimer}>Reset</button>
      </section>
    </div>
  );
}

// Advanced useRef Patterns
function AdvancedUseRef() {
  // 5. useRef for CALLBACK REFS
  const [height, setHeight] = useState(0);

  const measuredRef = useRef(null);

  const callbackRef = useRef((node) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  });

  // 6. useRef for STORING FUNCTIONS
  const apiCallRef = useRef(null);

  useEffect(() => {
    // Store the latest API call function
    apiCallRef.current = async (id) => {
      const response = await fetch(`/api/items/${id}`);
      return response.json();
    };
  });

  const handleApiCall = async (id) => {
    if (apiCallRef.current) {
      const data = await apiCallRef.current(id);
      console.log('API data:', data);
    }
  };

  // 7. useRef for IMPERATIVE ACTIONS
  const customComponentRef = useRef(null);

  const triggerCustomAction = () => {
    if (customComponentRef.current) {
      customComponentRef.current.doSomething();
    }
  };

  return (
    <div>
      <div ref={callbackRef}>
        <p>This div's height is: {height}px</p>
      </div>

      <CustomComponent ref={customComponentRef} />
      <button onClick={triggerCustomAction}>
        Trigger Custom Action
      </button>
    </div>
  );
}

// Forward Ref Example
const CustomComponent = React.forwardRef((props, ref) => {
  const [value, setValue] = useState('');

  // Expose methods to parent component
  useImperativeHandle(ref, () => ({
    doSomething: () => {
      setValue('Action triggered!');
      console.log('Custom action executed');
    },
    reset: () => {
      setValue('');
    },
    getValue: () => value
  }));

  return (
    <div>
      <p>Custom Component Value: {value}</p>
    </div>
  );
});

// Custom Hook using useRef
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

// Usage of custom hook
function ComponentWithPrevious() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>



### useImperativeHandle

Like giving your component a remote control that parents can use to trigger specific actions!

**Key Points:**
- Exposes custom functions to parent components
- Used with `forwardRef`
- Limits what parent can access

```js
const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    clear: () => inputRef.current.value = '',
    getValue: () => inputRef.current.value
  }));

  return <input ref={inputRef} {...props} />;
});

// Usage
function Parent() {
  const childRef = useRef();

  return (
    <div>
      <CustomInput ref={childRef} />
      <button onClick={() => childRef.current.focus()}>Focus</button>
      <button onClick={() => childRef.current.clear()}>Clear</button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useMemo

Like having a smart calculator that remembers expensive calculations so it doesn't repeat them!

**Key Points:**
- Caches expensive calculations
- Only recalculates when dependencies change
- Helps performance optimization

```js
function ExpensiveComponent({ items, filter }) {
  // Without useMemo - calculates every render
  const expensiveValue = items.filter(item =>
    item.name.includes(filter)
  ).reduce((sum, item) => sum + item.price, 0);

  // With useMemo - only recalculates when items or filter change
  const memoizedValue = useMemo(() => {
    return items.filter(item =>
      item.name.includes(filter)
    ).reduce((sum, item) => sum + item.price, 0);
  }, [items, filter]);

  return <div>Total: ${memoizedValue}</div>;
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useCallback

Like saving a recipe card so you don't have to rewrite it every time you cook!

**Key Points:**
- Caches function definitions
- Prevents unnecessary child re-renders
- Use when passing functions to child components

```js
function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // Bad - new function every render
  const handleClick = () => setCount(count + 1);

  // Good - cached function
  const memoizedClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  return (
    <div>
      <Child onClick={memoizedClick} />
      <input value={name} onChange={(e) => setName(e.target.value)} />
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useContext

Like a family group chat where everyone can see the same messages without passing them person to person!

**Key Points:**
- Shares data across components without prop drilling
- Create context, provide value, consume in any child
- Great for themes, user auth, language settings

```js
// 1. Create Context
const ThemeContext = createContext();

// 2. Provider Component
function App() {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Header />
      <MainContent />
      <Footer />
    </ThemeContext.Provider>
  );
}

// 3. Consume Context
function Header() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <header className={theme}>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Switch to {theme === 'light' ? 'Dark' : 'Light'}
      </button>
    </header>
  );
}

function MainContent() {
  const { theme } = useContext(ThemeContext);
  return <main className={theme}>Content here</main>;
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useReducer

Like having a state manager that handles complex state changes with specific rules!

**Key Points:**
- Better than useState for complex state logic
- Predictable state updates through actions
- Similar to Redux pattern

```js
// 1. Define reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    case 'set':
      return { count: action.payload };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// 2. Use reducer in component
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'set', payload: 10 })}>Set to 10</button>
    </div>
  );
}

// Complex example - Todo app
function todoReducer(todos, action) {
  switch (action.type) {
    case 'add':
      return [...todos, { id: Date.now(), text: action.text, done: false }];
    case 'toggle':
      return todos.map(todo =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    case 'delete':
      return todos.filter(todo => todo.id !== action.id);
    default:
      return todos;
  }
}

function TodoApp() {
  const [todos, dispatch] = useReducer(todoReducer, []);

  return (
    <div>
      <button onClick={() => dispatch({ type: 'add', text: 'New todo' })}>
        Add Todo
      </button>
      {todos.map(todo => (
        <div key={todo.id}>
          <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>
            {todo.text}
          </span>
          <button onClick={() => dispatch({ type: 'toggle', id: todo.id })}>
            Toggle
          </button>
          <button onClick={() => dispatch({ type: 'delete', id: todo.id })}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### React 19 Hooks: useActionState

Like having a smart form that tracks its own submission state and handles errors automatically!

**Key Points:**
- Manages form submission state (pending, success, error)
- Works with Server Actions
- Handles optimistic updates

```js
import { useActionState } from 'react';

async function submitForm(prevState, formData) {
  try {
    await new Promise(resolve => setTimeout(resolve, 1000));
    const name = formData.get('name');
    return { success: true, message: `Hello ${name}!` };
  } catch (error) {
    return { success: false, error: 'Something went wrong' };
  }
}

function ContactForm() {
  const [state, formAction, isPending] = useActionState(submitForm, null);

  return (
    <form action={formAction}>
      <input name="name" placeholder="Your name" required />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Submitting...' : 'Submit'}
      </button>

      {state?.success && <p style={{color: 'green'}}>{state.message}</p>}
      {state?.error && <p style={{color: 'red'}}>{state.error}</p>}
    </form>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useFormStatus

Like a dashboard that shows you exactly what's happening with your form submission!

**Key Points:**
- Tracks form submission status
- Must be used inside a form component
- Shows pending state and form data

```js
import { useFormStatus } from 'react-dom';

function SubmitButton() {
  const { pending, data, method, action } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Saving...' : 'Save'}
    </button>
  );
}

function MyForm() {
  async function handleSubmit(formData) {
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log('Form submitted:', Object.fromEntries(formData));
  }

  return (
    <form action={handleSubmit}>
      <input name="title" placeholder="Post title" />
      <textarea name="content" placeholder="Post content" />
      <SubmitButton />
    </form>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### useOptimistic

Like showing instant results while secretly waiting for the real confirmation in the background!

**Key Points:**
- Shows immediate UI updates before server confirmation
- Great for likes, comments, todos
- Automatically reverts on error

```js
import { useOptimistic, useState } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false }
  ]);

  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, newTodo]
  );

  async function addTodo(formData) {
    const text = formData.get('text');
    const newTodo = { id: Date.now(), text, completed: false };

    addOptimisticTodo(newTodo); // Show immediately

    try {
      await new Promise(resolve => setTimeout(resolve, 1000));
      setTodos(prev => [...prev, newTodo]); // Real update
    } catch (error) {
      console.error('Failed to add todo');
    }
  }

  return (
    <div>
      <form action={addTodo}>
        <input name="text" placeholder="New todo" required />
        <button type="submit">Add Todo</button>
      </form>

      <ul>
        {optimisticTodos.map(todo => (
          <li key={todo.id} style={{
            opacity: todos.includes(todo) ? 1 : 0.5
          }}>
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### use() API

Like a magic key that can unlock promises and context values anywhere in your component!

**Key Points:**
- Can be used inside conditions and loops (unlike hooks)
- Works with Promises and Context
- Suspends component until promise resolves

```js
import { use, Suspense } from 'react';

function UserProfile({ userPromise }) {
  const user = use(userPromise); // Suspends until resolved

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

const ThemeContext = createContext();

function Button({ primary }) {
  // Can use inside conditions!
  if (primary) {
    const theme = use(ThemeContext);
    return <button className={theme}>Primary Button</button>;
  }

  return <button>Regular Button</button>;
}

function App() {
  const userPromise = fetch('/api/user').then(res => res.json());

  return (
    <ThemeContext.Provider value="dark">
      <Suspense fallback={<div>Loading user...</div>}>
        <UserProfile userPromise={userPromise} />
        <Button primary />
      </Suspense>
    </ThemeContext.Provider>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### Passing Refs as Props

Like giving someone the remote control to your TV so they can change channels from their couch!

**Key Points:**
- Pass refs like normal props (no forwardRef needed)
- Multiple refs can point to same element
- Cleaner than forwardRef pattern

```js
// Old way with forwardRef
const OldButton = forwardRef((props, ref) => {
  return <button ref={ref} {...props} />;
});

// New way - direct ref prop
function NewButton({ ref, ...props }) {
  return <button ref={ref} {...props} />;
}

function App() {
  const buttonRef = useRef();

  const focusButton = () => {
    buttonRef.current?.focus();
  };

  return (
    <div>
      <NewButton ref={buttonRef}>Click me</NewButton>
      <button onClick={focusButton}>Focus the button</button>

      {/* Conditional refs */}
      <NewButton ref={Math.random() > 0.5 ? buttonRef : null}>
        Maybe focused
      </NewButton>
    </div>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React as a Wrapper

Like a gift wrapper that takes your regular HTML and makes it interactive and dynamic!

**Key Points:**
- React wraps DOM elements with extra powers
- JSX gets converted to React.createElement calls
- React manages the actual DOM manipulation

```js
// What you write (JSX)
function App() {
  return <div className="app">Hello World</div>;
}

// What React actually does
function App() {
  return React.createElement('div', { className: 'app' }, 'Hello World');
}

// React wraps your components with extra functionality
function WrappedComponent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Reconciliation & How React Works Under the Hood

Like having a smart assistant who compares your old shopping list with your new one and only buys what changed!

**Key Points:**
- React compares Virtual DOM trees (diffing algorithm)
- Only updates parts of real DOM that actually changed
- Uses keys to efficiently track list items

```js
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}> {/* Key helps React track items */}
          {todo.text}
        </li>
      ))}
    </ul>
  );
}

// Example: Adding item to middle of list
// Old: [A, B, C]
// New: [A, X, B, C]
// With keys: React knows to insert X, keep A, B, C unchanged

function FiberExample() {
  const [items, setItems] = useState(['A', 'B', 'C']);

  const addItem = () => {
    setItems(prev => [...prev, `Item ${prev.length + 1}`]);
    // React schedules this update and can interrupt it for higher priority work
  };

  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>{item}</div>
      ))}
      <button onClick={addItem}>Add Item</button>
    </div>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Prop Drilling

Like passing a message through a long chain of people - each person must pass it along even if they don't need it!

**Key Points:**
- Passing props through multiple component levels
- Intermediate components don't use the props
- Can make code messy and hard to maintain

```js
// Prop Drilling Problem
function App() {
  const user = { name: 'John', role: 'admin' };
  return <Layout user={user} />;
}

function Layout({ user }) {
  // Layout doesn't use user, just passes it down
  return (
    <div>
      <Header user={user} />
      <Main user={user} />
    </div>
  );
}

function Header({ user }) {
  // Header doesn't use user, just passes it down
  return (
    <header>
      <Navigation user={user} />
    </header>
  );
}

function Navigation({ user }) {
  // Finally! Someone who actually uses the user
  return (
    <nav>
      Welcome, {user.name}!
      {user.role === 'admin' && <AdminPanel />}
    </nav>
  );
}

// Solution: Component Composition
function BetterApp() {
  const user = { name: 'John', role: 'admin' };

  return (
    <Layout>
      <Header>
        <Navigation user={user} /> {/* Direct prop passing */}
      </Header>
      <Main user={user} />
    </Layout>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Context API

Like a family group chat where everyone can see the same messages without passing them person to person!

**Key Points:**
- Avoids prop drilling by sharing data globally
- Provider supplies values, consumers use them
- Perfect for themes, auth, language settings

```js
import { createContext, useContext, useState } from 'react';

// 1. Create Context
const UserContext = createContext();

// 2. Create Provider Component
function UserProvider({ children }) {
  const [user, setUser] = useState({ name: 'John', role: 'admin' });

  const login = (userData) => setUser(userData);
  const logout = () => setUser(null);

  return (
    <UserContext.Provider value={{ user, login, logout }}>
      {children}
    </UserContext.Provider>
  );
}

// 3. Custom hook for easy access
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

// 4. Use anywhere in the component tree
function App() {
  return (
    <UserProvider>
      <Layout />
    </UserProvider>
  );
}

function Header() {
  const { user, logout } = useUser(); // Direct access!

  return (
    <header>
      Welcome, {user?.name}!
      <button onClick={logout}>Logout</button>
    </header>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Suspense API

Like having a loading screen that automatically shows up while your content is getting ready behind the scenes!

**Key Points:**
- Shows fallback UI while components are loading
- Works with lazy loading and data fetching
- Can have multiple Suspense boundaries

```js
import { Suspense, lazy } from 'react';

// 1. Lazy Loading Components
const LazyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <div>
      <h1>My App</h1>

      <Suspense fallback={<div>Loading component...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

// 2. Data Fetching with Suspense
function UserProfile({ userId }) {
  const user = use(fetchUser(userId)); // Suspends until data loads

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

function ProfileApp() {
  return (
    <Suspense fallback={<div>Loading user...</div>}>
      <UserProfile userId={1} />
    </Suspense>
  );
}

// 3. Nested Suspense Boundaries
function NestedApp() {
  return (
    <Suspense fallback={<div>Loading app...</div>}>
      <Header />

      <Suspense fallback={<div>Loading posts...</div>}>
        <PostList />
      </Suspense>

      <Suspense fallback={<div>Loading sidebar...</div>}>
        <Sidebar />
      </Suspense>
    </Suspense>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### State Management Tools (Redux, Context, etc.)

Like having different sized storage boxes for your app's data - small box for simple stuff, big warehouse for complex apps!

**Key Points:**
- Context API: Built-in, good for simple global state
- Redux: Powerful, predictable state management with actions/reducers
- Zustand: Simple and lightweight alternative

```js
// 1. Context API (Built-in)
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  return (
    <AppContext.Provider value={{ user, setUser, theme, setTheme }}>
      {children}
    </AppContext.Provider>
  );
}

// 2. Redux (npm install @reduxjs/toolkit react-redux)
import { createSlice, configureStore } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; },
  }
});

// 3. Zustand (npm install zustand)
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Performance Optimization: Minimize Renders

Like being a smart shopper who only buys what they actually need instead of buying everything in the store!

**Key Points:**
- Use React.memo to prevent unnecessary re-renders
- useMemo for expensive calculations
- useCallback for function references

```js
// 1. React.memo - prevents re-renders when props haven't changed
const ExpensiveChild = React.memo(({ name, count }) => {
  console.log('ExpensiveChild rendered');
  return <div>{name}: {count}</div>;
});

// 2. useMemo - cache expensive calculations
function ExpensiveList({ items, filter }) {
  const filteredItems = useMemo(() => {
    return items.filter(item => item.name.includes(filter));
  }, [items, filter]);

  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

// 3. useCallback - cache function references
function TodoApp() {
  const [todos, setTodos] = useState([]);

  const memoizedDelete = useCallback((id) => {
    setTodos(todos => todos.filter(todo => todo.id !== id));
  }, []); // Stable reference

  return (
    <div>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} onDelete={memoizedDelete} />
      ))}
    </div>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Hook Form

Like having a smart form assistant that handles all the paperwork while you focus on the important stuff!

**Key Points:**
- Minimal re-renders with uncontrolled components
- Built-in validation and error handling
- Easy integration with UI libraries

```js
// npm install react-hook-form
import { useForm } from 'react-hook-form';

function ContactForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset
  } = useForm();

  const onSubmit = async (data) => {
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('Form data:', data);
    reset();
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('name', {
          required: 'Name is required',
          minLength: { value: 2, message: 'Min 2 characters' }
        })}
        placeholder="Your name"
      />
      {errors.name && <span style={{color: 'red'}}>{errors.name.message}</span>}

      <input
        {...register('email', {
          required: 'Email is required',
          pattern: {
            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            message: 'Invalid email'
          }
        })}
        placeholder="Your email"
      />
      {errors.email && <span style={{color: 'red'}}>{errors.email.message}</span>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : 'Send'}
      </button>
    </form>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Formik

Like having a personal form trainer who guides you through every step of form creation and validation!

**Key Points:**
- More opinionated than React Hook Form
- Built-in field components and validation
- Great for complex forms with nested data

```js
// npm install formik yup
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * Yup from 'yup';

const validationSchema = Yup.object({
  name: Yup.string().min(2, 'Too Short!').required('Required'),
  email: Yup.string().email('Invalid email').required('Required'),
});

function FormikForm() {
  return (
    <Formik
      initialValues={{ name: '', email: '' }}
      validationSchema={validationSchema}
      onSubmit={async (values, { setSubmitting, resetForm }) => {
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('Form values:', values);
        resetForm();
        setSubmitting(false);
      }}
    >
      {({ isSubmitting }) => (
        <Form>
          <Field type="text" name="name" placeholder="Your name" />
          <ErrorMessage name="name" component="div" style={{color: 'red'}} />

          <Field type="email" name="email" placeholder="Your email" />
          <ErrorMessage name="email" component="div" style={{color: 'red'}} />

          <button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Submitting...' : 'Submit'}
          </button>
        </Form>
      )}
    </Formik>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### SWR

Like having a smart cache that automatically refreshes your data when you switch browser tabs or come back online!

**Key Points:**
- Stale-while-revalidate strategy
- Automatic caching, revalidation, and error handling
- Great for simple data fetching needs

```js
// npm install swr
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserProfile({ userId }) {
  const { data: user, error, isLoading, mutate } = useSWR(
    `/api/users/${userId}`,
    fetcher,
    {
      refreshInterval: 10000, // Refresh every 10 seconds
      revalidateOnFocus: true, // Refresh when window gets focus
    }
  );

  if (error) return <div>Failed to load user</div>;
  if (isLoading) return <div>Loading...</div>;

  const updateUser = async () => {
    // Optimistic update
    mutate({ ...user, name: 'Updated Name' }, false);

    try {
      await fetch(`/api/users/${userId}`, {
        method: 'PUT',
        body: JSON.stringify({ name: 'Updated Name' })
      });
      mutate(); // Revalidate
    } catch (error) {
      mutate(); // Revert on error
    }
  };

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={updateUser}>Update Name</button>
    </div>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### React Query

Like having a super-intelligent data manager that handles caching, syncing, updating, and error handling automatically!

**Key Points:**
- Most powerful data fetching library
- Advanced caching strategies and background updates
- Built-in optimistic updates and infinite queries

```js
// npm install @tanstack/react-query
import { QueryClient, QueryClientProvider, useQuery, useMutation } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <UserList />
    </QueryClientProvider>
  );
}

function UserList() {
  // Query for fetching data
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json()),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Mutation for creating users
  const createUserMutation = useMutation({
    mutationFn: (newUser) =>
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser)
      }).then(res => res.json()),
    onSuccess: () => {
      queryClient.invalidateQueries(['users']);
    }
  });

  if (isLoading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={() => createUserMutation.mutate({ name: 'New User' })}>
        Create User
      </button>

      <ul>
        {users?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```


<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### State Management for API Data

Like having a smart warehouse manager who knows exactly where all your data is stored and keeps it fresh!

**Key Points:**
- React Query handles server state separately from client state
- Automatically manages loading, error, and success states
- Keeps UI in sync with server data

```js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function UserDashboard() {
  const queryClient = useQueryClient();

  // Server state management
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });

  // Update server state
  const updateUserMutation = useMutation({
    mutationFn: (userData) =>
      fetch(`/api/users/${userData.id}`, {
        method: 'PUT',
        body: JSON.stringify(userData)
      }),
    onSuccess: (updatedUser) => {
      // Update cache immediately
      queryClient.setQueryData(['users'], (oldUsers) =>
        oldUsers.map(user =>
          user.id === updatedUser.id ? updatedUser : user
        )
      );
    }
  });

  const handleUpdateUser = (user) => {
    updateUserMutation.mutate({ ...user, name: 'Updated Name' });
  };

  if (isLoading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>Users ({users?.length})</h1>
      {users?.map(user => (
        <div key={user.id}>
          <span>{user.name}</span>
          <button onClick={() => handleUpdateUser(user)}>
            Update
          </button>
        </div>
      ))}
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Data Fetching

Like having a personal delivery service that brings you exactly what you need, when you need it!

**Key Points:**
- Declarative data fetching with useQuery
- Automatic retries and error handling
- Support for dependent queries and parallel fetching

```js
// Basic data fetching
function UserProfile({ userId }) {
  const { data: user, isLoading, error, refetch } = useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user');
      return response.json();
    },
    enabled: !!userId, // Only run if userId exists
    retry: 3, // Retry 3 times on failure
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  if (isLoading) return <div>Loading user...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  );
}

// Dependent queries
function UserPosts({ userId }) {
  // First, get user
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(res => res.json())
  });

  // Then get posts (depends on user)
  const { data: posts, isLoading } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => fetch(`/api/users/${user.id}/posts`).then(res => res.json()),
    enabled: !!user?.id // Only run when user is loaded
  });

  if (isLoading) return <div>Loading posts...</div>;

  return (
    <div>
      <h2>{user?.name}'s Posts</h2>
      {posts?.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}

// Parallel queries
function Dashboard() {
  const userQuery = useQuery({
    queryKey: ['user'],
    queryFn: () => fetch('/api/user').then(res => res.json())
  });

  const postsQuery = useQuery({
    queryKey: ['posts'],
    queryFn: () => fetch('/api/posts').then(res => res.json())
  });

  const notificationsQuery = useQuery({
    queryKey: ['notifications'],
    queryFn: () => fetch('/api/notifications').then(res => res.json())
  });

  if (userQuery.isLoading || postsQuery.isLoading || notificationsQuery.isLoading) {
    return <div>Loading dashboard...</div>;
  }

  return (
    <div>
      <h1>Welcome, {userQuery.data?.name}</h1>
      <p>Posts: {postsQuery.data?.length}</p>
      <p>Notifications: {notificationsQuery.data?.length}</p>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Caching

Like having a super-smart librarian who remembers exactly which books you've read and keeps your favorites within easy reach!

**Key Points:**
- Intelligent caching with automatic garbage collection
- Query invalidation and cache updates
- Background refetching keeps data fresh

```js
import { useQuery, useQueryClient } from '@tanstack/react-query';

function CachingExample() {
  const queryClient = useQueryClient();

  const { data: todos } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(res => res.json()),
    staleTime: 2 * 60 * 1000, // 2 minutes - data is fresh
    cacheTime: 10 * 60 * 1000, // 10 minutes - keep in cache
    refetchOnWindowFocus: true, // Refetch when window regains focus
    refetchOnReconnect: true, // Refetch when reconnected
    refetchInterval: 30000, // Refetch every 30 seconds
  });

  // Manual cache operations
  const prefetchTodos = () => {
    queryClient.prefetchQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/api/todos').then(res => res.json()),
      staleTime: 2 * 60 * 1000,
    });
  };

  const invalidateTodos = () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  };

  const updateTodoInCache = (todoId, updates) => {
    queryClient.setQueryData(['todos'], (oldTodos) =>
      oldTodos.map(todo =>
        todo.id === todoId ? { ...todo, ...updates } : todo
      )
    );
  };

  const removeTodoFromCache = (todoId) => {
    queryClient.setQueryData(['todos'], (oldTodos) =>
      oldTodos.filter(todo => todo.id !== todoId)
    );
  };

  return (
    <div>
      <h1>Todos ({todos?.length})</h1>

      <div>
        <button onClick={prefetchTodos}>Prefetch Todos</button>
        <button onClick={invalidateTodos}>Refresh Todos</button>
        <button onClick={() => updateTodoInCache(1, { completed: true })}>
          Mark Todo 1 Complete
        </button>
      </div>

      {todos?.map(todo => (
        <div key={todo.id}>
          <span style={{
            textDecoration: todo.completed ? 'line-through' : 'none'
          }}>
            {todo.title}
          </span>
          <button onClick={() => removeTodoFromCache(todo.id)}>
            Remove
          </button>
        </div>
      ))}
    </div>
  );
}

// Query with selective cache updates
function OptimizedTodoList() {
  const queryClient = useQueryClient();

  const addTodoMutation = useMutation({
    mutationFn: (newTodo) =>
      fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo)
      }).then(res => res.json()),
    onMutate: async (newTodo) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // Snapshot previous value
      const previousTodos = queryClient.getQueryData(['todos']);

      // Optimistically update cache
      queryClient.setQueryData(['todos'], (old) => [
        ...old,
        { id: Date.now(), ...newTodo, completed: false }
      ]);

      return { previousTodos };
    },
    onError: (err, newTodo, context) => {
      // Rollback on error
      queryClient.setQueryData(['todos'], context.previousTodos);
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });

  return (
    <div>
      <button onClick={() => addTodoMutation.mutate({ title: 'New Todo' })}>
        Add Todo
      </button>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Synchronization

Like having a perfect orchestra conductor who keeps all musicians playing in harmony, even when someone misses a beat!

**Key Points:**
- Real-time synchronization across components
- Optimistic updates with automatic rollback
- Window focus and network reconnection sync

```js
function SynchronizationExample() {
  const queryClient = useQueryClient();

  // Query that syncs across all components
  const { data: messages, isLoading } = useQuery({
    queryKey: ['messages'],
    queryFn: () => fetch('/api/messages').then(res => res.json()),
    refetchOnWindowFocus: true, // Sync when window regains focus
    refetchOnReconnect: true, // Sync when network reconnects
    refetchIntervalInBackground: true, // Keep syncing in background
    refetchInterval: 5000, // Sync every 5 seconds
  });

  // Mutation with optimistic updates
  const sendMessageMutation = useMutation({
    mutationFn: (message) =>
      fetch('/api/messages', {
        method: 'POST',
        body: JSON.stringify(message)
      }).then(res => res.json()),
    onMutate: async (newMessage) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['messages'] });

      // Snapshot the previous value
      const previousMessages = queryClient.getQueryData(['messages']);

      // Optimistically update to the new value
      queryClient.setQueryData(['messages'], (old) => [
        ...old,
        {
          id: `temp-${Date.now()}`,
          ...newMessage,
          timestamp: new Date().toISOString(),
          status: 'sending' // Optimistic status
        }
      ]);

      return { previousMessages };
    },
    onSuccess: (data, variables, context) => {
      // Replace optimistic update with real data
      queryClient.setQueryData(['messages'], (old) =>
        old.map(msg =>
          msg.id.toString().startsWith('temp-') && msg.text === variables.text
            ? { ...data, status: 'sent' }
            : msg
        )
      );
    },
    onError: (err, newMessage, context) => {
      // Rollback to previous state
      queryClient.setQueryData(['messages'], context.previousMessages);
      console.error('Failed to send message:', err);
    },
    onSettled: () => {
      // Always invalidate to ensure consistency
      queryClient.invalidateQueries({ queryKey: ['messages'] });
    },
  });

  const deleteMessageMutation = useMutation({
    mutationFn: (messageId) =>
      fetch(`/api/messages/${messageId}`, { method: 'DELETE' }),
    onMutate: async (messageId) => {
      await queryClient.cancelQueries({ queryKey: ['messages'] });

      const previousMessages = queryClient.getQueryData(['messages']);

      // Optimistically remove the message
      queryClient.setQueryData(['messages'], (old) =>
        old.filter(msg => msg.id !== messageId)
      );

      return { previousMessages };
    },
    onError: (err, messageId, context) => {
      queryClient.setQueryData(['messages'], context.previousMessages);
    },
  });

  if (isLoading) return <div>Loading messages...</div>;

  return (
    <div>
      <h1>Chat Messages</h1>

      <div>
        {messages?.map(message => (
          <div key={message.id} style={{
            opacity: message.status === 'sending' ? 0.5 : 1,
            border: message.status === 'sending' ? '1px dashed gray' : 'none'
          }}>
            <span>{message.text}</span>
            <small> - {message.timestamp}</small>
            {message.status === 'sending' && <span> (sending...)</span>}
            <button onClick={() => deleteMessageMutation.mutate(message.id)}>
              Delete
            </button>
          </div>
        ))}
      </div>

      <button onClick={() =>
        sendMessageMutation.mutate({
          text: `Hello at ${new Date().toLocaleTimeString()}`
        })
      }>
        Send Message
      </button>
    </div>
  );
}

// Multi-user synchronization
function MultiUserSync() {
  const { data: onlineUsers } = useQuery({
    queryKey: ['online-users'],
    queryFn: () => fetch('/api/users/online').then(res => res.json()),
    refetchInterval: 10000, // Check every 10 seconds
  });

  const { data: sharedDocument } = useQuery({
    queryKey: ['shared-doc'],
    queryFn: () => fetch('/api/document').then(res => res.json()),
    refetchOnWindowFocus: true, // Sync when switching back to tab
    refetchInterval: 2000, // Real-time sync every 2 seconds
  });

  return (
    <div>
      <div>Online Users: {onlineUsers?.length}</div>
      <div>Document: {sharedDocument?.content}</div>
    </div>
  );
}
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Project-Based Learning with React Query

Like building a real house instead of just learning about bricks - you see how everything works together!

**Key Points:**
- Complete todo app with React Query
- Real-world patterns and best practices
- Error handling and loading states

```js
// Complete Todo App with React Query
import { QueryClient, QueryClientProvider, useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 10, // 10 minutes
      retry: 2,
      refetchOnWindowFocus: false,
    },
  },
});

function TodoApp() {
  return (
    <QueryClientProvider client={queryClient}>
      <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
        <h1>Todo App with React Query</h1>
        <AddTodoForm />
        <TodoList />
        <TodoStats />
      </div>
    </QueryClientProvider>
  );
}

function AddTodoForm() {
  const [text, setText] = useState('');
  const queryClient = useQueryClient();

  const addTodoMutation = useMutation({
    mutationFn: (newTodo) =>
      fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTodo),
      }).then(res => res.json()),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
      setText('');
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    }
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      addTodoMutation.mutate({
        text: text.trim(),
        completed: false,
        createdAt: new Date().toISOString(),
      });
    }
  };

  return (
    <form onSubmit={handleSubmit} style={{ marginBottom: '20px' }}>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add a new todo..."
        disabled={addTodoMutation.isLoading}
        style={{ padding: '8px', marginRight: '8px', width: '300px' }}
      />
      <button
        type="submit"
        disabled={addTodoMutation.isLoading || !text.trim()}
        style={{ padding: '8px 16px' }}
      >
        {addTodoMutation.isLoading ? 'Adding...' : 'Add Todo'}
      </button>
    </form>
  );
}

function TodoList() {
  const { data: todos, isLoading, error } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(res => res.json()),
  });

  if (isLoading) return <div>Loading todos...</div>;
  if (error) return <div>Error loading todos: {error.message}</div>;

  return (
    <div>
      {todos?.length === 0 ? (
        <p>No todos yet. Add one above!</p>
      ) : (
        <div>
          {todos?.map(todo => (
            <TodoItem key={todo.id} todo={todo} />
          ))}
        </div>
      )}
    </div>
  );
}

function TodoItem({ todo }) {
  const queryClient = useQueryClient();

  const updateTodoMutation = useMutation({
    mutationFn: (updatedTodo) =>
      fetch(`/api/todos/${todo.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedTodo),
      }).then(res => res.json()),
    onMutate: async (updatedTodo) => {
      await queryClient.cancelQueries({ queryKey: ['todos'] });
      const previousTodos = queryClient.getQueryData(['todos']);

      queryClient.setQueryData(['todos'], (old) =>
        old.map(t => t.id === todo.id ? { ...t, ...updatedTodo } : t)
      );

      return { previousTodos };
    },
    onError: (err, updatedTodo, context) => {
      queryClient.setQueryData(['todos'], context.previousTodos);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });

  const deleteTodoMutation = useMutation({
    mutationFn: () => fetch(`/api/todos/${todo.id}`, { method: 'DELETE' }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });

  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      padding: '8px',
      border: '1px solid #ddd',
      marginBottom: '4px',
      opacity: updateTodoMutation.isLoading ? 0.7 : 1
    }}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={(e) =>
          updateTodoMutation.mutate({ completed: e.target.checked })
        }
        style={{ marginRight: '8px' }}
      />
      <span style={{
        flex: 1,
        textDecoration: todo.completed ? 'line-through' : 'none'
      }}>
        {todo.text}
      </span>
      <button
        onClick={() => deleteTodoMutation.mutate()}
        disabled={deleteTodoMutation.isLoading}
        style={{ marginLeft: '8px', padding: '4px 8px' }}
      >
        {deleteTodoMutation.isLoading ? 'Deleting...' : 'Delete'}
      </button>
    </div>
  );
}

function TodoStats() {
  const { data: todos } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(res => res.json()),
  });

  const total = todos?.length || 0;
  const completed = todos?.filter(todo => todo.completed).length || 0;
  const remaining = total - completed;

  return (
    <div style={{
      marginTop: '20px',
      padding: '16px',
      backgroundColor: '#f5f5f5',
      borderRadius: '4px'
    }}>
      <h3>Statistics</h3>
      <p>Total: {total}</p>
      <p>Completed: {completed}</p>
      <p>Remaining: {remaining}</p>
      <p>Progress: {total > 0 ? Math.round((completed / total) * 100) : 0}%</p>
    </div>
  );
}

export default TodoApp;
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>


### Introduction to Testing in React

Like having a quality control inspector who checks every part of your car before it leaves the factory!

**Key Points:**

- Testing ensures your components work correctly and prevent bugs
- Different types: Unit tests, Integration tests, End-to-end tests
- React Testing Library focuses on testing user interactions

```js
// Simple component to test
function Welcome({ name, isLoggedIn }) {
  if (!isLoggedIn) {
    return <div>Please log in</div>;
  }

  return (
    <div>
      <h1>Welcome, {name}!</h1>
      <button onClick={() => alert('Logged out!')}>Logout</button>
    </div>
  );
}

// Basic test example
import { render, screen } from '@testing-library/react';
import Welcome from './Welcome';

test('shows login message when not logged in', () => {
  render(<Welcome name="John" isLoggedIn={false} />);

  expect(screen.getByText('Please log in')).toBeInTheDocument();
});

test('shows welcome message when logged in', () => {
  render(<Welcome name="John" isLoggedIn={true} />);

  expect(screen.getByText('Welcome, John!')).toBeInTheDocument();
  expect(screen.getByRole('button', { name: 'Logout' })).toBeInTheDocument();
});

// Testing user interactions
import { fireEvent } from '@testing-library/react';

test('shows alert when logout clicked', () => {
  // Mock window.alert
  window.alert = jest.fn();

  render(<Welcome name="John" isLoggedIn={true} />);

  const logoutButton = screen.getByRole('button', { name: 'Logout' });
  fireEvent.click(logoutButton);

  expect(window.alert).toHaveBeenCalledWith('Logged out!');
});

// Testing with different props
describe('Welcome component', () => {
  test('renders correctly with different names', () => {
    const names = ['Alice', 'Bob', 'Charlie'];

    names.forEach(name => {
      render(<Welcome name={name} isLoggedIn={true} />);
      expect(screen.getByText(`Welcome, ${name}!`)).toBeInTheDocument();
    });
  });
});
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Setting Up Jest & Component Testing

Like setting up a perfect workshop with all the right tools before you start building!

**Key Points:**

- Jest is the testing framework (comes with Create React App)
- React Testing Library provides utilities for testing React components
- Setup includes test files, matchers, and mock configurations

```js
// package.json - test dependencies
{
  "devDependencies": {
    "@testing-library/react": "^13.4.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/user-event": "^14.4.3",
    "jest": "^27.5.1"
  },
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}

// setupTests.js - global test setup
import '@testing-library/jest-dom';

// Optional: Custom matchers
expect.extend({
  toBeVisible(received) {
    const pass = received.style.display !== 'none';
    return {
      message: () => `expected element to ${pass ? 'not ' : ''}be visible`,
      pass,
    };
  }
});

// jest.config.js - Jest configuration
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapping: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/src/__mocks__/fileMock.js'
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/index.js',
    '!src/reportWebVitals.js'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};

// Component testing patterns
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p data-testid="count">Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

// Counter.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Counter from './Counter';

describe('Counter Component', () => {
  beforeEach(() => {
    render(<Counter />);
  });

  test('renders initial count', () => {
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');
  });

  test('increments count when increment button clicked', async () => {
    const user = userEvent.setup();
    const incrementButton = screen.getByRole('button', { name: 'Increment' });

    await user.click(incrementButton);

    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');
  });

  test('decrements count when decrement button clicked', async () => {
    const user = userEvent.setup();
    const decrementButton = screen.getByRole('button', { name: 'Decrement' });

    await user.click(decrementButton);

    expect(screen.getByTestId('count')).toHaveTextContent('Count: -1');
  });

  test('resets count when reset button clicked', async () => {
    const user = userEvent.setup();

    // First increment
    await user.click(screen.getByRole('button', { name: 'Increment' }));
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');

    // Then reset
    await user.click(screen.getByRole('button', { name: 'Reset' }));
    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');
  });
});

// Testing with custom render function
function customRender(ui, options = {}) {
  const AllTheProviders = ({ children }) => {
    return (
      <ThemeProvider theme="light">
        <Router>
          {children}
        </Router>
      </ThemeProvider>
    );
  };

  return render(ui, { wrapper: AllTheProviders, ...options });
}

// Custom hook testing
import { renderHook, act } from '@testing-library/react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
}

test('useCounter hook works correctly', () => {
  const { result } = renderHook(() => useCounter(5));

  expect(result.current.count).toBe(5);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(6);

  act(() => {
    result.current.reset();
  });

  expect(result.current.count).toBe(5);
});
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Mocking & Spying

Like having a stunt double who can pretend to be anyone and tell you exactly what happened during the scene!

**Key Points:**

- Mocks replace real functions/modules with fake implementations
- Spies watch function calls and track what happened
- Essential for testing external dependencies and side effects

```js
// Basic mocking examples
describe('Mocking Functions', () => {
  test('mock a simple function', () => {
    const mockFn = jest.fn();
    mockFn('hello', 'world');

    expect(mockFn).toHaveBeenCalledWith('hello', 'world');
    expect(mockFn).toHaveBeenCalledTimes(1);
  });

  test('mock with return value', () => {
    const mockFn = jest.fn();
    mockFn.mockReturnValue(42);

    expect(mockFn()).toBe(42);
  });

  test('mock with different return values', () => {
    const mockFn = jest.fn();
    mockFn
      .mockReturnValueOnce('first')
      .mockReturnValueOnce('second')
      .mockReturnValue('default');

    expect(mockFn()).toBe('first');
    expect(mockFn()).toBe('second');
    expect(mockFn()).toBe('default');
  });
});

// Mocking modules
// __mocks__/axios.js
export default {
  get: jest.fn(() => Promise.resolve({ data: {} })),
  post: jest.fn(() => Promise.resolve({ data: {} })),
};

// Component that uses axios
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    axios.get(`/api/users/${userId}`)
      .then(response => {
        setUser(response.data);
        setLoading(false);
      })
      .catch(() => {
        setLoading(false);
      });
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

// Testing with mocked axios
import axios from 'axios';
import { render, screen, waitFor } from '@testing-library/react';
import UserProfile from './UserProfile';

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('UserProfile with mocked axios', () => {
  beforeEach(() => {
    mockedAxios.get.mockClear();
  });

  test('displays user data when API call succeeds', async () => {
    const userData = { id: 1, name: 'John Doe', email: 'john@example.com' };
    mockedAxios.get.mockResolvedValue({ data: userData });

    render(<UserProfile userId={1} />);

    expect(screen.getByText('Loading...')).toBeInTheDocument();

    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });

    expect(mockedAxios.get).toHaveBeenCalledWith('/api/users/1');
  });

  test('displays error message when API call fails', async () => {
    mockedAxios.get.mockRejectedValue(new Error('API Error'));

    render(<UserProfile userId={1} />);

    await waitFor(() => {
      expect(screen.getByText('User not found')).toBeInTheDocument();
    });
  });
});

// Spying on real functions
describe('Spying Examples', () => {
  test('spy on console.log', () => {
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

    function greet(name) {
      console.log(`Hello, ${name}!`);
      return `Greeting sent to ${name}`;
    }

    const result = greet('Alice');

    expect(consoleSpy).toHaveBeenCalledWith('Hello, Alice!');
    expect(result).toBe('Greeting sent to Alice');

    consoleSpy.mockRestore();
  });

  test('spy on object methods', () => {
    const user = {
      name: 'John',
      greet() {
        return `Hello, I'm ${this.name}`;
      }
    };

    const greetSpy = jest.spyOn(user, 'greet');

    const greeting = user.greet();

    expect(greetSpy).toHaveBeenCalled();
    expect(greeting).toBe("Hello, I'm John");

    greetSpy.mockRestore();
  });

  test('spy with custom implementation', () => {
    const mathUtils = {
      add: (a, b) => a + b,
      multiply: (a, b) => a * b
    };

    const addSpy = jest.spyOn(mathUtils, 'add')
      .mockImplementation((a, b) => {
        console.log(`Adding ${a} + ${b}`);
        return a + b;
      });

    const result = mathUtils.add(2, 3);

    expect(addSpy).toHaveBeenCalledWith(2, 3);
    expect(result).toBe(5);
  });
});

// Mocking React Router
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => jest.fn(),
  useParams: () => ({ id: '123' }),
  useLocation: () => ({ pathname: '/users/123' })
}));

// Mocking local storage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
});

test('component uses localStorage', () => {
  localStorageMock.getItem.mockReturnValue('saved-data');

  render(<MyComponent />);

  expect(localStorageMock.getItem).toHaveBeenCalledWith('user-preferences');
});
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Testing Async Code

Like being a patient detective who waits for all the clues to arrive before solving the case!

**Key Points:**

- Use waitFor for elements that appear after async operations
- Mock API calls and promises for predictable testing
- Handle loading states, success, and error scenarios

```js
// Component with async operations
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/users');
      if (!response.ok) throw new Error('Failed to fetch');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const deleteUser = async (userId) => {
    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      setUsers(users.filter(user => user.id !== userId));
    } catch (err) {
      setError('Failed to delete user');
    }
  };

  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h1>Users ({users.length})</h1>
      {users.map(user => (
        <div key={user.id}>
          <span>{user.name}</span>
          <button onClick={() => deleteUser(user.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}

// Testing async component
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// Mock fetch globally
global.fetch = jest.fn();

describe('UserList Async Tests', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  test('displays loading state initially', () => {
    fetch.mockResolvedValue({
      ok: true,
      json: async () => []
    });

    render(<UserList />);

    expect(screen.getByText('Loading users...')).toBeInTheDocument();
  });

  test('displays users after successful fetch', async () => {
    const mockUsers = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' }
    ];

    fetch.mockResolvedValue({
      ok: true,
      json: async () => mockUsers
    });

    render(<UserList />);

    // Wait for loading to finish
    await waitFor(() => {
      expect(screen.queryByText('Loading users...')).not.toBeInTheDocument();
    });

    // Check if users are displayed
    expect(screen.getByText('Users (2)')).toBeInTheDocument();
    expect(screen.getByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();
  });

  test('displays error message when fetch fails', async () => {
    fetch.mockRejectedValue(new Error('Network error'));

    render(<UserList />);

    await waitFor(() => {
      expect(screen.getByText('Error: Network error')).toBeInTheDocument();
    });
  });

  test('deletes user when delete button clicked', async () => {
    const mockUsers = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' }
    ];

    // Mock initial fetch
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockUsers
    });

    render(<UserList />);

    // Wait for initial load
    await waitFor(() => {
      expect(screen.getByText('Alice')).toBeInTheDocument();
    });

    // Mock delete request
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({})
    });

    // Click delete button for Alice
    const deleteButton = screen.getAllByText('Delete')[0];
    fireEvent.click(deleteButton);

    // Wait for Alice to be removed
    await waitFor(() => {
      expect(screen.queryByText('Alice')).not.toBeInTheDocument();
    });

    expect(screen.getByText('Bob')).toBeInTheDocument();
    expect(fetch).toHaveBeenCalledWith('/api/users/1', { method: 'DELETE' });
  });
});

// Testing with React Query
function UserListWithQuery() {
  const { data: users, isLoading, error, refetch } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      {users?.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}

// Testing React Query component
import { QueryClient, QueryClientProvider } from 'react-query';

test('React Query component loads data', async () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });

  fetch.mockResolvedValue({
    ok: true,
    json: async () => [{ id: 1, name: 'Alice' }]
  });

  render(
    <QueryClientProvider client={queryClient}>
      <UserListWithQuery />
    </QueryClientProvider>
  );

  expect(screen.getByText('Loading...')).toBeInTheDocument();

  await waitFor(() => {
    expect(screen.getByText('Alice')).toBeInTheDocument();
  });
});

// Testing custom async hooks
function useAsyncUser(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;

    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();

        if (!cancelled) {
          setUser(userData);
          setLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
          setLoading(false);
        }
      }
    };

    fetchUser();

    return () => {
      cancelled = true;
    };
  }, [userId]);

  return { user, loading, error };
}

// Testing the custom hook
import { renderHook, waitFor } from '@testing-library/react';

test('useAsyncUser hook fetches user data', async () => {
  const mockUser = { id: 1, name: 'Alice' };

  fetch.mockResolvedValue({
    ok: true,
    json: async () => mockUser
  });

  const { result } = renderHook(() => useAsyncUser(1));

  expect(result.current.loading).toBe(true);
  expect(result.current.user).toBe(null);

  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });

  expect(result.current.user).toEqual(mockUser);
  expect(result.current.error).toBe(null);
});

// Testing with timers
function DelayedMessage() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const timer = setTimeout(() => {
      setMessage('Hello after 2 seconds!');
    }, 2000);

    return () => clearTimeout(timer);
  }, []);

  return <div>{message || 'Waiting...'}</div>;
}

test('displays message after delay', async () => {
  jest.useFakeTimers();

  render(<DelayedMessage />);

  expect(screen.getByText('Waiting...')).toBeInTheDocument();

  // Fast-forward time
  jest.advanceTimersByTime(2000);

  await waitFor(() => {
    expect(screen.getByText('Hello after 2 seconds!')).toBeInTheDocument();
  });

  jest.useRealTimers();
});
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>

### Project: Test Login Page & UI

Like building a complete security system test for your house - checking every door, window, and alarm!

**Key Points:**

- Complete testing of login form validation
- Testing user interactions and form submission
- Integration testing with authentication flow

```js
// LoginPage.js - Component to test
function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});
  const [loading, setLoading] = useState(false);
  const [loginSuccess, setLoginSuccess] = useState(false);

  const validateForm = () => {
    const newErrors = {};

    if (!email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!password) {
      newErrors.password = 'Password is required';
    } else if (password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) return;

    setLoading(true);

    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      if (response.ok) {
        const data = await response.json();
        localStorage.setItem('token', data.token);
        setLoginSuccess(true);
      } else {
        const errorData = await response.json();
        setErrors({ submit: errorData.message || 'Login failed' });
      }
    } catch (error) {
      setErrors({ submit: 'Network error. Please try again.' });
    } finally {
      setLoading(false);
    }
  };

  if (loginSuccess) {
    return (
      <div className="success-message">
        <h2>Login Successful!</h2>
        <p>Welcome back!</p>
      </div>
    );
  }

  return (
    <div className="login-page">
      <form onSubmit={handleSubmit} className="login-form">
        <h1>Login</h1>

        <div className="form-group">
          <label htmlFor="email">Email:</label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className={errors.email ? 'error' : ''}
            aria-describedby={errors.email ? 'email-error' : undefined}
          />
          {errors.email && (
            <span id="email-error" className="error-message" role="alert">
              {errors.email}
            </span>
          )}
        </div>

        <div className="form-group">
          <label htmlFor="password">Password:</label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className={errors.password ? 'error' : ''}
            aria-describedby={errors.password ? 'password-error' : undefined}
          />
          {errors.password && (
            <span id="password-error" className="error-message" role="alert">
              {errors.password}
            </span>
          )}
        </div>

        {errors.submit && (
          <div className="error-message" role="alert">
            {errors.submit}
          </div>
        )}

        <button
          type="submit"
          disabled={loading}
          className="submit-button"
        >
          {loading ? 'Logging in...' : 'Login'}
        </button>
      </form>
    </div>
  );
}

// LoginPage.test.js - Comprehensive test suite
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginPage from './LoginPage';

// Mock fetch
global.fetch = jest.fn();

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
Object.defineProperty(window, 'localStorage', { value: localStorageMock });

describe('LoginPage Component', () => {
  beforeEach(() => {
    fetch.mockClear();
    localStorageMock.setItem.mockClear();
    localStorageMock.getItem.mockClear();
  });

  // Rendering Tests
  describe('Rendering', () => {
    test('renders login form with all elements', () => {
      render(<LoginPage />);

      expect(screen.getByRole('heading', { name: 'Login' })).toBeInTheDocument();
      expect(screen.getByLabelText('Email:')).toBeInTheDocument();
      expect(screen.getByLabelText('Password:')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument();
    });

    test('form elements have correct attributes', () => {
      render(<LoginPage />);

      const emailInput = screen.getByLabelText('Email:');
      const passwordInput = screen.getByLabelText('Password:');

      expect(emailInput).toHaveAttribute('type', 'email');
      expect(passwordInput).toHaveAttribute('type', 'password');
      expect(emailInput).toHaveAttribute('id', 'email');
      expect(passwordInput).toHaveAttribute('id', 'password');
    });
  });

  // Form Validation Tests
  describe('Form Validation', () => {
    test('shows error when email is empty', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      const submitButton = screen.getByRole('button', { name: 'Login' });
      await user.click(submitButton);

      expect(screen.getByText('Email is required')).toBeInTheDocument();
      expect(screen.getByRole('alert')).toBeInTheDocument();
    });

    test('shows error when email is invalid', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'invalid-email');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Email is invalid')).toBeInTheDocument();
    });

    test('shows error when password is empty', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Password is required')).toBeInTheDocument();
    });

    test('shows error when password is too short', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), '123');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Password must be at least 6 characters')).toBeInTheDocument();
    });

    test('clears errors when valid input is entered', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      // First, trigger error
      await user.click(screen.getByRole('button', { name: 'Login' }));
      expect(screen.getByText('Email is required')).toBeInTheDocument();

      // Then enter valid email
      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');

      // Errors should be cleared when form is resubmitted
      fetch.mockResolvedValue({
        ok: true,
        json: async () => ({ token: 'fake-token' })
      });

      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.queryByText('Email is required')).not.toBeInTheDocument();
    });
  });

  // User Interaction Tests
  describe('User Interactions', () => {
    test('updates input values when user types', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      const emailInput = screen.getByLabelText('Email:');
      const passwordInput = screen.getByLabelText('Password:');

      await user.type(emailInput, 'user@example.com');
      await user.type(passwordInput, 'mypassword');

      expect(emailInput).toHaveValue('user@example.com');
      expect(passwordInput).toHaveValue('mypassword');
    });

    test('form can be submitted by pressing Enter', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      fetch.mockResolvedValue({
        ok: true,
        json: async () => ({ token: 'fake-token' })
      });

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');
      await user.keyboard('{Enter}');

      await waitFor(() => {
        expect(fetch).toHaveBeenCalledWith('/api/login', expect.any(Object));
      });
    });
  });

  // API Integration Tests
  describe('API Integration', () => {
    test('successful login saves token and shows success message', async () => {
      const user = userEvent.setup();
      const mockToken = 'mock-jwt-token';

      fetch.mockResolvedValue({
        ok: true,
        json: async () => ({ token: mockToken })
      });

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      expect(screen.getByText('Logging in...')).toBeInTheDocument();

      await waitFor(() => {
        expect(screen.getByText('Login Successful!')).toBeInTheDocument();
      });

      expect(localStorageMock.setItem).toHaveBeenCalledWith('token', mockToken);
      expect(fetch).toHaveBeenCalledWith('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'password123'
        })
      });
    });

    test('failed login shows error message', async () => {
      const user = userEvent.setup();

      fetch.mockResolvedValue({
        ok: false,
        json: async () => ({ message: 'Invalid credentials' })
      });

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'wrongpassword');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      await waitFor(() => {
        expect(screen.getByText('Invalid credentials')).toBeInTheDocument();
      });

      expect(localStorageMock.setItem).not.toHaveBeenCalled();
    });

    test('network error shows error message', async () => {
      const user = userEvent.setup();

      fetch.mockRejectedValue(new Error('Network error'));

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');
      await user.click(screen.getByRole('button', { name: 'Login' }));

      await waitFor(() => {
        expect(screen.getByText('Network error. Please try again.')).toBeInTheDocument();
      });
    });

    test('button is disabled during loading', async () => {
      const user = userEvent.setup();

      // Mock a slow response
      fetch.mockImplementation(() =>
        new Promise(resolve =>
          setTimeout(() => resolve({
            ok: true,
            json: async () => ({ token: 'token' })
          }), 100)
        )
      );

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');

      const submitButton = screen.getByRole('button', { name: 'Login' });
      await user.click(submitButton);

      expect(screen.getByRole('button', { name: 'Logging in...' })).toBeDisabled();

      await waitFor(() => {
        expect(screen.getByText('Login Successful!')).toBeInTheDocument();
      });
    });
  });

  // Accessibility Tests
  describe('Accessibility', () => {
    test('error messages have proper ARIA attributes', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      await user.click(screen.getByRole('button', { name: 'Login' }));

      const emailError = screen.getByText('Email is required');
      const passwordError = screen.getByText('Password is required');

      expect(emailError).toHaveAttribute('role', 'alert');
      expect(passwordError).toHaveAttribute('role', 'alert');
      expect(emailError).toHaveAttribute('id', 'email-error');
      expect(passwordError).toHaveAttribute('id', 'password-error');

      const emailInput = screen.getByLabelText('Email:');
      const passwordInput = screen.getByLabelText('Password:');

      expect(emailInput).toHaveAttribute('aria-describedby', 'email-error');
      expect(passwordInput).toHaveAttribute('aria-describedby', 'password-error');
    });

    test('form is keyboard navigable', async () => {
      const user = userEvent.setup();
      render(<LoginPage />);

      // Tab through form elements
      await user.tab();
      expect(screen.getByLabelText('Email:')).toHaveFocus();

      await user.tab();
      expect(screen.getByLabelText('Password:')).toHaveFocus();

      await user.tab();
      expect(screen.getByRole('button', { name: 'Login' })).toHaveFocus();
    });
  });

  // Edge Cases
  describe('Edge Cases', () => {
    test('handles multiple rapid submissions', async () => {
      const user = userEvent.setup();

      fetch.mockImplementation(() =>
        new Promise(resolve =>
          setTimeout(() => resolve({
            ok: true,
            json: async () => ({ token: 'token' })
          }), 100)
        )
      );

      render(<LoginPage />);

      await user.type(screen.getByLabelText('Email:'), 'test@example.com');
      await user.type(screen.getByLabelText('Password:'), 'password123');

      const submitButton = screen.getByRole('button', { name: 'Login' });

      // Rapidly click multiple times
      await user.click(submitButton);
      await user.click(submitButton);
      await user.click(submitButton);

      // Should only make one API call
      await waitFor(() => {
        expect(screen.getByText('Login Successful!')).toBeInTheDocument();
      });

      expect(fetch).toHaveBeenCalledTimes(1);
    });
  });
});
```

<br>

<br>

<br>

  **[⬆ Back to Top](#table-of-contents)**

##

##

<br>
